<!DOCTYPE html>
<html lang="cn">
<head>
<!-- 2025-08-15 Fri 22:21 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>X86-64架构下一个网卡中断的处理流程</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Cauchy(pqy7172@gmail.com)">
<link rel="stylesheet" href="../../org-manual.css" type="text/css">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">X86-64架构下一个网卡中断的处理流程</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org89aced1">1. 中断向量表初始化</a>
<ul>
<li><a href="#orgb0056eb">1.1. 外部中断向量表构造</a></li>
<li><a href="#orgfc39dd7">1.2. 注册外部中断向量表</a></li>
</ul>
</li>
<li><a href="#orgb382f4b">2. 一个网卡中断的触发与执行</a></li>
</ul>
</div>
</div>
<p>
本文以一个网卡中断的处理过程来研究X86-64的中断管理，这个调用流程如下：
</p>
<pre class="example" id="org1944459">
=&gt; e1000_intr
=&gt; __handle_irq_event_percpu
=&gt; handle_irq_event
=&gt; handle_fasteoi_irq
=&gt; __common_interrupt
=&gt; common_interrupt
=&gt; asm_common_interrupt
=&gt; e1000_clean_rx_irq
=&gt; e1000_clean
=&gt; __napi_poll
=&gt; net_rx_action
=&gt; handle_softirqs
=&gt; __irq_exit_rcu
=&gt; common_interrupt
=&gt; asm_common_interrupt
=&gt; finish_task_switch.isra.0
=&gt; __schedule
=&gt; schedule
=&gt; worker_thread
=&gt; kthread
=&gt; ret_from_fork
=&gt; ret_from_fork_asm
</pre>
<div id="outline-container-org89aced1" class="outline-2">
<h2 id="org89aced1"><span class="section-number-2">1.</span> 中断向量表初始化</h2>
<div class="outline-text-2" id="text-1">
<p>
X86-64的外部中断通过idt_setup_apic_and_irq_gates函数来注册，但是外部中断表本身的内容通过irq_entries_start符号描述。下面分这两方面来介绍X86-64的初始化。
</p>
</div>
<div id="outline-container-orgb0056eb" class="outline-3">
<h3 id="orgb0056eb"><span class="section-number-3">1.1.</span> 外部中断向量表构造</h3>
<div class="outline-text-3" id="text-1-1">
<p>
下面的汇编代码描述了外部中断向量表的内容：
</p>
<pre class="example" id="orga91d227">
	.align IDT_ALIGN
SYM_CODE_START(irq_entries_start)
    vector=FIRST_EXTERNAL_VECTOR
    .rept NR_EXTERNAL_VECTORS
	UNWIND_HINT_IRET_REGS
0 :
	ENDBR
	.byte	0x6a, vector
	jmp	asm_common_interrupt
	/* Ensure that the above is IDT_ALIGN bytes max */
	.fill 0b + IDT_ALIGN - ., 1, 0xcc
	vector = vector+1
    .endr
SYM_CODE_END(irq_entries_start)
</pre>
<p>
这里NR_EXTERNAL_VECTORS以及FIRST_EXTERNAL_VECTOR被如下方式定义：
</p>
<pre class="example" id="org37b9132">
/*
 * Posted interrupt notification vector for all device MSIs delivered to
 * the host kernel.
 */
#define POSTED_MSI_NOTIFICATION_VECTOR	0xeb

/*
 * IDT vectors usable for external interrupt sources start at 0x20.
 * (0x80 is the syscall vector, 0x30-0x3f are for ISA)
 */
#define FIRST_EXTERNAL_VECTOR		0x20

#ifdef CONFIG_X86_LOCAL_APIC
#define FIRST_SYSTEM_VECTOR		POSTED_MSI_NOTIFICATION_VECTOR
#else
#define FIRST_SYSTEM_VECTOR		NR_VECTORS
#endif
#define NR_EXTERNAL_VECTORS		(FIRST_SYSTEM_VECTOR - FIRST_EXTERNAL_VECTOR)
</pre>
<p>
X86-64架构对于中断号的使用是划分了范围的，0x20是外部中断向量的起始位置，所谓外部中断源是指硬件设备（如键盘、网卡、定时器等）通过中断控制器（如 PIC、APIC或Local APIC）触发的中断，这些外部设备都需要通过中断控制器再中断CPU。
</p>

<p>
现代x86-64架构一般都配置了CONFIG_X86_LOCAL_APIC，所以FIRST_SYSTEM_VECTOR就是POSTED_MSI_NOTIFICATION_VECTOR，POSTED_MSI_NOTIFICATION_VECTOR（向量号 0xEB）主要用在中断虚拟机化里，当设备通过 MSI（Message Signaled Interrupts）触发中断时，如果设备的中断目标是虚拟机（vCPU），并且这个vCPU正在运行，且它支持APICv，APIC会直接通过PI机制将中断注入到目标虚拟机。如果目标虚拟机vCPU未运行（例如调度到宿主机的其他线程上），则会触发POSTED_MSI_NOTIFICATION_VECTOR（0xEB）来通知宿主机，传统中断处理中，当设备向虚拟机发送中断时，通常需要以下步骤，首先触发中断导致虚拟机VM-Exit。然后宿主机内核处理中断后，再注入到虚拟机。这种方法会带来大量的性能开销，尤其是I/O密集型工作负载（如网卡或存储设备）会产生频繁的中断。使用POSTED_MSI_NOTIFICATION_VECTOR和PI机制后，如果目标vCPU正在运行，则直接将中断注入虚拟机，完全避免VM-Exit。如果目标vCPU未运行，仅在必要时通知宿主机处理，这大幅减少了VM-Exit的次数。
</p>

<p>
所以[0x20, 0xeb)共计203个向量号用于外部设备中断，低于0x20的中断号一般用于处理CPU内部异常，比如除0错误，调试以及Page Fault等，NMI使用的向量号也低于0x20。
</p>

<p>
使用.byte硬编码push指令的方式
</p>

<p>
最后反汇编vmlinux查看被编译出来的irq_entries_start符号处的指令，就类似下面的模式：
</p>
<pre class="example" id="orgf7e80f5">
ffffffff81e00230 &lt;irq_entries_start&gt;:
ffffffff81e00230:       f3 0f 1e fa             endbr64
ffffffff81e00234:       6a 20                   push   $0x20
ffffffff81e00236:       e9 05 13 00 00          jmp    ffffffff81e01540 &lt;asm_common_interrupt&gt;
ffffffff81e0023b:       cc                      int3
ffffffff81e0023c:       cc                      int3
ffffffff81e0023d:       cc                      int3
ffffffff81e0023e:       cc                      int3
ffffffff81e0023f:       cc                      int3
ffffffff81e00240:       f3 0f 1e fa             endbr64
ffffffff81e00244:       6a 21                   push   $0x21
ffffffff81e00246:       e9 f5 12 00 00          jmp    ffffffff81e01540 &lt;asm_common_interrupt&gt;
ffffffff81e0024b:       cc                      int3
ffffffff81e0024c:       cc                      int3
ffffffff81e0024d:       cc                      int3
ffffffff81e0024e:       cc                      int3
ffffffff81e0024f:       cc                      int3
</pre>
<p>
每个中断句柄入口的代码都是相似的几条指令，唯一的不同就是push到栈上的向量号不一样。注意每个中断句柄的入口，其第一条指令都是endbr64，这是因为内核开启了X86_KERNEL_IBT配置的缘故，该指令的作用是标记合法的间接跳转目标，确保控制流的安全性。所谓间接跳转，比如间接调用或中断处理程序入口（因为硬件会自动往中断句柄跳）。如果跳转到没有endbr64的地址，处理器会触发异常（#CP: Control Protection Exception），从而防御攻击。
</p>

<p>
.align IDT_ALIGN指明了接下来的汇编符号（代码）要对齐到某个字节，现代Intel处理器一般启用了IBT(Intel CET，Control-flow Enforcement Technology)，这是一种安全机制，用于防范间接分支跳转攻击，这些攻击会劫持程序的控制流，跳转到恶意代码或利用程序中合法代码片段进行恶意行为，启用了这个配置，就会对齐到16字节处。
</p>

<p>
.rept宏指令表示在它们之间的指令需要重复编出NR_EXTERNAL_VECTORS次.
</p>
</div>
</div>
<div id="outline-container-orgfc39dd7" class="outline-3">
<h3 id="orgfc39dd7"><span class="section-number-3">1.2.</span> 注册外部中断向量表</h3>
<div class="outline-text-3" id="text-1-2">
<p>
本节开始分析注册中断的函数idt_setup_apic_and_irq_gates：
</p>
<pre class="example" id="org52a102d">
/**
 * idt_setup_apic_and_irq_gates - Setup APIC/SMP and normal interrupt gates
 */
void __init idt_setup_apic_and_irq_gates(void)
{
	int i = FIRST_EXTERNAL_VECTOR;
	void *entry;

	idt_setup_from_table(idt_table, apic_idts, ARRAY_SIZE(apic_idts), true);

	for_each_clear_bit_from(i, system_vectors, FIRST_SYSTEM_VECTOR) {
		entry = irq_entries_start + IDT_ALIGN * (i - FIRST_EXTERNAL_VECTOR);
		set_intr_gate(i, entry);
	}

#ifdef CONFIG_X86_LOCAL_APIC
	for_each_clear_bit_from(i, system_vectors, NR_VECTORS) {
		/*
		 * Don't set the non assigned system vectors in the
		 * system_vectors bitmap. Otherwise they show up in
		 * /proc/interrupts.
		 */
		entry = spurious_entries_start + IDT_ALIGN * (i - FIRST_SYSTEM_VECTOR);
		set_intr_gate(i, entry);
	}
#endif
	/* Map IDT into CPU entry area and reload it. */
	idt_map_in_cea();
	load_idt(&amp;idt_descr);

	/* Make the IDT table read only */
	set_memory_ro((unsigned long)&amp;idt_table, 1);

	idt_setup_done = true;
}
</pre>
<p>
该函数主要分为几个部分，第一个部分是将apic_idts里的中断向量拷贝到idt_table里，第二部分针对前面还没有设置的向量，通过set_intr_gate继续往idt_table里设置，以上两部分设置完后其实都还是在内存里，所以最后的第三部分就是通过idt_map_in_cea将这个表设置好映射关系，并将这个中断表通过lidt指令加载到idt寄存器。
</p>

<p>
先分析第一部分，idt_setup_from_table函数：
</p>
<pre class="example" id="org558b1d2">
arch/x86/kernel/idt.c
static __init void
idt_setup_from_table(gate_desc *idt, const struct idt_data *t, int size, bool sys)
{
	gate_desc desc;

	for (; size &gt; 0; t++, size--) {
		idt_init_desc(&amp;desc, t);
		write_idt_entry(idt, t-&gt;vector, &amp;desc);
		if (sys)
			set_bit(t-&gt;vector, system_vectors);
	}
}
</pre>
<p>
这里首先介绍/分析apic_idts表：
</p>
<pre class="example" id="orgf8a2b74">
arch/x86/kernel/idt.c
/*
 * The APIC and SMP idt entries
 */
static const __initconst struct idt_data apic_idts[] = {
#ifdef CONFIG_SMP
	INTG(RESCHEDULE_VECTOR,			asm_sysvec_reschedule_ipi),
	INTG(CALL_FUNCTION_VECTOR,		asm_sysvec_call_function),
	INTG(CALL_FUNCTION_SINGLE_VECTOR,	asm_sysvec_call_function_single),
	INTG(REBOOT_VECTOR,			asm_sysvec_reboot),
#endif

#ifdef CONFIG_X86_THERMAL_VECTOR
	INTG(THERMAL_APIC_VECTOR,		asm_sysvec_thermal),
#endif

#ifdef CONFIG_X86_MCE_THRESHOLD
	INTG(THRESHOLD_APIC_VECTOR,		asm_sysvec_threshold),
#endif

#ifdef CONFIG_X86_MCE_AMD
	INTG(DEFERRED_ERROR_VECTOR,		asm_sysvec_deferred_error),
#endif

#ifdef CONFIG_X86_LOCAL_APIC
	INTG(LOCAL_TIMER_VECTOR,		asm_sysvec_apic_timer_interrupt),
	INTG(X86_PLATFORM_IPI_VECTOR,		asm_sysvec_x86_platform_ipi),
# if IS_ENABLED(CONFIG_KVM)
	INTG(POSTED_INTR_VECTOR,		asm_sysvec_kvm_posted_intr_ipi),
	INTG(POSTED_INTR_WAKEUP_VECTOR,		asm_sysvec_kvm_posted_intr_wakeup_ipi),
	INTG(POSTED_INTR_NESTED_VECTOR,		asm_sysvec_kvm_posted_intr_nested_ipi),
# endif
# ifdef CONFIG_IRQ_WORK
	INTG(IRQ_WORK_VECTOR,			asm_sysvec_irq_work),
# endif
	INTG(SPURIOUS_APIC_VECTOR,		asm_sysvec_spurious_apic_interrupt),
	INTG(ERROR_APIC_VECTOR,			asm_sysvec_error_interrupt),
# ifdef CONFIG_X86_POSTED_MSI
	INTG(POSTED_MSI_NOTIFICATION_VECTOR,	asm_sysvec_posted_msi_notification),
# endif
#endif
};
</pre>
<p>
以asm_sysvec_reschedule_ipi为例分析它的实现：
</p>
<pre class="example" id="org80b02d6">
DECLARE_IDTENTRY(RESCHEDULE_VECTOR,			sysvec_reschedule_ipi);
</pre>
<p>
而DECLARE_IDTENTRY会依据当前编译单元是.c文件或.S文件有不同的定义，对于.c来说：
</p>
<pre class="example" id="orgacec3b4">
arch/x86/include/asm/idtentry.h
/**
 * DECLARE_IDTENTRY - Declare functions for simple IDT entry points
 *		      No error code pushed by hardware
 * @vector:	Vector number (ignored for C)
 * @func:	Function name of the entry point
 *
 * Declares four functions:
 * - The ASM entry point: asm_##func
 * - The XEN PV trap entry point: xen_##func (maybe unused)
 * - The C handler called from the FRED event dispatcher (maybe unused)
 * - The C handler called from the ASM entry point
 *
 * Note: This is the C variant of DECLARE_IDTENTRY(). As the name says it
 * declares the entry points for usage in C code. There is an ASM variant
 * as well which is used to emit the entry stubs in entry_32/64.S.
 */
#define DECLARE_IDTENTRY(vector, func)					\
	asmlinkage void asm_##func(void);				\
	asmlinkage void xen_asm_##func(void);				\
	void fred_##func(struct pt_regs *regs);				\
	__visible void func(struct pt_regs *regs)
</pre>
<p>
以上只是给出了比如asm_sysvec_reschedule_ipi这样符号声明，但是对于编译汇编文件.S时再给出asm_sysvec_reschedule_ipi的定义：
</p>
<pre class="example" id="org6f9c62d">
arch/x86/include/asm/idtentry.h

#else /* !__ASSEMBLER__ */

/*
 * The ASM variants for DECLARE_IDTENTRY*() which emit the ASM entry stubs.
 */
#define DECLARE_IDTENTRY(vector, func)					\
	idtentry vector asm_##func func has_error_code=0
</pre>
<p>
identry是实现在arch/x86/entry/entry_64.S里的宏，用来给出参数asm_##func（也就是asm_sysvec_reschedule_ipi）符号的定义，idtentry实际抽象出了所有中断entry时需要做的公共动作，这样定义出的asm_sysvec_reschedule_ipi可以理解为中断发生后的第一个要跳转到的地址，具体里面的代码留待后面分析中断执行时再细节分析，这里可以通过反汇编vmlinux先搂一眼asm_sysvec_reschedule_ipi的指令级实现：
</p>
<pre class="example" id="org0a3ddc7">
ffffffff81e01630 &lt;asm_sysvec_reschedule_ipi&gt;:
ffffffff81e01630:       f3 0f 1e fa             endbr64
ffffffff81e01634:       90                      nop
ffffffff81e01635:       90                      nop
ffffffff81e01636:       90                      nop
ffffffff81e01637:       fc                      cld
ffffffff81e01638:       6a ff                   push   $0xffffffffffffffff
ffffffff81e0163a:       e8 f1 05 00 00          call   ffffffff81e01c30 &lt;error_entry&gt;
ffffffff81e0163f:       48 89 c4                mov    %rax,%rsp
ffffffff81e01642:       48 89 e7                mov    %rsp,%rdi
ffffffff81e01645:       e8 36 35 ef ff          call   ffffffff81cf4b80 &lt;sysvec_reschedule_ipi&gt;
ffffffff81e0164a:       e9 21 07 00 00          jmp    ffffffff81e01d70 &lt;error_return&gt;
ffffffff81e0164f:       90                      nop
</pre>
<p>
而asm_sysvec_reboot具有类似的结构：
</p>
<pre class="example" id="orga3e5bf1">
ffffffff81e01650 &lt;asm_sysvec_reboot&gt;:
ffffffff81e01650:       f3 0f 1e fa             endbr64
ffffffff81e01654:       90                      nop
ffffffff81e01655:       90                      nop
ffffffff81e01656:       90                      nop
ffffffff81e01657:       fc                      cld
ffffffff81e01658:       6a ff                   push   $0xffffffffffffffff
ffffffff81e0165a:       e8 d1 05 00 00          call   ffffffff81e01c30 &lt;error_entry&gt;
ffffffff81e0165f:       48 89 c4                mov    %rax,%rsp
ffffffff81e01662:       48 89 e7                mov    %rsp,%rdi
ffffffff81e01665:       e8 86 34 ef ff          call   ffffffff81cf4af0 &lt;sysvec_reboot&gt;
ffffffff81e0166a:       e9 01 07 00 00          jmp    ffffffff81e01d70 &lt;error_return&gt;
ffffffff81e0166f:       90                      nop
</pre>
<p>
可以想见，error_entry里就会有具体中断句柄（sysvec_reschedule_ipi/sysvec_reboot等）进入前的现场保存，而error_return里会有中断句柄返回前的现场恢复操作，而call sysvec_reschedule_ipi，其实就是宏汇编调用链：
</p>
<pre class="example" id="org08ed920">
identry-&gt;idtentry_body-&gt;call \cfunc，
</pre>
<p>
这里cfunc就是identry的第三个参数cfunc，在这个例子下就是上面DECLARE_IDTENTRY的第二个参数sysvec_reschedule_ipi：
</p>
<pre class="example" id="orgbd2cedf">
DECLARE_IDTENTRY(RESCHEDULE_VECTOR,			sysvec_reschedule_ipi);
</pre>
<p>
所以才有了上面贴的反汇编里有指令call sysvec_reschedule_ipi，那么这个符号又是哪里定义的呢？如下：
</p>
<pre class="example" id="org07badc8">
arch/x86/kernel/smp.c 

DEFINE_IDTENTRY_SYSVEC_SIMPLE(sysvec_reschedule_ipi)
{
	apic_eoi();
	trace_reschedule_entry(RESCHEDULE_VECTOR);
	inc_irq_stat(irq_resched_count);
	scheduler_ipi();
	trace_reschedule_exit(RESCHEDULE_VECTOR);
}
</pre>
<pre class="example" id="orgb422b29">
arch/x86/include/asm/idtentry.h

#define DEFINE_IDTENTRY_SYSVEC_SIMPLE(func)				\
static __always_inline void __##func(struct pt_regs *regs);		\
									\
static __always_inline void instr_##func(struct pt_regs *regs)		\
{									\
	__irq_enter_raw();						\
	__##func (regs);						\
	__irq_exit_raw();						\
}									\
									\
__visible noinstr void func(struct pt_regs *regs)			\
{									\
	irqentry_state_t state = irqentry_enter(regs);			\
									\
	kvm_set_cpu_l1tf_flush_l1d();                                   \
	instrumentation_begin();					\
	instr_##func (regs);						\
	instrumentation_end();						\
	irqentry_exit(regs, state);					\
}									\
									\
void fred_##func(struct pt_regs *regs)					\
{									\
	instr_##func (regs);						\
}									\
									\
static __always_inline void __##func(struct pt_regs *regs)
</pre>
<p>
注意这里最后的__##func的函数体就是前面的：
</p>
<pre class="example" id="org1d87545">
{
	apic_eoi();
	trace_reschedule_entry(RESCHEDULE_VECTOR);
	inc_irq_stat(irq_resched_count);
	scheduler_ipi();
	trace_reschedule_exit(RESCHEDULE_VECTOR);
}
</pre>
<p>
相当于说identry宏汇编里面会封装所有中断处理的公共逻辑比如保持/恢复现场，而具体的业务逻辑
（具体的某个中断号对应的处理逻辑）则由传进去的cfunc决定，这里是sysvec_reschedule_ipi符号，
类似使用这种的还有很多比如：
</p>
<pre class="example" id="org64df529">
DECLARE_IDTENTRY_SYSVEC(REBOOT_VECTOR,			sysvec_reboot);
</pre>
<p>
这些逻辑也体现了一种封装/继承的思想，未来打算将某个向量号XXX，分配给某个具体函数funcxxx处理时只需写：
</p>
<pre class="example" id="orgdd9efac">
DECLARE_IDTENTRY_SYSVEC(XXX, funcxxx)
</pre>
<p>
同时用类似DEFINE_IDTENTRY_SYSVEC_SIMPLE这样的宏来给出其具体的业务逻辑：
</p>
<pre class="example" id="orgec27ca2">
DEFINE_IDTENTRY_SYSVEC_SIMPLE(funcxxx)
</pre>
<p>
对于sysvec_reschedule_ipi的具体业务逻辑就是scheduler_ipi，而至于公共的中断处理逻辑，如下宏调用链会替我们操心处理好（并定义出相关符号可以调用）：
</p>
<pre class="example" id="org5a6f417">
DECLARE_IDTENTRY_SYSVEC-&gt;DECLARE_IDTENTRY-&gt;idtentry
</pre>

<p>
具体执行的这些细节留待后面中断执行时再分析，这里还是聚焦中断向量表的注册。
</p>

<p>
分析到目前，就是想回答说类似asm_sysvec_reschedule_ipi/asm_sysvec_reboot等这样的句柄有了定义（addr），那么INTG的实现就可以赋值了：
</p>
<pre class="example" id="org300fa52">
#define G(_vector, _addr, _ist, _type, _dpl, _segment)	\
	{						\
		.vector		= _vector,		\
		.bits.ist	= _ist,			\
		.bits.type	= _type,		\
		.bits.dpl	= _dpl,			\
		.bits.p		= 1,			\
		.addr		= _addr,		\
		.segment	= _segment,		\
	}

/* Interrupt gate */
#define INTG(_vector, _addr)				\
	G(_vector, _addr, DEFAULT_STACK, GATE_INTERRUPT, DPL0, __KERNEL_CS)
</pre>
<p>
这里比较关键的就是跳转地址给到了idt_data::addr，这样apic_idts表的内容就构造完了，回过头来看，apic_idts里其实就是除开0-31的cpu内部异常以及32-NR_EXTERNAL_VECTORS的外部中断的系统向量，主要是内核用来管理的比如重调度，让所有cpu执行某个函数等。
</p>

<p>
再回到idt_setup_apic_and_irq_gates-&gt;idt_setup_from_table函数，这里再贴下：
</p>
<pre class="example" id="org3dbabcd">
static __init void
idt_setup_from_table(gate_desc *idt, const struct idt_data *t, int size, bool sys)
{
	gate_desc desc;

	for (; size &gt; 0; t++, size--) {
		idt_init_desc(&amp;desc, t);
		write_idt_entry(idt, t-&gt;vector, &amp;desc);
		if (sys)
			set_bit(t-&gt;vector, system_vectors);
	}
}
</pre>
<p>
对于apic_idts里的所有条目，都要调用相应的函数进行处理，每个条目作为输入调用idt_init_desc函数：
</p>
<pre class="example" id="orgc32442c">
static inline void idt_init_desc(gate_desc *gate, const struct idt_data *d)
{
	unsigned long addr = (unsigned long) d-&gt;addr;

	gate-&gt;offset_low	= (u16) addr;
	gate-&gt;segment		= (u16) d-&gt;segment;
	gate-&gt;bits		= d-&gt;bits;
	gate-&gt;offset_middle	= (u16) (addr &gt;&gt; 16);
#ifdef CONFIG_X86_64
	gate-&gt;offset_high	= (u32) (addr &gt;&gt; 32);
	gate-&gt;reserved		= 0;
#endif
}
</pre>
<p>
这里可以看到，主要的逻辑是地址需要转换成low/middle/high部分，其它都是拷贝赋值，设置好gate_desc后，就调用write_idt_entry将这个中断描述符拷贝到全局表idt_table里，其实际实现就是native_write_idt_entry：
</p>
<pre class="example" id="org8c107d0">
static inline void native_write_idt_entry(gate_desc *idt, int entry, const gate_desc *gate)
{
	memcpy(&amp;idt[entry], gate, sizeof(*gate));
}
</pre>
<p>
这里entry传入的就是中断号，它也指明了应该将这个中断描述符拷贝到idt_table里的哪个位置。最后system_vectors是一个全局的bitmap，它记录了哪些中断已经被设置，并且主要针对sys vector（系统向量）才设置为true，也就是apic_idts里的向量。
</p>

<p>
继续往下看：
</p>
<pre class="example" id="orgc5f9ef2">
for_each_clear_bit_from(i, system_vectors, FIRST_SYSTEM_VECTOR) {
	entry = irq_entries_start + IDT_ALIGN * (i - FIRST_EXTERNAL_VECTOR);
	set_intr_gate(i, entry);
}
</pre>
<p>
这段代码主要是针对从第一个外部向量FIRST_SYSTEM_VECTOR开始，如果在system_vectors里还没有设置的话，就将irq_entries_start起始的向量条目的地址通过set_intr_gate设置到idt_table里：
</p>
<pre class="example" id="orgc49e19d">
static __init void set_intr_gate(unsigned int n, const void *addr)
{
	struct idt_data data;

	init_idt_data(&amp;data, n, addr);

	idt_setup_from_table(idt_table, &amp;data, 1, false);
}
</pre>
<p>
这里通过init_idt_data初始化一个idt_data，然后调用前面介绍过的idt_setup_from_table将irq_entries_start里的中断句柄也设置到idt_table里了，只不过注意这里最后一个参数是false，因为这是外部中断了，不是系统向量。
</p>

<p>
再往下的代码，是针对从i开始，在system_vectors里还没有设置向量的，要设置一个伪中断向量处理函数到idt_table，以作为一个兜底的处理手段，如果某个中断向量没有被内核分配给实际设备驱动（比如硬件根本没有使用这个向量），但硬件/芯片组错误地触发了这个中断，就会走到common_spurious-&gt;spurious_interrupt 这个入口。如果没有这个处理，CPU接到未注册向量的中断时会导致异常（或直接挂死），所以需要有一个安全的默认处理逻辑来“吃掉”它。比如某些老硬件、总线、电气干扰可能导致错误中断信号。在handle_spurious_interrupt里，内核不会尝试去真正处理这个中断，而是记录一次spurious interrupt计数（方便/proc/interrupts统计）。通常直接返回，不触发调度，也不应答给具体驱动。某些平台可能会尝试向APIC发送End-Of-Interrupt(EOI)以防止中断卡死。
</p>

<p>
spurious_entries_start定义如下：
</p>
<pre class="example" id="org8fd6268">
./arch/x86/include/asm/idtentry.h
SYM_CODE_START(spurious_entries_start)
    vector=FIRST_SYSTEM_VECTOR
    .rept NR_SYSTEM_VECTORS
	UNWIND_HINT_IRET_REGS
0 :
	ENDBR
	.byte	0x6a, vector
	jmp	asm_spurious_interrupt
	/* Ensure that the above is IDT_ALIGN bytes max */
	.fill 0b + IDT_ALIGN - ., 1, 0xcc
	vector = vector+1
    .endr
SYM_CODE_END(spurious_entries_start)
</pre>
<p>
asm_spurious_interrupt类似前面定义符号asm_sysvec_reschedule_ipi，在编译C文件时只有声明：
</p>
<pre class="example" id="org45f59c0">
arch/x86/include/asm/idtentry.h

DECLARE_IDTENTRY_IRQ(X86_TRAP_OTHER,	spurious_interrupt);

#define DECLARE_IDTENTRY_IRQ(vector, func)				\
	DECLARE_IDTENTRY_ERRORCODE(vector, func)

#define DECLARE_IDTENTRY_ERRORCODE(vector, func)			\
	asmlinkage void asm_##func(void);				\
	asmlinkage void xen_asm_##func(void);				\
	__visible void func(struct pt_regs *regs, unsigned long error_code)
</pre>
<p>
而在汇编.S文件时，才给出这个符号的定义：
</p>
<pre class="example" id="org4e56389">
arch/x86/include/asm/idtentry.h

#define DECLARE_IDTENTRY_ERRORCODE(vector, func)			\
	idtentry vector asm_##func func has_error_code=1
</pre>
<p>
这和前面介绍ipi中断时类似。
</p>

<p>
下一个要重点分析的就是idt_map_in_cea函数：
</p>
<pre class="example" id="orgc93f74f">
static void __init idt_map_in_cea(void)
{
	/*
	 * Set the IDT descriptor to a fixed read-only location in the cpu
	 * entry area, so that the "sidt" instruction will not leak the
	 * location of the kernel, and to defend the IDT against arbitrary
	 * memory write vulnerabilities.
	 */
	cea_set_pte(CPU_ENTRY_AREA_RO_IDT_VADDR, __pa_symbol(idt_table),
		    PAGE_KERNEL_RO);
	idt_descr.address = CPU_ENTRY_AREA_RO_IDT;
}
</pre>
<p>
这里首先介绍一个宏CPU_ENTRY_AREA_RO_IDT_VADDR：
</p>
<pre class="example" id="org339ded2">
arch/x86/include/asm/pgtable_areas.h 
#define CPU_ENTRY_AREA_RO_IDT_VADDR	((void *)CPU_ENTRY_AREA_RO_IDT)

/* Single page reserved for the readonly IDT mapping: */
#define CPU_ENTRY_AREA_RO_IDT		CPU_ENTRY_AREA_BASE
</pre>
<pre class="example" id="org2f2e0cb">
arch/x86/include/asm/pgtable_64_types.h
#define CPU_ENTRY_AREA_BASE	(CPU_ENTRY_AREA_PGD &lt;&lt; P4D_SHIFT)

#define CPU_ENTRY_AREA_PGD	_AC(-4, UL)
#define P4D_SHIFT		39
</pre>
<p>
也就是说，CPU_ENTRY_AREA_RO_IDT_VADDR最后的值就是0xfffffe0000000000，这是一个虚拟地址，x86-64下虚拟地址的分布介绍在Documentation/arch/x86/x86_64/mm.rst文件里，比如0000000000000000-00007fffffffefff共计128TB是用户空间的虚拟内存。而ffffc90000000000-ffffe8ffffffffff共计32TB是内核的vmalloc/ioremap空间了。
</p>

<p>
回到CPU_ENTRY_AREA_RO_IDT_VADDR（fffffe0000000000），fffffe0000000000-fffffe7fffffffff的512GB是cpu_entry_area mapping区域，这个区域就是提供类似idt表，可以进入中断处理代码，中断可以在用户态程序运行时产生，所以它是Page-Global页，这样的页用户态和内核态都可以访问，并且在任务切换或者写cr3时，page global的页不会刷tlb，也就是这样的页是固定映射，而cea_set_pte函数正是在完成这样的映射：
</p>
<pre class="example" id="org7d7cc6e">
void cea_set_pte(void *cea_vaddr, phys_addr_t pa, pgprot_t flags)
{
	unsigned long va = (unsigned long) cea_vaddr;
	pte_t pte = pfn_pte(pa &gt;&gt; PAGE_SHIFT, flags);

	/*
	 * The cpu_entry_area is shared between the user and kernel
	 * page tables.  All of its ptes can safely be global.
	 * _PAGE_GLOBAL gets reused to help indicate PROT_NONE for
	 * non-present PTEs, so be careful not to set it in that
	 * case to avoid confusion.
	 */
	if (boot_cpu_has(X86_FEATURE_PGE) &amp;&amp;
	    (pgprot_val(flags) &amp; _PAGE_PRESENT))
		pte = pte_set_flags(pte, _PAGE_GLOBAL);

	set_pte_vaddr(va, pte);
}
</pre>
<p>
整个函数是在设置各级页表的页表项内容，以完成虚拟地址到idt_table所在物理地址的映射，要映射到idt_table的物理地址，那么必须先知道idt_table的物理地址，这通过宏__pa_symbol做到，
</p>
</div>
</div>
</div>

<div id="outline-container-orgb382f4b" class="outline-2">
<h2 id="orgb382f4b"><span class="section-number-2">2.</span> 一个网卡中断的触发与执行</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cauchy(pqy7172@gmail.com)</p>
<p class="date">Created: 2025-08-15 Fri 22:21</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
