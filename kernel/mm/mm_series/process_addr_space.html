<!DOCTYPE html>
<html lang="cn">
<head>
<!-- 2021-07-25 Sun 11:28 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>进程地址空间</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Cauchy(pqy7172@gmail.com)">
<link rel="stylesheet" href="../../../org-manual.css" type="text/css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">进程地址空间</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orge2ca0b6">1. 线性地址空间</a></li>
<li><a href="#org89cd4e5">2. 管理地址空间</a></li>
<li><a href="#orgb48f4fe">3. 进程地址空间描述符</a>
<ul>
<li><a href="#org3f143c5">3.1. 分配mm_struct描述符</a></li>
<li><a href="#org84ffc51">3.2. 初始化描述符</a></li>
<li><a href="#orgfc0a652">3.3. 销毁mm_struct</a></li>
</ul>
</li>
<li><a href="#orgcac6733">4. 内存区域（regions）</a></li>
<li><a href="#orgf49a946">5. 异常处理</a></li>
<li><a href="#org334a7e7">6. Page Fault</a></li>
<li><a href="#org8be3456">7. 拷贝到/拷贝自用户空间</a></li>
</ul>
</div>
</div>
<p>
虚拟内存的一个主要优点是每个进程都可以有它自己的虚拟地址空间，而虚拟地址空间又由操作系统映射到物理内存．这章会讨论下进程地址空间以及Linux如何管理它．
</p>

<p>
内核对待用户地址空间和内核空间是很不同的．比如，对于内核的内存请求会立即满足，而且不论在CPU上运行的是什么进程都是全局可见的．而对于进程来说，请求的空间只是通过将页表条目指向一个只读的全局的初始化为0的页面，这样可以做到在线性地址空间里预留一部分空间．到写的时候，触发page fault，这时才会真正的分配页面，并且将这个条目放在页表里．
</p>

<p>
用户地址空间是不可信任以及不是一成不变的，在上下文切换后，用户地址空间部分有可能会改变．因此，内核必须能够捕获所有来自用户空间的异常和地址错误．
</p>

<p>
本文首先介绍线性地址是如何划分以及各个部分的目的．随后会介绍描述每个进程的结构体，这些结构体是如何被分配，初始化以及怎么销毁的．随后会介绍进程的地址空间是如何创建的以及相关联的函数．这些会引入关于进程地址空间的异常处理，pagefault等其它机制．最后会介绍下如何安全的向用户空间拷贝数据或者从用户空间拷贝数据到内核空间．
</p>

<div id="outline-container-orge2ca0b6" class="outline-2">
<h2 id="orge2ca0b6"><span class="section-number-2">1</span> 线性地址空间</h2>
<div class="outline-text-2" id="text-1">
<p>
从用户的观点来说，线性地址空间是平坦的．但是从内核空间来说就很不一样了．地址空间被划分为两部分，用户空间部分，在上下文切换后可能会改变，而内核空间，保持不变．而划分出这个位置的就是PAGE_OFFSET，对于X86来说这个值是0xC0000000．这意味着3GB留给进程，而1GB留给内核空间，内核所看到的地址空间划分如下图：
</p>

<div id="orge1c3c5a" class="figure">
<p><img src="./img/kas.png" alt="kas.png" width="50%" height="50%">
</p>
<p><span class="figure-number">Figure 1: </span>内核看到的地址空间</p>
</div>
</div>
</div>

<div id="outline-container-org89cd4e5" class="outline-2">
<h2 id="org89cd4e5"><span class="section-number-2">2</span> 管理地址空间</h2>
<div class="outline-text-2" id="text-2">
<p>
进程用到的地址空间，由mm_struct结构体管理着，它类似于BSD里的vmspace．
</p>

<p>
每个地址空间都由一些页对齐的内存组成，这些页不会重叠．进程虚拟地址空间里又分许多的region，这些region由struct vm_area_struct结构体表示，举个具体的例子，一个region(struct
vm_area_struct)可能代表由malloc分配出来的堆，针对共享库的内存映射文件，以及mmap出来的匿名内存．针对区域里的页，也许是等待分配，也许是活跃的，也许在物理内存里，也许换出了．
</p>

<p>
如果一个region映射到一个文件，那么它的vm_file就会被设置．通过vm_file(file)-&gt;f_mapping(address_space)-&gt;host(inode)就可找到对应的文件，不同结构体间的关系如下图：
</p>


<div id="org81c9c1b" class="figure">
<p><img src="./img/ds_as.png" alt="ds_as.png" width="30%" height="30%">
</p>
<p><span class="figure-number">Figure 2: </span>地址空间相关的结构体</p>
</div>

<p>
下面列出一些和内存区域相关的syscall：
</p>

<ul class="org-ul">
<li><p>
fork
</p>

<p>
创建一个新的进程并赋予一个新的地址空间．所有的页都被标记为Copy-On-Write（COW），并且这两个进程共享这些页，直到一个page fault缺页发生时．一旦一个写错误发生，对于引起错误的进程，将会拷贝一个新的COW页．
</p></li>

<li><p>
clone
</p>

<p>
clone允许一个新的进程按部分共享它的环境，以及怎样实现线程．不给clone传CLONE_VM的话，就会创建一个新的地址空间，这就和fork完全一样了．
</p></li>

<li><p>
mmap
</p>

<p>
mmap在进程的线性地址空间创建一个新的区域．
</p></li>

<li><p>
mremap
</p>

<p>
重新映射或者调整一段内存的大小．如果将要unmap的区域位于存在区域的中间，那么这个存在的区域将会被划分为两个独立的内存区域．
</p></li>

<li><p>
munmap
</p>

<p>
销毁部分或全部的内存区域．如果要被unmap的区域位于存在内存区域的中间，那么这个存在的区域将会被划分为两个独立的内存区域．
</p></li>

<li><p>
shmat
</p>

<p>
附加一个共享的内存段到进程地址空间．
</p></li>

<li><p>
shmdt
</p>

<p>
从进程地址空间移除一个共享内存段．
</p></li>

<li><p>
execve
</p>

<p>
加载一个新的可执行文件并且替代当前的进程地址空间．
</p></li>

<li><p>
exit
</p>

<p>
销毁地址空间．
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgb48f4fe" class="outline-2">
<h2 id="orgb48f4fe"><span class="section-number-2">3</span> 进程地址空间描述符</h2>
<div class="outline-text-2" id="text-3">
<p>
进程地址空间由mm_struct描述，就是说对于一个进程来说，仅有一个mm_struct，并且这个mm_struct由用户线程共享．实际上，线程的寻找方式就是，找出所有指向同一个mm_strcut的task_struct(s).
</p>

<p>
对于内核线程来说mm_struct是不需要的，因为除了vmalloc其它情况是不会page fault的．
</p>

<p>
mm_struct有两个引用计数成员，mm_user和mm_count．mm_user计数了有多少个进程访问mm_struct的用户空间部分．mm_count则是计数了对于mm_struct整个空间有多少用户在使用．当这个计数器降到0时，mm_struct就会被销毁．
</p>

<p>
mm_struct结构体成员如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">mm_struct</span> {
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">vm_area_struct</span> *<span style="color: #DFAF8F;">mmap</span>
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> rb_root mm_rb;
    <span style="color: #7CB8BB;">pgd_t</span> * <span style="color: #DFAF8F;">pgd</span>;
    <span style="color: #7CB8BB;">atomic_t</span> <span style="color: #DFAF8F;">mm_users</span>;
    <span style="color: #7CB8BB;">atomic_t</span> <span style="color: #DFAF8F;">mm_count</span>;
    <span style="color: #7CB8BB;">spinlock_t</span> <span style="color: #DFAF8F;">page_table_lock</span>;
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">list_head</span> <span style="color: #DFAF8F;">mmlist</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">long</span> <span style="color: #DFAF8F;">start_code</span>, <span style="color: #DFAF8F;">end_code</span>, <span style="color: #DFAF8F;">start_data</span>, <span style="color: #DFAF8F;">end_data</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">long</span> <span style="color: #DFAF8F;">start_brk</span>, <span style="color: #DFAF8F;">brk</span>, <span style="color: #DFAF8F;">start_stack</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">long</span> <span style="color: #DFAF8F;">arg_start</span>, <span style="color: #DFAF8F;">arg_end</span>, <span style="color: #DFAF8F;">env_start</span>, <span style="color: #DFAF8F;">env_end</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">long</span> <span style="color: #DFAF8F;">total_vm</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">long</span> <span style="color: #DFAF8F;">locked_vm</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">long</span> <span style="color: #DFAF8F;">def_flags</span>;
    <span style="color: #7CB8BB;">mm_context_t</span> <span style="color: #DFAF8F;">context</span>;
}

</pre>
</div>
<p>
下面解释下各个成员的意义：
</p>
<ul class="org-ul">
<li>mmap：在地址空间中所有VMA的头vma．</li>
<li>mm_rb：VMAs组织成链表或者红黑树的形式，红黑树是为了快速查询，该成员就是这颗树的根．</li>
<li>pgd：该进程的pgd．</li>
<li>mm_users：访问地址空间的用户空间部分的用户数．</li>
<li>mm_count：mm_struct的用户数．</li>
<li>page_table_lock：保护在mm_struct中的成员，包括page table等．</li>
<li>mmlist：所有的mm_structs通过这个成员连接起来．</li>
<li>start_code，end_code：代码段的开始和结束位置．</li>
<li>start_data，end_data：数据段的开始和结束位置．</li>
<li>start_brk，brk：堆的开始和结束位置．</li>
<li>start_stack：栈的开始位置．</li>
<li>arg_start，arg_end：命令行参数的开始和结尾处．</li>
<li>env_start，env_end：环境变量的开始和结束处．</li>
<li>total_vm：进程里被所有VMA占有的虚拟内存空间．</li>
<li>locked_vm：锁在内存中的常驻页面，也就是设置有PG_mlocked的页面．</li>
<li>def_flags：仅可能有一个值，VM_LOCKED，用来表征未来的映射是否都是上锁的．</li>
<li>context：架构相关的MMU上下文．</li>
</ul>

<p>
下面介绍几个函数用来处理mm_struct结构体：<br>
mm_init()：设置mm_struct中成员的初始值，比如PGD，初始化锁等．<br>
allocate_mm：从slab分配器中分配一个mm_struct结构体．<br>
mm_alloc：通过调用allocate_mm分配mm_struct，并用mm_init来初始化．<br>
exit_mmap：遍历mm_struct，解除所有的VMA映射．<br>
copy_mm：仅在fork中使用，将当前的mm_struct精确的拷贝一份到新的任务中．<br>
free_mm：将mm_struct返回到slab分配器．
</p>
</div>

<div id="outline-container-org3f143c5" class="outline-3">
<h3 id="org3f143c5"><span class="section-number-3">3.1</span> 分配mm_struct描述符</h3>
<div class="outline-text-3" id="text-3-1">
<p>
有两个函数可以用于分配mm_struct，它们看起来容易混淆．一是allocate_mm，它是一个预定义的宏，单纯从slab allocator里分配mm_struct．而mm_alloc除了调用allocate_mm分配一个mm_struct，还得调用mm_init初始化．
</p>
</div>
</div>

<div id="outline-container-org84ffc51" class="outline-3">
<h3 id="org84ffc51"><span class="section-number-3">3.2</span> 初始化描述符</h3>
<div class="outline-text-3" id="text-3-2">
<p>
系统里的第一个mm_struct叫做init_mm．后面的mm_struct都是父进程mm_struct的拷贝．init_mm在编译时静态的初始化好了．如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">mm_struct</span> <span style="color: #DFAF8F;">init_mm</span> = {
    .mm_rb      = RB_ROOT,
    .pgd        = swapper_pg_dir,
    .mm_users   = ATOMIC_INIT(2),
    .mm_count   = ATOMIC_INIT(1),
    .write_protect_seq = SEQCNT_ZERO(init_mm.write_protect_seq),
    MMAP_LOCK_INITIALIZER(init_mm)
    .page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),
    .arg_lock   =  __SPIN_LOCK_UNLOCKED(init_mm.arg_lock),
    .mmlist     = LIST_HEAD_INIT(init_mm.mmlist),
    .user_ns    = &amp;init_user_ns,
    .cpu_bitmap = CPU_BITS_NONE,
    INIT_MM_CONTEXT(init_mm)
};
</pre>
</div>

<p>
而复制mm_struct的函数是copy_mm．
</p>
</div>
</div>

<div id="outline-container-orgfc0a652" class="outline-3">
<h3 id="orgfc0a652"><span class="section-number-3">3.3</span> 销毁mm_struct</h3>
<div class="outline-text-3" id="text-3-3">
<p>
使用atomic_inc(&amp;mm-&gt;mm_users)可以增加用户计数，而mmput会递减这个数字．如果减到0，所有的映射就都会被exit_mmap取消．
</p>
</div>
</div>
</div>
<div id="outline-container-orgcac6733" class="outline-2">
<h2 id="orgcac6733"><span class="section-number-2">4</span> 内存区域（regions）</h2>
<div class="outline-text-2" id="text-4">
<p>
一个进程的完整地址空间是很少使用到的，仅有稀疏的几个区域会被用到，这样的每个区域被vm_area_struct结构体表示，这样的vm_area_struct不会重叠，并且一个vm_area_struct内具有相同的保护目的．举个例子，一个只读的共享库就会被加载到同一个地址空间（内存区域）．通过/proc/PID/maps可以查看一个进程映射的所有内存区域．
</p>

<p>
一个内存区域可以有许多不同的结构体，就vm_area_struct它自己可以用来表示匿名内存．
</p>

<p>
如果一个内存区域映射到文件，file类型的vm_file成员可以代表这个文件．它有类型为struct inode指针的成员，而inode又有struct address_space，这里面包括了文件的私有信息，包括许多函数指针用来执行特定于文件系统相关的一些操作，比如读写一个页到磁盘．
</p>

<p>
vm_area_struct定义如下：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">vm_area_struct</span> {
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">long</span> <span style="color: #DFAF8F;">vm_start</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf49a946" class="outline-2">
<h2 id="orgf49a946"><span class="section-number-2">5</span> 异常处理</h2>
</div>

<div id="outline-container-org334a7e7" class="outline-2">
<h2 id="org334a7e7"><span class="section-number-2">6</span> Page Fault</h2>
</div>

<div id="outline-container-org8be3456" class="outline-2">
<h2 id="org8be3456"><span class="section-number-2">7</span> 拷贝到/拷贝自用户空间</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cauchy(pqy7172@gmail.com)</p>
<p class="date">Created: 2021-07-25 Sun 11:28</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
