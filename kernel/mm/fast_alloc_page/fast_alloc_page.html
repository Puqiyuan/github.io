<!DOCTYPE html>
<html lang="cn">
<head>
<!-- 2024-11-04 Mon 22:24 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>物理页面分配之快速路径</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Cauchy(pqy7172@gmail.com)">
<link rel="stylesheet" href="../../../org-manual.css" type="text/css">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">物理页面分配之快速路径</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb7581bd">1. alloc_pages_noprof</a></li>
</ul>
</div>
</div>
<p>
本文分析在理想情况下，也就是没有内存短缺时内核通过伙伴系统分配物理页面的流程。物理页面分配的接口包括alloc_pages，这个函数在成功分配时返回的是第一个页面的page数据结构。另外一类接口是__get_free_pages，返回的是内核空间的虚拟地址。本文主要以alloc_pages为入口，分析内核是如何在理想情况下经过快速路径去分配物理页面的，alloc_pages就是一个简单的宏定义，主要调用alloc_pages_noprof。
</p>

<div id="outline-container-orgb7581bd" class="outline-2">
<h2 id="orgb7581bd"><span class="section-number-2">1.</span> alloc_pages_noprof</h2>
<div class="outline-text-2" id="text-1">
<p>
<b>原型：</b>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">page</span> *<span style="color: #93E0E3;">alloc_pages_noprof</span>(<span style="color: #7CB8BB;">gfp_t</span> <span style="color: #DFAF8F;">gfp</span>, <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">order</span>)
</pre>
</div>
<p>
<b>作用：</b>
</p>

<p>
分配2^order个连续页面，第一个物理页面自然对齐，所谓自然对齐，举个例子假如order为3，那么就会对齐到2^3*PAGE_SIZE的字节处。当在进程上下文时，会遵循NUMA分配策略。分配失败时返回NULL。
</p>

<p>
<b>详细分析：</b>
</p>

<p>
参数gfp的类型是gfp_t：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">typedef</span> <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span> <span style="color: #7CB8BB;">__bitwise</span> gfp_t;
</pre>
</div>
<p>
__bitwise主要是为了类型安全而存在，比如gfp_t类型的量不能和int类型的量进行运算和直接赋值（除非进行了类型强制转换），否则开启了Wall的编译选项时，编译器会报警告，它是编译器支持的一
个attribute。GFP标志主要用来指明内存应该如何分配，比如典型的由GFP推出内存应该在哪个zone中去分配。GFP这个缩写其实是get_free_pages，__开头这样的GFP标志比较底层，一般的用户应该使用GFP_KERNEL这样的由__开头的标志形成的组合。
</p>

<p>
该函数会根据当前上下文是进程上下文还是中断上下文，分不同的情况传入不同的参数pol（类型为mempolicy）去调用alloc_pages_mpol_noprof函数，定义如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">page</span> *<span style="color: #93E0E3;">alloc_pages_noprof</span>(<span style="color: #7CB8BB;">gfp_t</span> <span style="color: #DFAF8F;">gfp</span>, <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">order</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">mempolicy</span> *<span style="color: #DFAF8F;">pol</span> = &amp;default_policy;

        <span style="color: #5F7F5F;">/*</span>
<span style="color: #7F9F7F;">         * No reference counting needed for current-&gt;mempolicy</span>
<span style="color: #7F9F7F;">         * nor system default_policy</span>
<span style="color: #5F7F5F;">         */</span>
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>in_interrupt() &amp;&amp; <span style="color: #F0DFAF; font-weight: bold;">!</span>(gfp &amp; __GFP_THISNODE))
                pol = get_task_policy(current);

        <span style="color: #F0DFAF; font-weight: bold;">return</span> alloc_pages_mpol_noprof(gfp, order, pol, NO_INTERLEAVE_INDEX,
                                       numa_node_id());
}
</pre>
</div>
<p>
在不处于中断上下文并且传入的GFP标志位没有__GFP_THISNODE时，内存的NUMA分配策略才会生效。那么如何判定是不是在中断上下文呢，__GFP_THISNODE究竟是什么意思呢，还有其它的NUMA策略标志吗？
</p>

<p>
判断是否在中断上下文中使用in_interrupt：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">in_interrupt</span>()          (irq_count())
</pre>
</div>
<p>
在没有定义CONFIG_PREEMPT_RT的情况下，irq_count被如下定义：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;"># define</span> <span style="color: #93E0E3;">irq_count</span>()            (preempt_count() &amp; (NMI_MASK | HARDIRQ_MASK | SOFTIRQ_MASK))
</pre>
</div>

<p>
preempt_count在通用头文件include/asm-generic/preempt.h与架构头文件arch/x86/include/asm/preempt.h中均有定义，但是一般是架构头文件优先使用，这种优先特性体现在Makefile中对头文件使用-I选项包含头文件的先后上，preempt_count在上述两个头文件中均有实现，但是-I选项只要找到第一个有实现的头文件即停止搜索：
</p>
<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #DFAF8F;">LINUXINCLUDE</span>    := \
                -I$(<span style="color: #DFAF8F;">srctree</span>)/arch/$(<span style="color: #DFAF8F;">SRCARCH</span>)/include \
                -I$(<span style="color: #DFAF8F;">objtree</span>)/arch/$(<span style="color: #DFAF8F;">SRCARCH</span>)/include/generated \
                $(<span style="color: #DFAF8F;">if</span> $(<span style="color: #DFAF8F;">building_out_of_srctree</span>),-I$(<span style="color: #DFAF8F;">srctree</span>)/include) \
                -I$(<span style="color: #DFAF8F;">objtree</span>)/include \
                $(<span style="color: #DFAF8F;">USERINCLUDE</span>)
export KBUILD_CPPFLAGS NOSTDINC_FLAGS LINUXINCLUDE OBJCOPYFLAGS KBUILD_LDFLAGS
</pre>
</div>

<p>
X86架构下，preempt_count被如下定义：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">__always_inline</span> <span style="color: #7CB8BB;">int</span> preempt_count(<span style="color: #7CB8BB;">void</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">return</span> raw_cpu_read_4(pcpu_hot.preempt_count) &amp; ~PREEMPT_NEED_RESCHED;
}
</pre>
</div>
<p>
也就是说每个CPU都有一个4字节的int量preempt_count表征现在的抢占计数，这32个bit按如下划分：
</p>
<pre class="example" id="org98d8ec2">
        PREEMPT_MASK:	0x000000ff
        SOFTIRQ_MASK:	0x0000ff00
        HARDIRQ_MASK:	0x000f0000
            NMI_MASK:	0x00f00000
PREEMPT_NEED_RESCHED:	0x80000000
</pre>
<p>
也就是说最低8个bit（最低1个字节）用来计数抢占，低第二个字节用来表示软中断的计数，依次类推，那么NMI_MASK、HARDIRQ_MASK以及SOFTIRQ_MASK等各种MASK宏用来取出对应字段计数的，就可以按如下代码定出：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">PREEMPT_BITS</span>    8
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">SOFTIRQ_BITS</span>    8
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">HARDIRQ_BITS</span>    4
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">NMI_BITS</span>        4

<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">PREEMPT_SHIFT</span>   0
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">SOFTIRQ_SHIFT</span>   (PREEMPT_SHIFT + PREEMPT_BITS)
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">HARDIRQ_SHIFT</span>   (SOFTIRQ_SHIFT + SOFTIRQ_BITS)
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">NMI_SHIFT</span>       (HARDIRQ_SHIFT + HARDIRQ_BITS)

<span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">__IRQ_MASK</span>(<span style="color: #DFAF8F;">x</span>)   ((1UL &lt;&lt; (x))-1)

<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">PREEMPT_MASK</span>    (__IRQ_MASK(PREEMPT_BITS) &lt;&lt; PREEMPT_SHIFT)
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">SOFTIRQ_MASK</span>    (__IRQ_MASK(SOFTIRQ_BITS) &lt;&lt; SOFTIRQ_SHIFT)
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">HARDIRQ_MASK</span>    (__IRQ_MASK(HARDIRQ_BITS) &lt;&lt; HARDIRQ_SHIFT)
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">NMI_MASK</span>        (__IRQ_MASK(NMI_BITS)     &lt;&lt; NMI_SHIFT)
</pre>
</div>

<p>
所以回到前面irq_count的定义以及回答如何判定是不是在中断上下文中：只要不可屏蔽中断、硬中断以及软中断三者有其一即可认为当前处于中断上下文中。
</p>

<p>
__GFP_THISNODE标志主要作用是表明从指定的节点上分配内存，禁止分配回退或使用其它策略，如果请求的节点没有足够的内存资源，那么分配将会失败，这种情况自然不需要考虑NUMA内存分配策略了。除了这个标志还有如下的一些移动和放置策略：
</p>

<ul class="org-ul">
<li>__GFP_MOVABLE <br>
表示页面是可移动的。这个标志通常用于那些可以在内存整理（compaction）过程中通过页面迁移移动的页面，或是可以被回收的页面。在内存管理中，标记为__GFP_MOVABLE的页面将被放置在特定的pageblocks中，这些pageblocks一般只包含可移动页面，以尽量减少外部碎片的问题。</li>

<li>__GFP_RECLAIMABLE <br>
主要用于slab分配。指定了SLAB_RECLAIM_ACCOUNT的slab分配使用该标志，这些页面可以通过shrinker机制回收。这使得slab分配的内存可以在系统需要时被回收，以便释放更多的内存资源。</li>

<li>__GFP_WRITE <br>
表示调用者打算修改页面内容，即页面将被“写脏”（dirty）。内核在分配这些页面时，会尽量将这些页面在本地节点之间进行分散分配，以避免所有脏页集中在同一个内存区域或节点，帮助实现公平的内存分配策略（fair zone allocation policy）。</li>

<li>__GFP_HARDWALL <br>
强制执行cpuset的内存分配策略。如果系统中存在cpuset配置（用于控制和隔离不同任务的内存使用），这个标志确保页面分配遵循cpuset的内存限制和隔离策略。</li>

<li>__GFP_ACCOUNT <br>
该标志表示分配的内存将被记账到kmemcg（Kernel Memory Control Group），即为分配的内存计入内核内存控制组。它用于限制和跟踪控制组（cgroup）中分配的内核内存资源。</li>
</ul>

<p>
当既不在中断上下文gfp参数也没有设置__GFP_THISNODE时，就会调用get_task_policy函数：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">mempolicy</span> *<span style="color: #93E0E3;">get_task_policy</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">task_struct</span> *<span style="color: #DFAF8F;">p</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">mempolicy</span> *<span style="color: #DFAF8F;">pol</span> = p-&gt;mempolicy;
        <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">node</span>;

        <span style="color: #F0DFAF; font-weight: bold;">if</span> (pol)
                <span style="color: #F0DFAF; font-weight: bold;">return</span> pol;

        node = numa_node_id();
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (node != NUMA_NO_NODE) {
                pol = &amp;preferred_node_policy[node];
                <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">preferred_node_policy is not initialised early in boot</span><span style="color: #5F7F5F;"> */</span>
                <span style="color: #F0DFAF; font-weight: bold;">if</span> (pol-&gt;mode)
                        <span style="color: #F0DFAF; font-weight: bold;">return</span> pol;
        }

        <span style="color: #F0DFAF; font-weight: bold;">return</span> &amp;default_policy;
}
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cauchy(pqy7172@gmail.com)</p>
<p class="date">Created: 2024-11-04 Mon 22:24</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
