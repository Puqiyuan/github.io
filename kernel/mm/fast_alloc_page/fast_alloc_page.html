<!DOCTYPE html>
<html lang="cn">
<head>
<!-- 2024-11-06 Wed 23:26 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>物理页面分配之快速路径</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Cauchy(pqy7172@gmail.com)">
<link rel="stylesheet" href="../../../org-manual.css" type="text/css">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">物理页面分配之快速路径</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9b64485">1. alloc_pages_noprof</a></li>
<li><a href="#orgedc822c">2. alloc_pages_mpol_noprof</a></li>
<li><a href="#orgc5ea259">3. 附节</a>
<ul>
<li><a href="#org8dc70fb">3.1. get_vma_policy生成ilx</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
本文分析在理想情况下，也就是没有内存短缺时内核通过伙伴系统分配物理页面的流程。物理页面分配的接口包括alloc_pages，这个函数在成功分配时返回的是第一个页面的page数据结构。另外一类接口是__get_free_pages，返回的是内核空间的虚拟地址。本文主要以alloc_pages为入口，分析内核是如何在理想情况下经过快速路径去分配物理页面的，alloc_pages就是一个简单的宏定义，主要调用alloc_pages_noprof。
</p>

<div id="outline-container-org9b64485" class="outline-2">
<h2 id="org9b64485"><span class="section-number-2">1.</span> alloc_pages_noprof</h2>
<div class="outline-text-2" id="text-1">
<p>
<b>原型：</b>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">page</span> *<span style="color: #93E0E3;">alloc_pages_noprof</span>(<span style="color: #7CB8BB;">gfp_t</span> <span style="color: #DFAF8F;">gfp</span>, <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">order</span>)
</pre>
</div>
<p>
<b>作用：</b>
</p>

<p>
分配2^order个连续页面，第一个物理页面自然对齐，所谓自然对齐，举个例子假如order为3，那么就会对齐到2^3*PAGE_SIZE的字节处。当在进程上下文时，会遵循NUMA分配策略。分配失败时返回NULL。
</p>

<p>
<b>详细分析：</b>
</p>

<p>
参数gfp的类型是gfp_t：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">typedef</span> <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span> <span style="color: #7CB8BB;">__bitwise</span> gfp_t;
</pre>
</div>
<p>
__bitwise主要是为了类型安全而存在，比如gfp_t类型的量不能和int类型的量进行运算和直接赋值（除非进行了类型强制转换），否则开启了Wall的编译选项时，编译器会报警告，它是编译器支持的一
个attribute。GFP标志主要用来指明内存应该如何分配，比如典型的由GFP推出内存应该在哪个zone中去分配。GFP这个缩写其实是get_free_pages，__开头这样的GFP标志比较底层，一般的用户应该使用GFP_KERNEL这样的由__开头的标志形成的组合。
</p>

<p>
该函数会根据当前上下文是进程上下文还是中断上下文，分不同的情况传入不同的参数pol（类型为mempolicy）去调用alloc_pages_mpol_noprof函数，alloc_pages_noprof定义如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">page</span> *<span style="color: #93E0E3;">alloc_pages_noprof</span>(<span style="color: #7CB8BB;">gfp_t</span> <span style="color: #DFAF8F;">gfp</span>, <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">order</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">mempolicy</span> *<span style="color: #DFAF8F;">pol</span> = &amp;default_policy;

        <span style="color: #5F7F5F;">/*</span>
<span style="color: #7F9F7F;">         * No reference counting needed for current-&gt;mempolicy</span>
<span style="color: #7F9F7F;">         * nor system default_policy</span>
<span style="color: #5F7F5F;">         */</span>
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>in_interrupt() &amp;&amp; <span style="color: #F0DFAF; font-weight: bold;">!</span>(gfp &amp; __GFP_THISNODE))
                pol = get_task_policy(current);

        <span style="color: #F0DFAF; font-weight: bold;">return</span> alloc_pages_mpol_noprof(gfp, order, pol, NO_INTERLEAVE_INDEX,
                                       numa_node_id());
}
</pre>
</div>
<p>
在不处于中断上下文并且传入的GFP标志位没有__GFP_THISNODE时，内存的NUMA分配策略才会生效。那么如何判定是不是在中断上下文呢，__GFP_THISNODE究竟是什么意思呢，还有其它的NUMA策略标志吗？
</p>

<p>
判断是否在中断上下文中使用in_interrupt：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">in_interrupt</span>()          (irq_count())
</pre>
</div>
<p>
在没有定义CONFIG_PREEMPT_RT的情况下，irq_count被如下定义：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;"># define</span> <span style="color: #93E0E3;">irq_count</span>()            (preempt_count() &amp; (NMI_MASK | HARDIRQ_MASK | SOFTIRQ_MASK))
</pre>
</div>

<p>
preempt_count在通用头文件include/asm-generic/preempt.h与架构头文件arch/x86/include/asm/preempt.h中均有定义，但是一般是架构头文件优先使用，这种优先特性体现在Makefile中对头文件使用-I选项包含头文件的先后上，preempt_count在上述两个头文件中均有实现，但是-I选项只要找到第一个有实现的头文件即停止搜索：
</p>
<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #DFAF8F;">LINUXINCLUDE</span>    := \
                -I$(<span style="color: #DFAF8F;">srctree</span>)/arch/$(<span style="color: #DFAF8F;">SRCARCH</span>)/include \
                -I$(<span style="color: #DFAF8F;">objtree</span>)/arch/$(<span style="color: #DFAF8F;">SRCARCH</span>)/include/generated \
                $(<span style="color: #DFAF8F;">if</span> $(<span style="color: #DFAF8F;">building_out_of_srctree</span>),-I$(<span style="color: #DFAF8F;">srctree</span>)/include) \
                -I$(<span style="color: #DFAF8F;">objtree</span>)/include \
                $(<span style="color: #DFAF8F;">USERINCLUDE</span>)
export KBUILD_CPPFLAGS NOSTDINC_FLAGS LINUXINCLUDE OBJCOPYFLAGS KBUILD_LDFLAGS
</pre>
</div>

<p>
X86架构下，preempt_count被如下定义：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">__always_inline</span> <span style="color: #7CB8BB;">int</span> preempt_count(<span style="color: #7CB8BB;">void</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">return</span> raw_cpu_read_4(pcpu_hot.preempt_count) &amp; ~PREEMPT_NEED_RESCHED;
}
</pre>
</div>
<p>
也就是说每个CPU都有一个4字节的int量preempt_count表征现在的抢占计数，这32个bit按如下划分：
</p>
<pre class="example" id="org2c41646">
        PREEMPT_MASK:	0x000000ff
        SOFTIRQ_MASK:	0x0000ff00
        HARDIRQ_MASK:	0x000f0000
            NMI_MASK:	0x00f00000
PREEMPT_NEED_RESCHED:	0x80000000
</pre>
<p>
也就是说最低8个bit（最低1个字节）用来计数抢占，低第二个字节用来表示软中断的计数，依次类推，那么NMI_MASK、HARDIRQ_MASK以及SOFTIRQ_MASK等各种MASK宏用来取出对应字段计数的，就可以按如下代码定出：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">PREEMPT_BITS</span>    8
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">SOFTIRQ_BITS</span>    8
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">HARDIRQ_BITS</span>    4
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">NMI_BITS</span>        4

<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">PREEMPT_SHIFT</span>   0
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">SOFTIRQ_SHIFT</span>   (PREEMPT_SHIFT + PREEMPT_BITS)
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">HARDIRQ_SHIFT</span>   (SOFTIRQ_SHIFT + SOFTIRQ_BITS)
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">NMI_SHIFT</span>       (HARDIRQ_SHIFT + HARDIRQ_BITS)

<span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">__IRQ_MASK</span>(<span style="color: #DFAF8F;">x</span>)   ((1UL &lt;&lt; (x))-1)

<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">PREEMPT_MASK</span>    (__IRQ_MASK(PREEMPT_BITS) &lt;&lt; PREEMPT_SHIFT)
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">SOFTIRQ_MASK</span>    (__IRQ_MASK(SOFTIRQ_BITS) &lt;&lt; SOFTIRQ_SHIFT)
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">HARDIRQ_MASK</span>    (__IRQ_MASK(HARDIRQ_BITS) &lt;&lt; HARDIRQ_SHIFT)
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">NMI_MASK</span>        (__IRQ_MASK(NMI_BITS)     &lt;&lt; NMI_SHIFT)
</pre>
</div>

<p>
所以回到前面irq_count的定义以及回答如何判定是不是在中断上下文中：只要不可屏蔽中断、硬中断以及软中断三者有其一即可认为当前处于中断上下文中。而一般在进入中断上下文时会对preempt_count相应的字段进行自增：
</p>
<pre class="example" id="org04764f4">
__irq_enter-&gt;preempt_count_add-&gt;__preempt_count_add
</pre>

<p>
__GFP_THISNODE标志主要作用是表明从指定的节点上分配内存，禁止分配回退或使用其它策略，如果请求的节点没有足够的内存资源，那么分配将会失败，这种情况自然不需要考虑NUMA内存分配策略了。除了这个标志还有如下的一些移动和放置策略：
</p>

<ul class="org-ul">
<li>__GFP_MOVABLE <br>
表示页面是可移动的。这个标志通常用于那些可以在内存整理（compaction）过程中通过页面迁移移动的页面，或是可以被回收的页面。在内存管理中，标记为__GFP_MOVABLE的页面将被放置在特定的pageblocks中，这些pageblocks一般只包含可移动页面，以尽量减少外部碎片的问题。</li>

<li>__GFP_RECLAIMABLE <br>
主要用于slab分配。指定了SLAB_RECLAIM_ACCOUNT的slab分配使用该标志，这些页面可以通过shrinker机制回收。这使得slab分配的内存可以在系统需要时被回收，以便释放更多的内存资源。</li>

<li>__GFP_WRITE <br>
表示调用者打算修改页面内容，即页面将被“写脏”（dirty）。内核在分配这些页面时，会尽量将这些页面在本地节点之间进行分散分配，以避免所有脏页集中在同一个内存区域或节点，帮助实现公平的内存分配策略（fair zone allocation policy）。</li>

<li>__GFP_HARDWALL <br>
强制执行cpuset的内存分配策略。如果系统中存在cpuset配置（用于控制和隔离不同任务的内存使用），这个标志确保页面分配遵循cpuset的内存限制和隔离策略。</li>

<li>__GFP_ACCOUNT <br>
该标志表示分配的内存将被记账到kmemcg（Kernel Memory Control Group），即为分配的内存计入内核内存控制组。它用于限制和跟踪控制组（cgroup）中分配的内核内存资源。</li>
</ul>

<p>
当既不在中断上下文gfp参数也没有设置__GFP_THISNODE时，就会调用get_task_policy函数：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">mempolicy</span> *<span style="color: #93E0E3;">get_task_policy</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">task_struct</span> *<span style="color: #DFAF8F;">p</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">mempolicy</span> *<span style="color: #DFAF8F;">pol</span> = p-&gt;mempolicy;
        <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">node</span>;

        <span style="color: #F0DFAF; font-weight: bold;">if</span> (pol)
                <span style="color: #F0DFAF; font-weight: bold;">return</span> pol;

        node = numa_node_id();
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (node != NUMA_NO_NODE) {
                pol = &amp;preferred_node_policy[node];
                <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">preferred_node_policy is not initialised early in boot</span><span style="color: #5F7F5F;"> */</span>
                <span style="color: #F0DFAF; font-weight: bold;">if</span> (pol-&gt;mode)
                        <span style="color: #F0DFAF; font-weight: bold;">return</span> pol;
        }

        <span style="color: #F0DFAF; font-weight: bold;">return</span> &amp;default_policy;
}
</pre>
</div>
<p>
该函数首先获取当前进程的内存分配策略mempolicy，mempolicy可以被关联到一个进程，也可以关联到一个VMA。对于VMA关联的，优先考虑，然后才是进程关联。根据上面get_task_policy函数的定义，内核有一个默认的mempolicy叫default_policy，其定义如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">mempolicy</span> <span style="color: #DFAF8F;">default_policy</span> = {
        .refcnt = ATOMIC_INIT(1), <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">never free it</span><span style="color: #5F7F5F;"> */</span>
        .mode = MPOL_LOCAL,
};
</pre>
</div>
<p>
MPOL_LOCAL是NUMA内存策略的默认方式，所谓NUMA内存策略可以允许用户指定在特定节点上进行内存分配的优先级和方式，适用于不同的进程或VMA（虚拟内存区域）。这些策略可以用于优化多节点系统上的内存访问效率。具体有以下方式：
</p>

<ul class="org-ul">
<li>interleave（交错方式）<br>
内存分配在指定的一组节点上交错进行，如果分配失败则会采用常规的回退策略。对于VMA分配，这种交错策略基于对象的偏移量（或匿名内存的映射偏移量）；对于进程策略，则基于一个进程计数器进行分配。</li>

<li>weighted interleave（加权交错）<br>
类似于interleave，但允许根据每个节点的权重分配内存。例如，nodeset(0,1)与权重(2,1)表示每在节点0上分配两页内存后，再在节点1上分配一页内存。</li>

<li>bind（绑定）<br>
只在指定的节点集合上分配内存，不采用回退策略。</li>

<li>preferred（优先）<br>
首先尝试在指定节点上分配内存，若失败则使用常规回退策略。如果节点设置为NUMA_NO_NODE，则优先在本地CPU上分配内存。通常这类似于默认策略，但在VMA上设置时可以覆盖非默认的进程策略。</li>

<li>preferred many（多节点优先）<br>
与preferred类似，但允许指定多个优先节点，然后再进行回退。</li>

<li>default（默认）<br>
优先在本地节点上分配内存，或者在VMA上使用进程策略。这是Linux内核在NUMA系统上一直采用的默认行为。</li>
</ul>

<p>
另外，进程策略适用于该进程上下文中的大多数非中断内存分配，中断则不受策略影响，VMA策略只适用于该VMA中的内存分配。策略应用于系统的高区内存，而不应用于低区和GFP_DMA内存分配。对于共享内存（shmem/tmpfs），策略在所有用户之间共享，即使没有用户映射时也会记住该策略。
</p>

<p>
中断不会使用当前进程的内存策略，它们总是优先在本地CPU上分配内存。这种设计是为了在中断处理过程中尽可能减少延迟。
</p>

<p>
对于交错策略来说，在进程上下文中，不需要锁定机制，因为进程只会访问自身的状态，因此没有并发冲突。对于VMA的操作，mmap_lock的读锁（down_read）在一定程度上保护了这些操作，以确保内存映射的一致性。
</p>

<p>
内存策略mempolicy结构体的释放：内存策略对象通过引用计数来管理生命周期。mpol_put()函数会减少内存策略的引用计数，当引用计数降为零时，该内存策略对象会被释放。这种机制保证了对象只会在不再使用时被释放，避免了内存泄漏。
</p>

<p>
内存策略mempolicy结构体的复制：mpol_dup()函数用于分配一个新的内存策略，并将指定的内存策略复制到新的内存空间。新创建的内存策略对象的引用计数被初始化为1，表示当前调用者持有该引用。这允许多个内存策略对象彼此独立，同时保证每个对象的生命周期被正确管理。
</p>

<p>
回到get_task_policy函数，如果进程有内存分配策略mempolicy，则返回这个策略。如果进程没有内存策略，那么就会从系统的全局节点策略数组preferrred_node_policy中去获取内存策略，当然在系统启动早期preferred_node_policy里可能是没有数据的，所以需要判断pol-&gt;mode非零，因为preferred_node_policy的定义是static的（被初始化为0）：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">mempolicy</span> <span style="color: #DFAF8F;">preferred_node_policy</span>[MAX_NUMNODES];
</pre>
</div>

<p>
MAX_NUMNODES定义了系统支持的最大NUMA节点数量：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#ifdef</span> CONFIG_NODES_SHIFT
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">NODES_SHIFT</span>     CONFIG_NODES_SHIFT
<span style="color: #94BFF3;">#else</span>
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">NODES_SHIFT</span>     0
<span style="color: #94BFF3;">#endif</span>
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">MAX_NUMNODES</span>    (1 &lt;&lt; NODES_SHIFT)
</pre>
</div>

<p>
而NODES_SHIFT的值依据不同的架构有不同的配置，这主要体现在比如arch/x86/Kconfig中有如下代码：
</p>
<div class="org-src-container">
<pre class="src src-conf">config NODES_SHIFT
        int <span style="color: #CC9393;">"Maximum NUMA Nodes (as a power of 2)"</span> if !MAXSMP
        range 1 10
        default <span style="color: #CC9393;">"10"</span> if MAXSMP
        default <span style="color: #CC9393;">"6"</span> if X86_64
        default <span style="color: #CC9393;">"3"</span>
        depends on NUMA
        help
          Specify the maximum number of NUMA Nodes available on the target
          system.  Increases memory reserved to accommodate various tables.
</pre>
</div>

<p>
这样在编译构建时会自动生成，比如CONFIG_NODES_SHIFT在自动生成的头文件include/generated/autoconf.h中被定义为10。
</p>

<p>
get_task_policy中还使用了numa_node_id函数，在定义了CONFIG_USE_PERCPU_NUMA_NODE_ID时该函数定义如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#ifdef</span> CONFIG_USE_PERCPU_NUMA_NODE_ID
<span style="color: #93E0E3;">DECLARE_PER_CPU</span>(<span style="color: #7CB8BB;">int</span>, numa_node);

<span style="color: #94BFF3;">#if</span><span style="color: #94BFF3; font-weight: bold;">n</span><span style="color: #94BFF3;">def</span> numa_node_id
<span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">Returns the number of the current Node.</span><span style="color: #5F7F5F;"> */</span>
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">numa_node_id</span>(<span style="color: #7CB8BB;">void</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">return</span> raw_cpu_read(numa_node);
}
<span style="color: #94BFF3;">#endif</span>
</pre>
</div>
<p>
该值在cpu启动初始化的流程被初始化：
</p>
<div class="org-src-container">
<pre class="src src-c">start_secondary-&gt;cpu_init-&gt;set_numa_node
<span style="color: #94BFF3;">#if</span><span style="color: #94BFF3; font-weight: bold;">n</span><span style="color: #94BFF3;">def</span> set_numa_node
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">void</span> set_numa_node(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">node</span>)
{
        this_cpu_write(numa_node, node);
}
<span style="color: #94BFF3;">#endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgedc822c" class="outline-2">
<h2 id="orgedc822c"><span class="section-number-2">2.</span> alloc_pages_mpol_noprof</h2>
<div class="outline-text-2" id="text-2">
<p>
<b>原型：</b>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">page</span> *<span style="color: #93E0E3;">alloc_pages_mpol_noprof</span>(<span style="color: #7CB8BB;">gfp_t</span> <span style="color: #DFAF8F;">gfp</span>, <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">order</span>,
                <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">mempolicy</span> *<span style="color: #DFAF8F;">pol</span>, <span style="color: #7CB8BB;">pgoff_t</span> <span style="color: #DFAF8F;">ilx</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">nid</span>)
</pre>
</div>

<p>
<b>作用：</b><br>
分配2^order个页面，第一个参数是内存分配标志gfp，最后一个参数nid是前面使用numa_node_id获得的该运行CPU所在的node。针对第四个参数ilx，在交错策略下时，ilx表明是否使用task_struct里的il_prev作为依据来选择内存分配的节点，为NO_INTERLEAVE_INDEX时表明使用task_struct:ilx_prev，而当通过get_vma_policy来获得一个有效的ilx值时就使用这个值来确定如何选择哪个节点来分配内存。第三个参数pol就是前面通过get_task_policy获得的内存策略，当然还有其它的调用路径通过get_vma_policy来获得内存策略，这在本文<a href="#org8dc70fb">附节: get_vma_policy生成ilx</a>中有介绍。
</p>

<p>
<b>详细分析：</b><br>
</p>
</div>
</div>
<div id="outline-container-orgc5ea259" class="outline-2">
<h2 id="orgc5ea259"><span class="section-number-2">3.</span> 附节</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org8dc70fb" class="outline-3">
<h3 id="org8dc70fb"><span class="section-number-3">3.1.</span> get_vma_policy生成ilx</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cauchy(pqy7172@gmail.com)</p>
<p class="date">Created: 2024-11-06 Wed 23:26</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
