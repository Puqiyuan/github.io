<!DOCTYPE html>
<html lang="cn">
<head>
<!-- 2025-07-05 Sat 22:40 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>进程调度</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Cauchy(pqy7172@gmail.com)">
<link rel="stylesheet" href="../../org-manual.css" type="text/css">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">进程调度</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9d3c4ab">1. __schedule</a></li>
<li><a href="#org47cd20c">2. pick_next_task</a></li>
<li><a href="#org054ea4d">3. context_switch</a></li>
</ul>
</div>
</div>
<p>
__schedule是进程调度的核心函数，它先调用pick_next_task函数算出需要运行哪个进程，然后调用context_switch函数完成切换。
</p>

<p>
驱动调度器并进入__schedule这个核心调度函数主要有以下一些方式：
</p>

<ul class="org-ul">
<li>显式阻塞，例如互斥锁（mutex）、信号量（semaphore）、等待队列（waitqueue）等，任务主动睡眠进入等待状态，比如进程调用了mutex_lock、down或wait_event等函数可能会导致自己进入等待状态，需要调度器选择下一个可运行的任务。</li>
<li>定时器的中断处理程序sched_tick可以设置TIF_NEED_RESCHED标志来驱动任务间的抢占调度，该标志会在中断返回和用户态返回路径上被检查。</li>
<li>唤醒任务时并不会直接导致schedule被调用，它只是将任务添加到运行队列（run-queue）中。但如果新加入的任务优先级更高，导致抢占，那么唤醒代码会设置TIF_NEED_RESCHED，然后schedule将在最近的时机被调用，这种时机又分内核是否开启抢占而有所不同：
<ul class="org-ul">
<li>如果内核是可抢占的（CONFIG_PREEMPTION=y）：在系统调用或异常（syscall/exception）上下文中，会在最外层preempt_enable时触发抢占调度，这可能会在wake_up的spin_unlock之后立即发生。在中断（IRQ）上下文中，会在从中断处理程序返回到可抢占上下文时进行调度。</li>
<li>如果内核是不可抢占的（CONFIG_PREEMPTION未启用），那么调度将在以下情况下发生，1显式主动调用cond_resched，2显式主动调用schedule，3从系统调用或异常返回到用户态，4从中断处理程序返回到用户态。</li>
</ul></li>
</ul>

<p>
调用__schedule时必须禁用抢占（preemption disabled），但其父函数可能会处理抢占的问题，比如__schedule__loop就会禁用抢占。
</p>

<p>
__schedule函数的参数sched_mode指明了以何种模式进入的调度器，它的取值可以有：
</p>
<pre class="example" id="org53163d0">
/*
 * Constants for the sched_mode argument of __schedule().
 *
 * The mode argument allows RT enabled kernels to differentiate a
 * preemption from blocking on an 'sleeping' spin/rwlock.
 */
#define SM_IDLE			(-1)
#define SM_NONE			0
#define SM_PREEMPT		1
#define SM_RTLOCK_WAIT		2
</pre>
<p>
内核调度器在调度空闲任务时会使用SM_IDLE模式，表示当前没有可运行的普通任务，CPU可能会进入低功耗模式。
</p>

<p>
SM_NONE是普通调度模式，不涉及特殊的抢占或锁等待情况。这是最常见的调度模式，表示当前任务只是正常调度，而不是因为抢占或等待锁。
</p>

<p>
SM_PREEMPT表示任务被抢占（preempted）。当更高优先级的任务就绪时，内核可以抢占当前任务。比如普通任务被抢占式内核（Preemptible Kernel）或实时内核抢占时使用此模式。软实时（SCHED_RR）或硬实时（SCHED_FIFO）任务可能会触发此模式。
</p>

<p>
SM_RTLOCK_WAIT表示任务正在等待RT（实时）锁。实时内核（RT内核）提供了一种机制，使spinlock和rwlock可以在高优先级任务上睡眠（普通内核的自旋锁是不会睡眠的）。当任务因为获取实时锁（RT lock）而阻塞时，会使用这个模式。
</p>

<p>
总的来说这些调度模式主要用于区分不同的调度情况，特别是在抢占式调度和RT内核下，普通任务切换使用SM_NONE，表示任务因为时间片耗尽或显式调度而切换。抢占（Preemption）使用SM_PREEMPT，表示任务因为更高优先级任务到来而被抢占。空闲调度使用SM_IDLE，表示CPU进入空闲模式。实时锁等待使用SM_RTLOCK_WAIT，表示任务在RT互斥锁（如rtmutex）上睡眠等待。
</p>

<p>
比如preempt_schedule_common函数调用_schedule时就指明了参数SM_PREEMPT，表明本次进入调度器是因为抢占。
</p>

<div id="outline-container-org9d3c4ab" class="outline-2">
<h2 id="org9d3c4ab"><span class="section-number-2">1.</span> __schedule</h2>
<div class="outline-text-2" id="text-1">
<p>
以下是__schedule的实现：
</p>
<pre class="example" id="org76529e9">
static void __sched notrace __schedule(int sched_mode)
{
	struct task_struct *prev, *next;
	/*
	 * On PREEMPT_RT kernel, SM_RTLOCK_WAIT is noted
	 * as a preemption by schedule_debug() and RCU.
	 */
	bool preempt = sched_mode &gt; SM_NONE;
	unsigned long *switch_count;
	unsigned long prev_state;
	struct rq_flags rf;
	struct rq *rq;
	int cpu;

	cpu = smp_processor_id();
	rq = cpu_rq(cpu);
	prev = rq-&gt;curr;

	schedule_debug(prev, preempt);

	if (sched_feat(HRTICK) || sched_feat(HRTICK_DL))
		hrtick_clear(rq);

	local_irq_disable();
	rcu_note_context_switch(preempt);

	/*
	 * Make sure that signal_pending_state()-&gt;signal_pending() below
	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)
	 * done by the caller to avoid the race with signal_wake_up():
	 *
	 * __set_current_state(@state)		signal_wake_up()
	 * schedule()				  set_tsk_thread_flag(p, TIF_SIGPENDING)
	 *					  wake_up_state(p, state)
	 *   LOCK rq-&gt;lock			    LOCK p-&gt;pi_state
	 *   smp_mb__after_spinlock()		    smp_mb__after_spinlock()
	 *     if (signal_pending_state())	    if (p-&gt;state &amp; @state)
	 *
	 * Also, the membarrier system call requires a full memory barrier
	 * after coming from user-space, before storing to rq-&gt;curr; this
	 * barrier matches a full barrier in the proximity of the membarrier
	 * system call exit.
	 */
	rq_lock(rq, &amp;rf);
	smp_mb__after_spinlock();

	/* Promote REQ to ACT */
	rq-&gt;clock_update_flags &lt;&lt;= 1;
	update_rq_clock(rq);
	rq-&gt;clock_update_flags = RQCF_UPDATED;

	switch_count = &amp;prev-&gt;nivcsw;

	/* Task state changes only considers SM_PREEMPT as preemption */
	preempt = sched_mode == SM_PREEMPT;

	/*
	 * We must load prev-&gt;state once (task_struct::state is volatile), such
	 * that we form a control dependency vs deactivate_task() below.
	 */
	prev_state = READ_ONCE(prev-&gt;__state);
	if (sched_mode == SM_IDLE) {
		/* SCX must consult the BPF scheduler to tell if rq is empty */
		if (!rq-&gt;nr_running &amp;&amp; !scx_enabled()) {
			next = prev;
			goto picked;
		}
	} else if (!preempt &amp;&amp; prev_state) {
		try_to_block_task(rq, prev, prev_state);
		switch_count = &amp;prev-&gt;nvcsw;
	}

	next = pick_next_task(rq, prev, &amp;rf);
	rq_set_donor(rq, next);
picked:
	clear_tsk_need_resched(prev);
	clear_preempt_need_resched();
#ifdef CONFIG_SCHED_DEBUG
	rq-&gt;last_seen_need_resched_ns = 0;
#endif

	if (likely(prev != next)) {
		rq-&gt;nr_switches++;
		/*
		 * RCU users of rcu_dereference(rq-&gt;curr) may not see
		 * changes to task_struct made by pick_next_task().
		 */
		RCU_INIT_POINTER(rq-&gt;curr, next);
		/*
		 * The membarrier system call requires each architecture
		 * to have a full memory barrier after updating
		 * rq-&gt;curr, before returning to user-space.
		 *
		 * Here are the schemes providing that barrier on the
		 * various architectures:
		 * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC,
		 *   RISC-V.  switch_mm() relies on membarrier_arch_switch_mm()
		 *   on PowerPC and on RISC-V.
		 * - finish_lock_switch() for weakly-ordered
		 *   architectures where spin_unlock is a full barrier,
		 * - switch_to() for arm64 (weakly-ordered, spin_unlock
		 *   is a RELEASE barrier),
		 *
		 * The barrier matches a full barrier in the proximity of
		 * the membarrier system call entry.
		 *
		 * On RISC-V, this barrier pairing is also needed for the
		 * SYNC_CORE command when switching between processes, cf.
		 * the inline comments in membarrier_arch_switch_mm().
		 */
		++*switch_count;

		migrate_disable_switch(rq, prev);
		psi_account_irqtime(rq, prev, next);
		psi_sched_switch(prev, next, !task_on_rq_queued(prev) ||
					     prev-&gt;se.sched_delayed);

		trace_sched_switch(preempt, prev, next, prev_state);

		/* Also unlocks the rq: */
		rq = context_switch(rq, prev, next, &amp;rf);
	} else {
		rq_unpin_lock(rq, &amp;rf);
		__balance_callbacks(rq);
		raw_spin_rq_unlock_irq(rq);
	}
}
</pre>
<p>
该函数本身比较简单，每个cpu都有一关联的runqueues，首先是通过smp_processor_id获取当前运行cpu的编号：
</p>
<pre class="example" id="org1846c15">
# define smp_processor_id() __smp_processor_id()
</pre>
<p>
不同架构有不同的__smp_processor_id实现，对于x86架构来说，每个cpu都维护有一个pcpu_hot结构体，里面有cpu_number成员记录了当前运行的cpu号，cpu_number在初始化的时候通过start_kernel-&gt;setup_per_cpu_areas去设置：
</p>
<pre class="example" id="org1e5e028">
for_each_possible_cpu(cpu) {
        ...
        per_cpu(pcpu_hot.cpu_number, cpu) = cpu;
        ...
}
</pre>
<p>
而对于其它架构比如arm64，则是在当前运行线程中的一个成员进行记录：
</p>
<pre class="example" id="org83dd94a">
#define raw_smp_processor_id() (current_thread_info()-&gt;cpu)
</pre>
<p>
有了cpu号，就可以通过cpu_rq获得对应当前运行cpu的rq运行队列了：
</p>
<pre class="example" id="orgb3bb473">
DECLARE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);
#define cpu_rq(cpu)		(&amp;per_cpu(runqueues, (cpu)))
</pre>
<p>
通过DECLARE就为每个cpu都开辟了rq的空间，这样per_cpu就可以依据cpu号取到对应的rq运行队列。
</p>

<div class="centered-line">sched_debug</div>
<p>
继续分析schedule_debug：
</p>
<pre class="example" id="org0eade67">
/*
 * Various schedule()-time debugging checks and statistics:
 */
static inline void schedule_debug(struct task_struct *prev, bool preempt)
{
#ifdef CONFIG_SCHED_STACK_END_CHECK
	if (task_stack_end_corrupted(prev))
		panic("corrupted stack end detected inside scheduler\n");

	if (task_scs_end_corrupted(prev))
		panic("corrupted shadow stack detected inside scheduler\n");
#endif

#ifdef CONFIG_DEBUG_ATOMIC_SLEEP
	if (!preempt &amp;&amp; READ_ONCE(prev-&gt;__state) &amp;&amp; prev-&gt;non_block_count) {
		printk(KERN_ERR "BUG: scheduling in a non-blocking section: %s/%d/%i\n",
			prev-&gt;comm, prev-&gt;pid, prev-&gt;non_block_count);
		dump_stack();
		add_taint(TAINT_WARN, LOCKDEP_STILL_OK);
	}
#endif

	if (unlikely(in_atomic_preempt_off())) {
		__schedule_bug(prev);
		preempt_count_set(PREEMPT_DISABLED);
	}
	rcu_sleep_check();
	SCHED_WARN_ON(ct_state() == CT_STATE_USER);

	profile_hit(SCHED_PROFILING, __builtin_return_address(0));

	schedstat_inc(this_rq()-&gt;sched_count);
}
</pre>
<p>
该函数主要是做一些在调度时的debug检查，第一个检查就是看看即将要被切换出去的prev其内核栈顶是否被污染了（笔者环境开了CONFIG_SCHED_STACK_END_CHECK）：
</p>
<pre class="example" id="orge35b9eb">
#ifdef CONFIG_SCHED_STACK_END_CHECK
	if (task_stack_end_corrupted(prev))
		panic("corrupted stack end detected inside scheduler\n");

	if (task_scs_end_corrupted(prev))
		panic("corrupted shadow stack detected inside scheduler\n");
#endif
</pre>
<pre class="example" id="orgb330686">
#define task_stack_end_corrupted(task) \
		(*(end_of_stack(task)) != STACK_END_MAGIC)
</pre>
<p>
对于开启了CONFIG_THREAD_INFO_IN_TASK配置的end_of_stack实现如下：
</p>
<pre class="example" id="orgf970dd7">
static __always_inline unsigned long *end_of_stack(const struct task_struct *task)
{
#ifdef CONFIG_STACK_GROWSUP
	return (unsigned long *)((unsigned long)task-&gt;stack + THREAD_SIZE) - 1;
#else
	return task-&gt;stack;
#endif
}
</pre>
<p>
可以看到这里返回了task的内核栈底，x86架构上内核栈自顶（大地址处）向下（小地址处）生长，而task-&gt;stack通过如下代码分配获取出来就是页面的小地址处，也就是end_of_stack中返回的内核栈结束的地方：
</p>
<pre class="example" id="org13a5335">
static int alloc_thread_stack_node(struct task_struct *tsk, int node)
{
	unsigned long *stack;
	stack = kmem_cache_alloc_node(thread_stack_cache, THREADINFO_GFP, node);
	stack = kasan_reset_tag(stack);
	tsk-&gt;stack = stack;
	return stack ? 0 : -ENOMEM;
}
</pre>
<p>
alloc_thread_stack_node被dup_task_struct函数在创建进程的时候调用。对于配置了CONFIG_THREAD_INFO_IN_TASK，进程的thread_info结构体就在task_struct里，而不是传统的放到内核栈task-&gt;stack处，这样可以简化内核栈的管理，不用在栈上去处理thread_info的逻辑（比如加偏移取相应的thread_info里的成员）。
</p>

<p>
task_stack_end_corrupted主要就是检查栈底处的值是不是STACK_END_MAGIC，该值同样通过dup_task_struct-&gt;set_task_stack_end_magic去设置：
</p>
<pre class="example" id="org236f56b">
void set_task_stack_end_magic(struct task_struct *tsk)
{
	unsigned long *stackend;

	stackend = end_of_stack(tsk);
	*stackend = STACK_END_MAGIC;	/* for overflow detection */
}
</pre>
<p>
对于顺序下来的over write，若写到了栈底就会在调度出去时被检测发现而panic，调度出是一个恰当的时机，这样避免了下次调度到该进程时遇到一个被破坏了的栈。
</p>

<p>
task_scs_end_corrupted是类似的原理，不再详细介绍。
</p>
<div class="centered-line">sched_debug</div>
<p>
再往下看schedule_debug的实现：
</p>
<pre class="example" id="org80d4b4d">
if (unlikely(in_atomic_preempt_off())) {
	__schedule_bug(prev);
	preempt_count_set(PREEMPT_DISABLED);
}

</pre>
<p>
这个条件大概率是不会满足的，这里主要想分析这个条件是在判断什么：
</p>
<pre class="example" id="org064686f">
/*
 * Check whether we were atomic before we did preempt_disable():
 * (used by the scheduler)
 */
#define in_atomic_preempt_off() (preempt_count() != PREEMPT_DISABLE_OFFSET)
</pre>
<pre class="example" id="org066281f">
static __always_inline int preempt_count(void)
{
	return raw_cpu_read_4(pcpu_hot.preempt_count) &amp; ~PREEMPT_NEED_RESCHED;
}
</pre>
<pre class="example" id="org111b16c">
/*
 * The preempt_count offset after preempt_disable();
 */
#if defined(CONFIG_PREEMPT_COUNT)
# define PREEMPT_DISABLE_OFFSET	PREEMPT_OFFSET
#else
# define PREEMPT_DISABLE_OFFSET	0
#endif
</pre>
<pre class="example" id="orge9d7b54">
#define PREEMPT_OFFSET	(1UL &lt;&lt; PREEMPT_SHIFT)
</pre>
<pre class="example" id="orgc12ed70">
#define PREEMPT_SHIFT	0
</pre>
<p>
对于开启了CONFIG_PREEMPT_COUNT来说，在x86上就是检查preempt_count必须为1，这样条件就是满足，不会进入__schedule_bug，这其实是说运行到此处调度器的代码时，父函数已经调用过一次preempt_disable，而在调用它之前，preempt_count必须为0，也就是不处于原子上下文或已经调用过了preempt_disable，换言之，原子上下文（比如软硬中断中）不允许调度发生。
</p>

<p>
继续往下看一个warn判断：
</p>
<pre class="example" id="orgc15f72c">
SCHED_WARN_ON(ct_state() == CT_STATE_USER);
</pre>
<p>
ct_state函数在启用CONFIG_CONTEXT_TRACKING_USER配置时会返回有意义的值，它主要用来追踪cpu的当前上下文，可能的状态有：
</p>
<pre class="example" id="orgad486a5">
enum ctx_state {
	CT_STATE_DISABLED	= -1,	/* returned by ct_state() if unknown */
	CT_STATE_KERNEL		= 0,
	CT_STATE_IDLE		= 1,
	CT_STATE_USER		= 2,
	CT_STATE_GUEST		= 3,
	CT_STATE_MAX		= 4,
};
</pre>
<p>
这些状态主动在相应上下文切换的代码流程里被切换，RCU可以利用这些状态确认当前CPU是否处于用户态，以便判断是否可以将该CPU视为“非活跃”，从而进行RCU回收，另外在某些架构（如NO_HZ_FULL模式）中，内核会在用户态禁用定时器中断，以减少上下文切换的开销。但是，这样会导致cputime统计变得不准确，因为CPU进入用户态后不会有定时器中断来更新时间统计。CONTEXT_TRACKING_USER通过显式追踪进入/退出用户态的时间，使CPU时间统计能够在NO_HZ_FULL模式下仍然保持准确。
</p>

<p>
至于本warn判断本身，调度器（schedule）运行时一定是在内核态，如果ct_state() == CT_STATE_USER，说明context tracking机制出了问题，所以这里加了SCHED_WARN_ON作为一个调试检查。
</p>

<p>
继续往下看是增加一个profile计数：
</p>
<pre class="example" id="orge7e61de">
profile_hit(SCHED_PROFILING, __builtin_return_address(0));
</pre>
<pre class="example" id="orgac4526a">
/*
 * Single profiler hit:
 */
static inline void profile_hit(int type, void *ip)
{
	/*
	 * Speedup for the common (no profiling enabled) case:
	 */
	if (unlikely(prof_on == type))
		profile_hits(type, ip, 1);
}
</pre>
<p>
可以进行profiling的包括三个模块：
</p>
<pre class="example" id="org3025142">
#define CPU_PROFILING	1
#define SCHED_PROFILING	2
#define KVM_PROFILING	4
</pre>
<p>
prof_on在启动时依据profile=的参数设置调用profile_setup来填为上面三个类型中的一个。__builtin_return_address是编译器内置的函数，可以返回当前函数的返回地址。
profile_hits实现如下：
</p>
<pre class="example" id="orgba8231f">
static void do_profile_hits(int type, void *__pc, unsigned int nr_hits)
{
	unsigned long pc;
	pc = ((unsigned long)__pc - (unsigned long)_stext) &gt;&gt; prof_shift;
	if (pc &lt; prof_len)
		atomic_add(nr_hits, &amp;prof_buffer[pc]);
}
</pre>
<p>
prof_buffer是在初始化函数profile_init里开的空间，可以看到do_profile_hits就是记录了内核text段某个pc执行的次数，是一种性能统计的功能，它实现在CONFIG_PROFILING配置下，并可以通过/proc访问文件的方式。
</p>

<p>
最后是schedstat_inc自增rq的sched_count，当然这需要开启CONFIG_SCHEDSTATS配置，这样/proc/schedstat就可以反应一些调度统计信息了：
</p>
<pre class="example" id="org1305a58">
schedstat_inc(this_rq()-&gt;sched_count);
</pre>
<pre class="example" id="orgd4e9ceb">
#define   schedstat_inc(var)		do { if (schedstat_enabled()) { var++; } } while (0)
</pre>
<p>
注意这里是宏展开，不是函数调用，所以最后对sched_count的自增一定会生效，展开就是文本替换，在预编译阶段完成：
</p>
<pre class="example" id="orgea51720">
#define   schedstat_inc(var)		do { if (schedstat_enabled()) { this_rq()-&gt;sched_count++; } } while (0)
</pre>
<div class="centered-line">sched_debug</div>

<p>
回到__schedule，继续往下看：
</p>
<pre class="example" id="orgcdfa721">
if (sched_feat(HRTICK) || sched_feat(HRTICK_DL))
    hrtick_clear(rq);
</pre>

<p>
HRTICK是高精度调度定时器功能，默认情况下这个功能是关闭的，但是sched_feat宏本身是有定义的，尤其是笔者的环境开了CONFIG_SCHED_DEBUG以及CONFIG_JUMP_LABEL两个配置，sched_feat使用静态分支判断的方法：
</p>
<pre class="example" id="org7f3d306">
#define sched_feat(x) (static_branch_##x(&amp;sched_feat_keys[__SCHED_FEAT_##x]))
</pre>
<p>
通过sched_feat这里主要是想介绍上面提到的两个配置的功能，至于HRTICK这个调度器feature本身，默认是不开启的：
</p>
<pre class="example" id="org8dd0a8e">
SCHED_FEAT(HRTICK, false)
</pre>

<p>
CONFIG_SCHED_DEBUG开启了调度器的调试信息，这样就会在/sys/kernel/debug/sched/下展示很多关于调度器的信息，开启这个代价很小，所以笔者环境默认开启了，比如/sys/kernel/debug/sched/features可以查看当前scheduler开启哪些feature：
</p>
<pre class="example" id="orgb70a746">
PLACE_LAG PLACE_DEADLINE_INITIAL PLACE_REL_DEADLINE RUN_TO_PARITY PREEMPT_SHORT NO_NEXT_BUDDY PICK_BUDDY CACHE_HOT_BUDDY DELAY_DEQUEUE DELAY_ZERO WAKEUP_PREEMPTION NO_HRTICK NO_HRTICK_DL NO_DOUBLE_TICK NONTASK_CAPACITY TTWU_QUEUE SIS_UTIL NO_WARN_DOUBLE_CLOCK RT_PUSH_IPI NO_RT_RUNTIME_SHARE NO_LB_MIN ATTACH_AGE_LOAD WA_IDLE WA_WEIGHT WA_BIAS UTIL_EST NO_LATENCY_WARN
</pre>
<p>
前面有NO的就是没有开启的，比如NO_HRTICK，当然在运行时可以动态的修改这个文件以开启某个feature。另外要介绍的一个配置就是CONFIG_JUMP_LABEL，它优化了almost-always-true和almost-always-false这样的分支预测，传统上，这样的分支预测还是有cmp指令进行比较并决定是否跳转的，这样在硬件上就有分支预测，但是一旦分支预测错误面临的性能损失比较大，jump label优化的做法是一开始都将这样的分支预测编译为nop指令，然后在运行时，通过static_key_enable/disable这样的接口一路向下到text_poke去动态的调整nop为jmp到对应函数（或调整为nop，表示条件不满足）。
</p>

<p>
至于上面的条件自然是不满足就不深入分析了。
</p>

<p>
接着后面是关闭本地cpu的中断响应，local_irq_disable在x86架构上使用的是cli指令，它只会禁止对可屏蔽的外部中断的响应，而异常和NMI（不可屏蔽中断）还是会响应的。
</p>

<p>
然后通过rq_lock获取操作runqueues的自旋锁，也就是操作rq需要有锁保护，防止并发操作带来的数据一致性问题。
</p>

<p>
继续看对smp_mb__after_spinlock的调用，它是针对arm64这样的弱一致内存模型的同步操作，因为在调用__schedule前通常通过__set_current_state设置了进程状态比如为TASK_INTERRUPTIBLE，而另外的独立路径可能设置进程有信号需要处理，比如通过set_tsk_thread_flag(p, TIF_SIGPENDING)，在之前一样的调用__schedule的路径下，通常也会调用signal_pending_state去检查进程是否有需要待处理的pending信号：
</p>
<pre class="example" id="org2abe54a">
static inline int signal_pending_state(unsigned int state, struct task_struct *p)
{
	if (!(state &amp; (TASK_INTERRUPTIBLE | TASK_WAKEKILL)))
		return 0;
	if (!signal_pending(p))
		return 0;

	return (state &amp; TASK_INTERRUPTIBLE) || __fatal_signal_pending(p);
}
</pre>
<pre class="example" id="org78084a7">
static inline int task_sigpending(struct task_struct *p)
{
	return unlikely(test_tsk_thread_flag(p,TIF_SIGPENDING));
}

static inline int signal_pending(struct task_struct *p)
{
	/*
	 * TIF_NOTIFY_SIGNAL isn't really a signal, but it requires the same
	 * behavior in terms of ensuring that we break out of wait loops
	 * so that notify signal callbacks can be processed.
	 */
	if (unlikely(test_tsk_thread_flag(p, TIF_NOTIFY_SIGNAL)))
		return 1;
	return task_sigpending(p);
}
</pre>
<p>
可以看到在能够检查另外独立路径设置的TIF_SIGPENDING前（通过signal_pending-&gt;task_sigpending），signal_pending_state需要先检查进程状态是否为TASK_INTERRUPTIBLE，如果进程不处于可中断的状态，根本不会进一步检查是否有pending的信号，这样独立路径设置的需要处理的TIF_SIGPENDING标志，就因为TASK_INTERRUPTIBLE没有及时写入而错过了处理。
</p>

<p>
先检查进程为TASK_INTERRUPTIBLE是因为只有可中断状态，才有意义可以接受待处理的信号，而TASK_UNINTERRUPTIBLE是不响应信号的。
</p>

<p>
独立路径写入TIF_SIGPENDING只是可能引起这个问题表现的条件/场景，不是根本原因，根本原因在于TASK_INTERRUPTIBLE的写入与TIF_SIGPENDING读取之间的并发问题，导致signal_pending_state可能在错误的时间点返回错误的结果。
</p>

<div class="centered-line">update_rq_clock</div>

<p>
调用update_rq_clock前对clock_update_flags左移一位，clock_update_flags有三种取值可能：
</p>
<pre class="example" id="orgc36a9d5">
/*
 * rq::clock_update_flags bits
 *
 * %RQCF_REQ_SKIP - will request skipping of clock update on the next
 *  call to __schedule(). This is an optimisation to avoid
 *  neighbouring rq clock updates.
 *
 * %RQCF_ACT_SKIP - is set from inside of __schedule() when skipping is
 *  in effect and calls to update_rq_clock() are being ignored.
 *
 * %RQCF_UPDATED - is a debug flag that indicates whether a call has been
 *  made to update_rq_clock() since the last time rq::lock was pinned.
 *
 * If inside of __schedule(), clock_update_flags will have been
 * shifted left (a left shift is a cheap operation for the fast path
 * to promote %RQCF_REQ_SKIP to %RQCF_ACT_SKIP), so you must use,
 *
 *	if (rq-clock_update_flags &gt;= RQCF_UPDATED)
 *
 * to check if %RQCF_UPDATED is set. It'll never be shifted more than
 * one position though, because the next rq_unpin_lock() will shift it
 * back.
 */
#define RQCF_REQ_SKIP		0x01
#define RQCF_ACT_SKIP		0x02
#define RQCF_UPDATED		0x04
</pre>
<p>
其中取值为RQCF_REQ_SKIP时，再左移一位就是RQCF_ACT_SKIP，这个值在update_rq_clock里会引起它的直接返回，也就是说内核其它地方可以通过将clock_update_flags设置为RQCF_REQ_SKIP以指示__schedule函数里调用update_rq_clock实际不进行调度时钟值的更新，这样可以省去一部分开销，当然在设置为RQCF_REQ_SKIP的路径上就必然调用过uodate_rq_clock对时钟进行了更新。
</p>

<p>
接下来分析下update_rq_clock函数：
</p>
<pre class="example" id="orgb7fe9d1">
void update_rq_clock(struct rq *rq)
{
	s64 delta;
	u64 clock;

	lockdep_assert_rq_held(rq);

	if (rq-&gt;clock_update_flags &amp; RQCF_ACT_SKIP)
		return;

#ifdef CONFIG_SCHED_DEBUG
	if (sched_feat(WARN_DOUBLE_CLOCK))
		SCHED_WARN_ON(rq-&gt;clock_update_flags &amp; RQCF_UPDATED);
	rq-&gt;clock_update_flags |= RQCF_UPDATED;
#endif
	clock = sched_clock_cpu(cpu_of(rq));
	scx_rq_clock_update(rq, clock);

	delta = clock - rq-&gt;clock;
	if (delta &lt; 0)
		return;
	rq-&gt;clock += delta;

	update_rq_clock_task(rq, delta);
}
</pre>
<p>
这里可以看到如果clock_update_flags为RQCF_ACT_SKIP，那么就直接返回了，而不更新rq里的对应时钟，然后本次更新了时钟，就将clock_update_flags设置为RQCF_UPDATED。
</p>

<p>
update_rq_clock函数通过sched_clock_cpu获得当前的时间戳（在x86架构上一般就是rdtsc指令），和上次记录的clock相减后得到本次增加的delta时间，关于sched_clock_cpu的实现涉及内核clock模块，参见笔者其它文章介绍。
</p>

<p>
在这里简单介绍下cpu_of的实现：
</p>
<pre class="example" id="orgdec0d6d">
static inline int cpu_of(struct rq *rq)
{
#ifdef CONFIG_SMP
	return rq-&gt;cpu;
#else
	return 0;
#endif
}
</pre>
<p>
调度初始化函数sched_init里完成了rq-&gt;cpu的设置：
</p>
<pre class="example" id="org9de30bd">
for_each_possible_cpu(i) {
	rq-&gt;cpu = i;
}
</pre>
<p>
随后的scx_rq_clock_update是在配置了CONFIG_SCHED_CLASS_EXT时有有效定义，该配置主要是一个基于BPF（Berkeley Packet Filter）的可扩展调度框架，旨在让开发者能够快速编写、部署和实验新的调度策略，而不需要修改Linux内核的核心代码。可以像开发普通BPF程序一样调整调度逻辑，无需重新编译内核，应用程序可以定义专属的CPU调度策略，提高性能，做到无中断地切换调度策略，而不需要重启系统或重编译内核。具体的实现细节可以参考笔者其它文章。
</p>

<p>
rq-&gt;clock是真实的物理时间增量，所以直接往上增加delta，但update_rq_clock_task里更新的rq里的成员需要对delta进行调整：
</p>

<pre class="example" id="orga15de94">
static void update_rq_clock_task(struct rq *rq, s64 delta)
{
/*
 * In theory, the compile should just see 0 here, and optimize out the call
 * to sched_rt_avg_update. But I don't trust it...
 */
	s64 __maybe_unused steal = 0, irq_delta = 0;

#ifdef CONFIG_IRQ_TIME_ACCOUNTING
	if (irqtime_enabled()) {
		irq_delta = irq_time_read(cpu_of(rq)) - rq-&gt;prev_irq_time;

		/*
		 * Since irq_time is only updated on {soft,}irq_exit, we might run into
		 * this case when a previous update_rq_clock() happened inside a
		 * {soft,}IRQ region.
		 *
		 * When this happens, we stop -&gt;clock_task and only update the
		 * prev_irq_time stamp to account for the part that fit, so that a next
		 * update will consume the rest. This ensures -&gt;clock_task is
		 * monotonic.
		 *
		 * It does however cause some slight miss-attribution of {soft,}IRQ
		 * time, a more accurate solution would be to update the irq_time using
		 * the current rq-&gt;clock timestamp, except that would require using
		 * atomic ops.
		 */
		if (irq_delta &gt; delta)
			irq_delta = delta;

		rq-&gt;prev_irq_time += irq_delta;
		delta -= irq_delta;
		delayacct_irq(rq-&gt;curr, irq_delta);
	}
#endif
#ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING
	if (static_key_false((&amp;paravirt_steal_rq_enabled))) {
		u64 prev_steal;

		steal = prev_steal = paravirt_steal_clock(cpu_of(rq));
		steal -= rq-&gt;prev_steal_time_rq;

		if (unlikely(steal &gt; delta))
			steal = delta;

		rq-&gt;prev_steal_time_rq = prev_steal;
		delta -= steal;
	}
#endif

	rq-&gt;clock_task += delta;

#ifdef CONFIG_HAVE_SCHED_AVG_IRQ
	if ((irq_delta + steal) &amp;&amp; sched_feat(NONTASK_CAPACITY))
		update_irq_load_avg(rq, irq_delta + steal);
#endif
	update_rq_clock_pelt(rq, delta);
}
</pre>
<p>
CONFIG_IRQ_TIME_ACCOUNTING配置控制的代码主要是要从任务的运行时间里扣除其用于中断的时间，delayacct_irq的实现还可以将这个花费在中断上的时间（也就是由irq引起的delay）给统计到task_struct::delays::irq_delay，当然前提是开启了CONFIG_TASK_DELAY_ACCT，当然开启这个配置能统计到的delay不只是irq，还有比如blkio，swap等。
</p>

<p>
一个问题是如果这个中断就是任务引起的，是不是也应当属于任务自己的时间。
</p>

<p>
CONFIG_PARAVIRT_TIME_ACCOUNTING主要针对虚拟化环境下，如果一个VCPU被Hypervisor抢占，那么需要从运行的delta时间里扣除这部分，因为实际上这部分时间任务并没有运行，使得进程的CPU使用率更加准确。
</p>

<p>
CONFIG_HAVE_SCHED_AVG_IRQ在笔者环境一般没有配置。
</p>

<p>
最后update_rq_clock_task-&gt;update_rq_clock_pelt里会按cpu的算力以及频率对delta物理时间进行缩放，也就是经过相同的delta时间，算力强频率高的cpu实际负载更大：
</p>
<pre class="example" id="org6011267">
/*
 * The clock_pelt scales the time to reflect the effective amount of
 * computation done during the running delta time but then sync back to
 * clock_task when rq is idle.
 *
 *
 * absolute time   | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16
 * @ max capacity  ------******---------------******---------------
 * @ half capacity ------************---------************---------
 * clock pelt      | 1| 2|    3|    4| 7| 8| 9|   10|   11|14|15|16
 *
 */
static inline void update_rq_clock_pelt(struct rq *rq, s64 delta)
{
	if (unlikely(is_idle_task(rq-&gt;curr))) {
		_update_idle_rq_clock_pelt(rq);
		return;
	}

	/*
	 * When a rq runs at a lower compute capacity, it will need
	 * more time to do the same amount of work than at max
	 * capacity. In order to be invariant, we scale the delta to
	 * reflect how much work has been really done.
	 * Running longer results in stealing idle time that will
	 * disturb the load signal compared to max capacity. This
	 * stolen idle time will be automatically reflected when the
	 * rq will be idle and the clock will be synced with
	 * rq_clock_task.
	 */

	/*
	 * Scale the elapsed time to reflect the real amount of
	 * computation
	 */
	delta = cap_scale(delta, arch_scale_cpu_capacity(cpu_of(rq)));
	delta = cap_scale(delta, arch_scale_freq_capacity(cpu_of(rq)));

	rq-&gt;clock_pelt += delta;
}
</pre>
<pre class="example" id="orge2f8f6a">
#define cap_scale(v, s)		((v)*(s) &gt;&gt; SCHED_CAPACITY_SHIFT)
</pre>
<p>
update_rq_clock_pelt按频率以及算力缩放的值放在rq::clock_pelt量里。
</p>
<div class="centered-line">update_rq_clock</div>
<p>
arch_scale_cpu_capacity用于获取cpu的计算能力：
</p>
<pre class="example" id="orgc548202">
unsigned long arch_scale_cpu_capacity(int cpu)
{
	if (static_branch_unlikely(&amp;arch_hybrid_cap_scale_key))
		return READ_ONCE(per_cpu_ptr(arch_cpu_scale, cpu)-&gt;capacity);

	return SCHED_CAPACITY_SCALE;
}
</pre>
<p>
hybrid一般就是针对arm架构开启了big.LITTLE，而针对Intel x86就是P-core/E-core，针对笔者的配置，就是返回默认的SCHED_CAPACITY_SCALE，也就是没有区分不同cpu的算力：
</p>
<pre class="example" id="orgb57ec4a">
# define SCHED_FIXEDPOINT_SHIFT		10
# define SCHED_CAPACITY_SHIFT		SCHED_FIXEDPOINT_SHIFT
# define SCHED_CAPACITY_SCALE		(1L &lt;&lt; SCHED_CAPACITY_SHIFT)
</pre>
<p>
这里可以看到，固定CPU算力就是1024，第一次通过cap_scale对算力进行scale，不过cpu_scale又右移动了，等于delta过的多少时间就是多少负载，因为算力一样。
</p>

<p>
第二个arch_scale_freq_capacity是根据频率来缩放delta时间，这个宏对于x86架构来说就是读取percpu变量arch_freq_scale，其设置会经由scale_freq_tick函数调用this_cpu_write，本质上是MSR_IA32_APERF和MSR_IA32_MPERF这两个msr寄存器分别各自做出差值delta，将delta差值做比值得商，写入arch_scale_freq_capacity是为当前频率需要缩放的比例，MSR_IA32_APERF（Actual PerformanceFrequency）是实际实际工作的时钟周期数，而MSR_IA32_MPERF（Maximum Performance Frequency）是理论最大工作周期数。比值商大于1代表当前处于turbo模式，睿频运行，小于1代表没有满频率运行。
</p>

<p>
注意scale_freq_tick里通过check_shl_overflow先将acnt（MSR_IA32_APERF）乘以2**20进行放大，然后通过check_mul_overflow将mcnt（MSR_IA32_MPERF）乘以2**10也进行放大（假如没有开启hybrid异构算力架构），最终其实是把delta(acnt)和delta(mcnt)的比值本来是个小数，乘以了1024，这样就是1024是比值1，小于1024的代表小数，大于1024的话代表比值大于1，cpu频率处于turbo状态。这是内核优化小数运行的常见手段，将小数乘以一个1024这样整数，避免内核做浮点运算，当然最小精度只有1/1024，可以调整为2048等等大的数值，可以将更小的小数表示到整数范围，也可以做截断处理，当发现小数小于1/1024，直接赋值为0。
</p>

<p>
最后的rq::clock_pelt是两者做了scale的和。
</p>

<p>
回到__schedule继续分析，先取出了nivcsw，这个计数表示非自愿上下文切换（non-voluntary
context switch），“非自愿”的意思是任务被抢占或被强制切换了。参数sched_mode表示了调度模式，最后preempt保存了是否是抢占模式调度，SM_PREEMPT代表抢占模式。prev-&gt;__state是任务的状态，比如TASK_RUNNING、TASK_INTERRUPTIBLE等。
</p>

<p>
如果是因为空闲调度模式进入调度器，那么表示这时可能没有其它任务要执行了，并且rq运行队列里也没有可运行的任务了，并且没有启用BPF调度器时，那么实际没有切换任务，因为next = prev，然后就直接goto picked了，不用经过pick_next_task去挑选下一个需要运行的任务了，而如果不是抢占切换，这代表当前任务主动让出cpu想要block阻塞自己，那么调用try_to_block_task将当前任务标记为阻塞状态，并从运行队列里移除，这种情况下要切换计数的指针为nvcsw，表示自愿上下文切换，因为后面要自增这个计数，到底自增哪个计数，需要根据不同情况选择。
</p>
</div>
</div>

<div id="outline-container-org47cd20c" class="outline-2">
<h2 id="org47cd20c"><span class="section-number-2">2.</span> pick_next_task</h2>
<div class="outline-text-2" id="text-2">
<p>
pick_next_task的实现依据是否开启CONFIG_SCHED_CORE配置有不同的实现，这个配置是支持SMT的，比如Intel的Hyper-Threading，一般没有开启这个配置，这样它实现如下：
</p>
<pre class="example" id="org303ba8c">
static struct task_struct *
pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
{
	return __pick_next_task(rq, prev, rf);
}

/*
 * Pick up the highest-prio task:
 */
static inline struct task_struct *
__pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
{
	const struct sched_class *class;
	struct task_struct *p;

	rq-&gt;dl_server = NULL;

	if (scx_enabled())
		goto restart;

	/*
	 * Optimization: we know that if all tasks are in the fair class we can
	 * call that function directly, but only if the @prev task wasn't of a
	 * higher scheduling class, because otherwise those lose the
	 * opportunity to pull in more work from other CPUs.
	 */
	if (likely(!sched_class_above(prev-&gt;sched_class, &amp;fair_sched_class) &amp;&amp;
		   rq-&gt;nr_running == rq-&gt;cfs.h_nr_queued)) {

		p = pick_next_task_fair(rq, prev, rf);
		if (unlikely(p == RETRY_TASK))
			goto restart;

		/* Assume the next prioritized class is idle_sched_class */
		if (!p) {
			p = pick_task_idle(rq);
			put_prev_set_next_task(rq, prev, p);
		}

		return p;
	}

restart:
	prev_balance(rq, prev, rf);

	for_each_active_class(class) {
		if (class-&gt;pick_next_task) {
			p = class-&gt;pick_next_task(rq, prev);
			if (p)
				return p;
		} else {
			p = class-&gt;pick_task(rq);
			if (p) {
				put_prev_set_next_task(rq, prev, p);
				return p;
			}
		}
	}

	BUG(); /* The idle class should always have a runnable task. */
}
</pre>
<p>
该函数主要分两部分，restart前的部分是针对CFS调度的优化，就是通用rq里正在运行的所有进程数量等于CFS队列里排队的进程数量并且即将被换出去的进程prev所属的调度类优先级不高于fair_sched_class类时，这样说明当前cpu的rq里只有CFS的进程，那么直接调用pick_next_task_fair选合适的进程来运行即可，这算是一种优化，不用每次都遍历所有调度类。
</p>

<p>
如果不能满足上述条件，那么就会走restart标签的代码去遍历所有调度类找到一个合适的进程去运行，下面针对这两部分分别详细分析。
</p>

<p>
先看下sche_class_above的实现：
</p>
<pre class="example" id="orgc182e65">
#define sched_class_above(_a, _b)	((_a) &lt; (_b))
</pre>
<p>
sched_class_above就是判断即将要调度出去的prev所属的调度类prev-&gt;sched_class的优先级是否高于fair_sched_class的优先级，若是就返回true，否则返回false。所以调度类的优先级高低，实际就是看调度类变量的地址小的优先级高，为什么由调度类变量的地址的大小就能确定一个调度类的优先级呢？这实际跟调度类的初始化代码以及链接器角度有关。
</p>

<p>
以fair_sched_class的定义为例：
</p>
<pre class="example" id="orgfcb02a4">
/*
 * All the scheduling class methods:
 */
DEFINE_SCHED_CLASS(fair) = {

	.enqueue_task		= enqueue_task_fair,
	.dequeue_task		= dequeue_task_fair,
	.yield_task		= yield_task_fair,
	.yield_to_task		= yield_to_task_fair,

      ...
};
</pre>
<pre class="example" id="org7aafe9d">
/*
 * Helper to define a sched_class instance; each one is placed in a separate
 * section which is ordered by the linker script:
 *
 *   include/asm-generic/vmlinux.lds.h
 *
 * *CAREFUL* they are laid out in *REVERSE* order!!!
 *
 * Also enforce alignment on the instance, not the type, to guarantee layout.
 */
#define DEFINE_SCHED_CLASS(name) \
const struct sched_class name##_sched_class \
	__aligned(__alignof__(struct sched_class)) \
	__section("__" #name "_sched_class")
</pre>
<p>
以上定义会使得fair_sched_class这个量被放到__fair_sched_class这个section里，其它调度类也是类似的定义方式：
</p>
<pre class="example" id="orgb641bf5">
DEFINE_SCHED_CLASS(rt)
DEFINE_SCHED_CLASS(idle)
DEFINE_SCHED_CLASS(stop)
DEFINE_SCHED_CLASS(dl)
DEFINE_SCHED_CLASS(ext)
</pre>
<p>
这些调度类会被链接脚本按序放置：
</p>
<pre class="example" id="org6f69002">
/*
 * The order of the sched class addresses are important, as they are
 * used to determine the order of the priority of each sched class in
 * relation to each other.
 */
#define SCHED_DATA				\
	STRUCT_ALIGN();				\
	__sched_class_highest = .;		\
	*(__stop_sched_class)			\
	*(__dl_sched_class)			\
	*(__rt_sched_class)			\
	*(__fair_sched_class)			\
	*(__ext_sched_class)			\
	*(__idle_sched_class)			\
	__sched_class_lowest = .;
</pre>
<p>
比如，*(__dl_sched_class)表示把所有放入__dl_sched_class段的对象，链接到当前地址，链接地址按每行依次增大，这样具有较小地址的调度类拥有更高的优先级，这样sched_class_above采用直接比较地址大小的办法来确定不同调度类的优先级就有了根据。
</p>

<p>
现在简单分析下另一个条件就是：
</p>
<pre class="example" id="orgabd4fbf">
rq-&gt;nr_running == rq-&gt;cfs.h_nr_queued
</pre>
<p>
条件本身是简单明晰的，就是现在通用rq运行队列里的所有正在运行的进程数量等于cfs队列里排队的进程数量，各个调度类在入队/出队都是可以操作rq::nr_running计数的，比如stop调度类出队进程时：
</p>
<pre class="example" id="orge345969">
dequeue_task_stop-&gt;sub_nr_running
</pre>
<p>
stop调度类入队时：
</p>
<pre class="example" id="orge784e7e">
enqueue_task_stop-&gt;add_nr_running
</pre>
<p>
对于fair CFS调度类来说也是一样，比如出队时：
</p>
<pre class="example" id="orgbf39639">
dequeue_entities-&gt;sub_nr_running
</pre>
<p>
入队时：
</p>
<pre class="example" id="org4a7b8cc">
enqueue_task_fair-&gt;add_nr_running
</pre>
<p>
同时，如果CFS操作了rq::nr_running，那么也会同步操作cfs_rq::h_nr_queued，比如在dequeue_entities里先会对cfs_rq::h_nr_queued进行递减，才会调用sub_nr_running去递减通用rq::nr_running计数，所以如果上述的条件满足，就意味着没有其它调度类的进程被enqueue到通用rq队列里，这样就可以直接调用CFS类的pick_next_task_fair函数了。如果从CFS队列里没能选出进程，那么就可以调用pick_task_idle选一个空闲进程来运行了，当然前提是fair调度类的下一个优先级的调度类就是idle类。
</p>

<p>
restart标签下的代码，先做了下负载均衡，prev_balance会从prev所属的调度类往下的优先级去遍历调度类，然后调用这些调度类的balance函数（如果有的话），当然restart下最重要的逻辑还是从最高优先级的调度类往最低优先级的调度类遍历，去寻找一个可以运行的进程：
</p>
<pre class="example" id="org11f048a">
#define for_each_active_class(class)						\
	for_active_class_range(class, __sched_class_highest, __sched_class_lowest)
#define for_active_class_range(class, _from, _to)				\
	for (class = (_from); class != (_to); class = next_active_class(class))
/*
 * Iterate only active classes. SCX can take over all fair tasks or be
 * completely disabled. If the former, skip fair. If the latter, skip SCX.
 */
static inline const struct sched_class *next_active_class(const struct sched_class *class)
{
	class++;
#ifdef CONFIG_SCHED_CLASS_EXT
	if (scx_switched_all() &amp;&amp; class == &amp;fair_sched_class)
		class++;
	if (!scx_enabled() &amp;&amp; class == &amp;ext_sched_class)
		class++;
#endif
	return class;
}
</pre>
<p>
有了前面对于使用调度类地址反应调度优先级的原理说明，现在看这个调度类遍历宏的实现就简单多了，就不必过多介绍了。这里只是再提下sched_class::pick_next_task和sched_class::pick_task在这里的不同调用表现，前者一般就只有CFS调度类实现了，使用pick_next_task就无需调度核心框架（kernel/sched/core.c）再去调用put_prev_set_next_task函数了。
</p>

<p>
最后idle调度类的进程一定可以有一个进程运行，所以最后有个BUG。
</p>

<p>
下面开始分析pick_next_task_fair函数：
</p>
<pre class="example" id="org6a79585">
struct task_struct *
pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
{
	struct sched_entity *se;
	struct task_struct *p;
	int new_tasks;

again:
	p = pick_task_fair(rq);
	if (!p)
		goto idle;
	se = &amp;p-&gt;se;

#ifdef CONFIG_FAIR_GROUP_SCHED
	if (prev-&gt;sched_class != &amp;fair_sched_class)
		goto simple;

	__put_prev_set_next_dl_server(rq, prev, p);

	/*
	 * Because of the set_next_buddy() in dequeue_task_fair() it is rather
	 * likely that a next task is from the same cgroup as the current.
	 *
	 * Therefore attempt to avoid putting and setting the entire cgroup
	 * hierarchy, only change the part that actually changes.
	 *
	 * Since we haven't yet done put_prev_entity and if the selected task
	 * is a different task than we started out with, try and touch the
	 * least amount of cfs_rqs.
	 */
	if (prev != p) {
		struct sched_entity *pse = &amp;prev-&gt;se;
		struct cfs_rq *cfs_rq;

		while (!(cfs_rq = is_same_group(se, pse))) {
			int se_depth = se-&gt;depth;
			int pse_depth = pse-&gt;depth;

			if (se_depth &lt;= pse_depth) {
				put_prev_entity(cfs_rq_of(pse), pse);
				pse = parent_entity(pse);
			}
			if (se_depth &gt;= pse_depth) {
				set_next_entity(cfs_rq_of(se), se);
				se = parent_entity(se);
			}
		}

		put_prev_entity(cfs_rq, pse);
		set_next_entity(cfs_rq, se);

		__set_next_task_fair(rq, p, true);
	}

	return p;

simple:
#endif
	put_prev_set_next_task(rq, prev, p);
	return p;

idle:
	if (!rf)
		return NULL;

	new_tasks = sched_balance_newidle(rq, rf);

	/*
	 * Because sched_balance_newidle() releases (and re-acquires) rq-&gt;lock, it is
	 * possible for any higher priority task to appear. In that case we
	 * must re-start the pick_next_entity() loop.
	 */
	if (new_tasks &lt; 0)
		return RETRY_TASK;

	if (new_tasks &gt; 0)
		goto again;

	/*
	 * rq is about to be idle, check if we need to update the
	 * lost_idle_time of clock_pelt
	 */
	update_idle_rq_clock_pelt(rq);

	return NULL;
}
</pre>
<p>
该函数主体逻辑有三方面，一是通过pick_task_fair函数去选下一个运行的进程，二是处理组调度的逻辑，三是如果没有可运行的进程，还需要调用sched_balance_newidle去拉取其它rq（cpu）上的任务。
</p>

<p>
pick_task_fair留后面分析。如果这个函数选不出进程了，也就是p为空，就会跳到idle标签，其下的逻辑就是通过sched_balance_newidle去拉取其它cpu上任务，如果能拉取成功（返回值大于0），就会跳到again通过pick_task_fair再次挑选任务运行。
</p>

<p>
在开启了组调度并且要被切换的prev进程所属的调度类是CFS时，就会有一些逻辑处理组调度，如果条件不满足就是跳到simple标签，也就是只需要简单的对prev进行put操作就行。
</p>

<p>
处理组调度的逻辑相对复杂一些，首先组调度有一个depth层级的概念，所有调度实体组成一棵调度树，叶子节点是可以运行的进程实体，而中间的层代表了其下任务的总行为。对于挑选出来即将运行p和即将切换出去的prev，如果它们不同，就会对它们循环向上降低深度，对于prev路径上的任务要进行put操作，而对于p路径上的任务要进行set操作，每次迭代期间，哪个较深，就通过parent_entity找到对应sched_entity的父调度实体，其实质也就是sched_entity::depth会减小。is_same_group会判断迭代的路径上两个sched_entity是否属于相同的组了：
</p>

<pre class="example" id="org73066eb">
/* Do the two (enqueued) entities belong to the same group ? */
static inline struct cfs_rq *
is_same_group(struct sched_entity *se, struct sched_entity *pse)
{
	if (se-&gt;cfs_rq == pse-&gt;cfs_rq)
		return se-&gt;cfs_rq;

	return NULL;
}
</pre>
<p>
如果迭代到两个sched_entity属于同一个cfs rq时，这时put/set操作就可以停下来了，这算是一种优化，不用操作整个调度树。
</p>

<p>
前面提到了set/put操作，具体的函数实现分别就是set_next_entity和put_prev_entity，下面分析下这两个函数。首先是set_next_entity：
</p>
<pre class="example" id="orga350aa9">
static void
set_next_entity(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	clear_buddies(cfs_rq, se);

	/* 'current' is not kept within the tree. */
	if (se-&gt;on_rq) {
		/*
		 * Any task has to be enqueued before it get to execute on
		 * a CPU. So account for the time it spent waiting on the
		 * runqueue.
		 */
		update_stats_wait_end_fair(cfs_rq, se);
		__dequeue_entity(cfs_rq, se);
		update_load_avg(cfs_rq, se, UPDATE_TG);

		set_protect_slice(se);
	}

	update_stats_curr_start(cfs_rq, se);
	WARN_ON_ONCE(cfs_rq-&gt;curr);
	cfs_rq-&gt;curr = se;

	/*
	 * Track our maximum slice length, if the CPU's load is at
	 * least twice that of our own weight (i.e. don't track it
	 * when there are only lesser-weight tasks around):
	 */
	if (schedstat_enabled() &amp;&amp;
	    rq_of(cfs_rq)-&gt;cfs.load.weight &gt;= 2*se-&gt;load.weight) {
		struct sched_statistics *stats;

		stats = __schedstats_from_se(se);
		__schedstat_set(stats-&gt;slice_max,
				max((u64)stats-&gt;slice_max,
				    se-&gt;sum_exec_runtime - se-&gt;prev_sum_exec_runtime));
	}

	se-&gt;prev_sum_exec_runtime = se-&gt;sum_exec_runtime;
}
</pre>
<p>
内核调度器在pick出一个进程运行前，都需要先对它进行set操作，所谓set操作，主要包括，如果进程还在等待队列上（on_rq被设置，在红黑树上就绪等待），那么需要将pick出的进程进行出队，因为一个马上就要运行的进程是不会同时又在红黑就绪树上等待的，这里可能会有点歧义，“出队”反而是代表进程要获得cpu运行了，正确的理解是，每个进程在运行前都需要enqueue到rq（红黑就绪树），在要获得cpu运行时需要dequeue，这里的enqueue/dequeue是针对红黑就绪树而说的，而不是上cpu运行来说enqueue/dequeue，一个典型的流程是：
</p>
<pre class="example" id="org8278770">
唤醒 -&gt; enqueue_entity -&gt; 等待红黑树调度 -&gt; 被选中 -&gt; dequeue_entity -&gt; 上CPU
</pre>
<p>
总结起来就是，在CFS中，“出队（dequeue）”不是表示进程失去了运行权，而恰恰相反，是调度器确认它将获得运行权的标志性动作。enqueue/dequeue操作本质上是对红黑树的数据结构维护，而非进程运行与否的直接体现。
</p>

<p>
set操作还有就是更新即将运行进程的一些统计状态，最后一个比较重要的动作是设置cfs_rq::curr为当前选择出来即将运行的sched_entity，curr代表当前在cfs_rq上运行的实体，如果没有运行的进程就设置为NULL。
</p>

<p>
下面详细分析下set_next_entity的细节。clear_buddies用于清除sched_entity所在cfs_rq的buddy信息。
</p>

<p>
接下来如果sched_entity::on_rq非零，代表调度实体还在红黑就绪树上，那么这时需要通过update_stats_wait_end_fair函数更新它花在rq上的等待时间，随后__dequeue_entity出队rq，update_load_avg更新一下负载，set_protect_slice设置保护时间片，依次分析。
</p>

<pre class="example" id="orga1f09e9">
static inline void
update_stats_wait_end_fair(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	struct sched_statistics *stats;
	struct task_struct *p = NULL;

	if (!schedstat_enabled())
		return;

	stats = __schedstats_from_se(se);

	/*
	 * When the sched_schedstat changes from 0 to 1, some sched se
	 * maybe already in the runqueue, the se-&gt;statistics.wait_start
	 * will be 0.So it will let the delta wrong. We need to avoid this
	 * scenario.
	 */
	if (unlikely(!schedstat_val(stats-&gt;wait_start)))
		return;

	if (entity_is_task(se))
		p = task_of(se);

	__update_stats_wait_end(rq_of(cfs_rq), p, stats);
}
</pre>

<p>
schedstat_enabled在没有开启CONFIG_SCHEDSTATS时都是0，否则就是sched_schedstats分支变量：
</p>
<pre class="example" id="org4bfb51a">
#define   schedstat_enabled()		static_branch_unlikely(&amp;sched_schedstats)
</pre>
<p>
笔者的环境开启了CONFIG_SCHEDSTATS配置，但是sched_schedstats默认是0的：
</p>
<pre class="example" id="orgb67700c">
DEFINE_STATIC_KEY_FALSE(sched_schedstats);
</pre>
<p>
所以通常情况下，update_stats_wait_end_fair在schedstat_enabled判断就该返回了，也就是cat /proc/schedstat默认是看不到wait_max，wait_count以及wait_sum这些成员的。
</p>

<p>
分析sched_schedstats这个分支变量，可以通过set_schedstats这个函数开关它：
</p>
<pre class="example" id="orgc6078da">
static void set_schedstats(bool enabled)
{
	if (enabled)
		static_branch_enable(&amp;sched_schedstats);
	else
		static_branch_disable(&amp;sched_schedstats);
}
</pre>
<p>
调用set_schedstats（也就是设置sched_schedstats）有两种手段一是通过启动命令行添加schedstats=enable，再有就是修改/proc/sys/kernel/sched_schedstats为1。
</p>

<p>
假设现在开启了sched_schedstats，那么往下就会通过__schedstats_from_se去获得sched_statistics调度统计结构体：
</p>
<pre class="example" id="orgde6a6ec">
static inline struct sched_statistics *
__schedstats_from_se(struct sched_entity *se)
{
#ifdef CONFIG_FAIR_GROUP_SCHED
	if (!entity_is_task(se))
		return &amp;container_of(se, struct sched_entity_stats, se)-&gt;stats;
#endif
	return &amp;task_of(se)-&gt;stats;
}
</pre>
<p>
该函数的实现分两种情况，一是配置了组调度并且当前实体并不是一个实际的任务，那么sched_statistics结构体实际是内嵌在了sched_entity_stats结构体，所以可以用container_of这种结构体偏移的办法获得调度统计结构体。
</p>

<p>
这里判断一个实体是否是实际任务的办法很简单（当然是针对开启组调度CONFIG_FAIR_GROUP_SCHED而说的，没有开启这个配置时，任何调度实体sched_entity都是可上CPU运行的）：
</p>
<pre class="example" id="orgf98d5f3">
#define entity_is_task(se)	(!se-&gt;my_q)
</pre>
<p>
my_q其实就是在开启组调度时（非空），该调度实体下拥有的cfs调度队列。
</p>

<p>
没有开启组调度时，__schedstats_from_se，sched_statistics就是内嵌在task_struct里的。
</p>

<p>
拿到了sched_statistics后，就有一个防御性检查判断，那就是wait_start要非0，wait_start是可能为0的，比如按如上的使用sysctl变量的方法开启该功能时，wait_start之前没有开启时是0，这样后面再算调度实体的等待运行时间就会变得很大（或者离谱）。
</p>

<p>
再往后的代码拿了下对应调度实体的task_struct结构体。
</p>

<p>
最后是真正的更新统计动作：
</p>
<pre class="example" id="org817770f">
void __update_stats_wait_end(struct rq *rq, struct task_struct *p,
			     struct sched_statistics *stats)
{
	u64 delta = rq_clock(rq) - schedstat_val(stats-&gt;wait_start);

	if (p) {
		if (task_on_rq_migrating(p)) {
			/*
			 * Preserve migrating task's wait time so wait_start
			 * time stamp can be adjusted to accumulate wait time
			 * prior to migration.
			 */
			__schedstat_set(stats-&gt;wait_start, delta);

			return;
		}

		trace_sched_stat_wait(p, delta);
	}

	__schedstat_set(stats-&gt;wait_max,
			max(schedstat_val(stats-&gt;wait_max), delta));
	__schedstat_inc(stats-&gt;wait_count);
	__schedstat_add(stats-&gt;wait_sum, delta);
	__schedstat_set(stats-&gt;wait_start, 0);
}
</pre>
<p>
这个函数的逻辑是显而易见的了，用rq_clock获得的clock减去之前记录的开始等待的时间wait_start（入队时会设置），就是当前调度实体等待了多久才获得cpu，同时设置新的可能变化的wait_max，也即最大等待时间，同时wait_count自增，wait_sum累加，由于__update_stats_wait_end结束后调度实体马上会上CPU运行，所以要设置wait_start为0。
</p>

<p>
这里需要说明说明的是，task_struct::on_rq其实有三种状态，为0代表正在cpu上运行，为1代表在rq上排队，而为2代表在迁移到另一个rq的过程：
</p>
<pre class="example" id="orgc753be0">
/* task_struct::on_rq states: */
#define TASK_ON_RQ_QUEUED	1
#define TASK_ON_RQ_MIGRATING	2
</pre>
<p>
task_on_rq_queued定义如下：
</p>
<pre class="example" id="org3ee5669">
static inline int task_on_rq_migrating(struct task_struct *p)
{
	return READ_ONCE(p-&gt;on_rq) == TASK_ON_RQ_MIGRATING;
}
</pre>
<p>
处理在迁移状态进程的等待时间是一个边界条件，在某个cpuA的rqA上等待了一段时间delta_A，还没有上cpuA运行时，就被迁移到了另一个cpuB时，在新的rqB上又等待了一段时间delta_B，那么总的等待时间应该是delta_A + delta_B，在__update_stats_wait_end里只是将这个delta时间给到了wait_start，也就是这时wait_start的语义其实发生了变化，不再是一个时间戳，而是一段时间长度，然后就返回了。而在__update_stats_wait_start的实现里，设置起始的开始等待时间时，会将wait_start减去这个已经等待的时间prev_wait_start（就是delta_A + delta_B）：
</p>
<pre class="example" id="orgfb238f3">
void __update_stats_wait_start(struct rq *rq, struct task_struct *p,
			       struct sched_statistics *stats)
{
	u64 wait_start, prev_wait_start;

	wait_start = rq_clock(rq);
	prev_wait_start = schedstat_val(stats-&gt;wait_start);

	if (p &amp;&amp; likely(wait_start &gt; prev_wait_start))
		wait_start -= prev_wait_start;

	__schedstat_set(stats-&gt;wait_start, wait_start);
}
</pre>
<p>
这样相当于把开始等待的时间往前拨了些，以达到累计等待时间的效果。对__update_stats_wait_start的调用可以是：
</p>
<pre class="example" id="org894ded0">
update_stats_enqueue_fair-&gt;update_stats_wait_start_fair-&gt;__update_stats_wait_start
</pre>
<p>
也可以是：
</p>
<pre class="example" id="orga4eba57">
put_prev_entity-&gt;update_stats_wait_start_fair-&gt;__update_stats_wait_start
</pre>
<p>
前者是调度实体入队的时候，后者是从CPU上撤下重新put到rq时，这些时机都需要记录开始等待的时间戳。
</p>

<p>
set调度实体的下一个动作是将调度实体dequeue出rq红黑树队列：
</p>
<pre class="example" id="org4d4d525">
static void __dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	rb_erase_augmented_cached(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline,
				  &amp;min_vruntime_cb);
	avg_vruntime_sub(cfs_rq, se);
}
</pre>
<pre class="example" id="org6ab160f">
static __always_inline void
rb_erase_augmented_cached(struct rb_node *node, struct rb_root_cached *root,
			  const struct rb_augment_callbacks *augment)
{
	if (root-&gt;rb_leftmost == node)
		root-&gt;rb_leftmost = rb_next(node);
	rb_erase_augmented(node, &amp;root-&gt;rb_root, augment);
}
</pre>
<p>
cfs_rq里的tasks_timeline成员就是大名鼎鼎的任务挂载的红黑树，其定义如下：
</p>
<pre class="example" id="org9085a25">
struct rb_root_cached {
	struct rb_root rb_root;
	struct rb_node *rb_leftmost;
};
</pre>
<p>
rb_leftmost是缓存的整个树的所有进程里，下一个即将运行的进程，而rb_root是所有进程形成树的根节点，sched_entity::run_node用来代表调度实体往树上挂载，如果当前出队的进程就刚好是rb_leftmost的话，那么rb_leftmost需要更新，因为当前进程出队了。rb_erase_augmented里是真正的删除节点的操作，里面还会维护二叉红黑树的性质，具体的本文主题就不介绍了。由于当前调度实体出队了，一些负载要从当前的cfs_rq里扣除，这就是avg_vruntime_sub做的事情：
</p>
<pre class="example" id="org06a70ee">
static void
avg_vruntime_sub(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	unsigned long weight = scale_load_down(se-&gt;load.weight);
	s64 key = entity_key(cfs_rq, se);

	cfs_rq-&gt;avg_vruntime -= key * weight;
	cfs_rq-&gt;avg_load -= weight;
}
</pre>
<p>
进程的weight一般通过set_load_weight去设置。
</p>

<p>
下一个动作是通过update_load_avg进行负载更新，进程的负载计算本篇主题不打算详细介绍，另开PELT算法主题单独介绍，总的来说该函数会将负载按周期进行衰减，这里的周期是1024us，也就是约为1ms，当前周期对负载的共享就是L，过去1ms内是L * y1，过去第2ms内是L * y^2，依次类推，其中y ^32 = 0.5。
</p>

<p>
update_stats_curr_start更新了现在调度实体开始运行的时间戳：
</p>
<pre class="example" id="org19c36c0">
/*
 * We are picking a new current task - update its stats:
 */
static inline void
update_stats_curr_start(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	/*
	 * We are starting a new run period:
	 */
	se-&gt;exec_start = rq_clock_task(rq_of(cfs_rq));
}
</pre>
<p>
cfs_rq当前运行的实体curr也要改成当前的se。
</p>

<p>
最后的一段代码是记录下当前se的最大运行slice时间片，用当前的sum_exec_runtime减去上次的这个累计执行时间，并和之前的取大者。不过这个更新是有条件的，那就是当前cfs_rq的负载要较大（大于sed两倍）。这样set动作就介绍完了。
</p>

<p>
下面是介绍put动作：
</p>
<pre class="example" id="org7f329fa">
static void put_prev_entity(struct cfs_rq *cfs_rq, struct sched_entity *prev)
{
	/*
	 * If still on the runqueue then deactivate_task()
	 * was not called and update_curr() has to be done:
	 */
	if (prev-&gt;on_rq)
		update_curr(cfs_rq);

	/* throttle cfs_rqs exceeding runtime */
	check_cfs_rq_runtime(cfs_rq);

	if (prev-&gt;on_rq) {
		update_stats_wait_start_fair(cfs_rq, prev);
		/* Put 'current' back into the tree. */
		__enqueue_entity(cfs_rq, prev);
		/* in !on_rq case, update occurred at dequeue */
		update_load_avg(cfs_rq, prev, 0);
	}
	WARN_ON_ONCE(cfs_rq-&gt;curr != prev);
	cfs_rq-&gt;curr = NULL;
}
</pre>
<p>
如果prev在rq上，就需要更新下当前sched_entity的一些运行时信息，最重要的信息当属sched_entity::vruntime（较新的内核使用新的调度算法，sched_entity::deadline替代了vruntime的功能），因为它（较新的内核是sched_entity::deadline）会用来确定插入进程红黑树的位置，而插入的位置又决定调度哪个进程上CPU运行：
</p>
<pre class="example" id="org93fedfa">
/*
 * Update the current task's runtime statistics.
 */
static void update_curr(struct cfs_rq *cfs_rq)
{
	struct sched_entity *curr = cfs_rq-&gt;curr;
	struct rq *rq = rq_of(cfs_rq);
	s64 delta_exec;
	bool resched;

	if (unlikely(!curr))
		return;

	delta_exec = update_curr_se(rq, curr);
	if (unlikely(delta_exec &lt;= 0))
		return;

	curr-&gt;vruntime += calc_delta_fair(delta_exec, curr);
	resched = update_deadline(cfs_rq, curr);
	update_min_vruntime(cfs_rq);

	if (entity_is_task(curr)) {
		struct task_struct *p = task_of(curr);

		update_curr_task(p, delta_exec);

		/*
		 * If the fair_server is active, we need to account for the
		 * fair_server time whether or not the task is running on
		 * behalf of fair_server or not:
		 *  - If the task is running on behalf of fair_server, we need
		 *    to limit its time based on the assigned runtime.
		 *  - Fair task that runs outside of fair_server should account
		 *    against fair_server such that it can account for this time
		 *    and possibly avoid running this period.
		 */
		if (dl_server_active(&amp;rq-&gt;fair_server))
			dl_server_update(&amp;rq-&gt;fair_server, delta_exec);
	}

	account_cfs_rq_runtime(cfs_rq, delta_exec);

	if (cfs_rq-&gt;nr_queued == 1)
		return;

	if (resched || did_preempt_short(cfs_rq, curr)) {
		resched_curr_lazy(rq);
		clear_buddies(cfs_rq, curr);
	}
}
</pre>
<p>
先通过update_curr_se算出delta_exec：
</p>
<pre class="example" id="org6aa6543">
static s64 update_curr_se(struct rq *rq, struct sched_entity *curr)
{
	u64 now = rq_clock_task(rq);
	s64 delta_exec;

	delta_exec = now - curr-&gt;exec_start;
	if (unlikely(delta_exec &lt;= 0))
		return delta_exec;

	curr-&gt;exec_start = now;
	curr-&gt;sum_exec_runtime += delta_exec;

	if (schedstat_enabled()) {
		struct sched_statistics *stats;

		stats = __schedstats_from_se(curr);
		__schedstat_set(stats-&gt;exec_max,
				max(delta_exec, stats-&gt;exec_max));
	}

	return delta_exec;
}
</pre>
<p>
delta_exec开始就是进程运行了多少时间，同时这个函数还更新了exec_start为新的现在的时间，累加了进程总运行时间sum_exec_runtime，进程运行的最大时间长度exec_max也可能会被更新。
</p>

<p>
接下来的calc_delta_fair里的逻辑是体现哪个进程优先调度的关键逻辑：
</p>
<pre class="example" id="orgbe7db0a">
/*
 * delta /= w
 */
static inline u64 calc_delta_fair(u64 delta, struct sched_entity *se)
{
	if (unlikely(se-&gt;load.weight != NICE_0_LOAD))
		delta = __calc_delta(delta, NICE_0_LOAD, &amp;se-&gt;load);

	return delta;
}
</pre>
<pre class="example" id="org72febde">
/*
 * delta_exec * weight / lw.weight
 *   OR
 * (delta_exec * (weight * lw-&gt;inv_weight)) &gt;&gt; WMULT_SHIFT
 *
 * Either weight := NICE_0_LOAD and lw \e sched_prio_to_wmult[], in which case
 * we're guaranteed shift stays positive because inv_weight is guaranteed to
 * fit 32 bits, and NICE_0_LOAD gives another 10 bits; therefore shift &gt;= 22.
 *
 * Or, weight =&lt; lw.weight (because lw.weight is the runqueue weight), thus
 * weight/lw.weight &lt;= 1, and therefore our shift will also be positive.
 */
static u64 __calc_delta(u64 delta_exec, unsigned long weight, struct load_weight *lw)
{
	u64 fact = scale_load_down(weight);
	u32 fact_hi = (u32)(fact &gt;&gt; 32);
	int shift = WMULT_SHIFT;
	int fs;

	__update_inv_weight(lw);

	if (unlikely(fact_hi)) {
		fs = fls(fact_hi);
		shift -= fs;
		fact &gt;&gt;= fs;
	}

	fact = mul_u32_u32(fact, lw-&gt;inv_weight);

	fact_hi = (u32)(fact &gt;&gt; 32);
	if (fact_hi) {
		fs = fls(fact_hi);
		shift -= fs;
		fact &gt;&gt;= fs;
	}

	return mul_u64_u32_shr(delta_exec, fact, shift);
}
</pre>
<p>
从这些逻辑可以看到，是把delta_exec进行了缩放，缩放的比例就是NICE_0_LOAD/weight_of_se，而sched_entity::weight经由函数set_load_weight设置：
</p>
<pre class="example" id="org4cd7055">
void set_load_weight(struct task_struct *p, bool update_load)
{
	int prio = p-&gt;static_prio - MAX_RT_PRIO;
	struct load_weight lw;

	if (task_has_idle_policy(p)) {
		lw.weight = scale_load(WEIGHT_IDLEPRIO);
		lw.inv_weight = WMULT_IDLEPRIO;
	} else {
		lw.weight = scale_load(sched_prio_to_weight[prio]);
		lw.inv_weight = sched_prio_to_wmult[prio];
	}

	/*
	 * SCHED_OTHER tasks have to update their load when changing their
	 * weight
	 */
	if (update_load &amp;&amp; p-&gt;sched_class-&gt;reweight_task)
		p-&gt;sched_class-&gt;reweight_task(task_rq(p), p, &amp;lw);
	else
		p-&gt;se.load = lw;
}
</pre>
<p>
这里比较关键的就是有个sched_prio_to_weight数组：
</p>
<pre class="example" id="org9d0a7aa">
/*
 * Nice levels are multiplicative, with a gentle 10% change for every
 * nice level changed. I.e. when a CPU-bound task goes from nice 0 to
 * nice 1, it will get ~10% less CPU time than another CPU-bound task
 * that remained on nice 0.
 *
 * The "10% effect" is relative and cumulative: from _any_ nice level,
 * if you go up 1 level, it's -10% CPU usage, if you go down 1 level
 * it's +10% CPU usage. (to achieve that we use a multiplier of 1.25.
 * If a task goes up by ~10% and another task goes down by ~10% then
 * the relative distance between them is ~25%.)
 */
const int sched_prio_to_weight[40] = {
 /* -20 */     88761,     71755,     56483,     46273,     36291,
 /* -15 */     29154,     23254,     18705,     14949,     11916,
 /* -10 */      9548,      7620,      6100,      4904,      3906,
 /*  -5 */      3121,      2501,      1991,      1586,      1277,
 /*   0 */      1024,       820,       655,       526,       423,
 /*   5 */       335,       272,       215,       172,       137,
 /*  10 */       110,        87,        70,        56,        45,
 /*  15 */        36,        29,        23,        18,        15,
};
</pre>
<p>
该数组是按nice值作为优先级填充的，相邻的nice值差距大约25%的CPU使用率，nice为0定义为1024。与之对应的是2^32 / weight的另一个数组sched_prio_to_wmult，这个值是为后面除以weight提前算的，因为对weight做除，效率较低，可以直接乘以这个数组里的值再右移2^32位，抵消了提前乘的2^32次方：
</p>
<pre class="example" id="org6b5ca1b">
/*
 * Inverse (2^32/x) values of the sched_prio_to_weight[] array, pre-calculated.
 *
 * In cases where the weight does not change often, we can use the
 * pre-calculated inverse to speed up arithmetics by turning divisions
 * into multiplications:
 */
const u32 sched_prio_to_wmult[40] = {
 /* -20 */     48388,     59856,     76040,     92818,    118348,
 /* -15 */    147320,    184698,    229616,    287308,    360437,
 /* -10 */    449829,    563644,    704093,    875809,   1099582,
 /*  -5 */   1376151,   1717300,   2157191,   2708050,   3363326,
 /*   0 */   4194304,   5237765,   6557202,   8165337,  10153587,
 /*   5 */  12820798,  15790321,  19976592,  24970740,  31350126,
 /*  10 */  39045157,  49367440,  61356676,  76695844,  95443717,
 /*  15 */ 119304647, 148102320, 186737708, 238609294, 286331153,
};
</pre>
<p>
具体的__calc_delta里的计算方式会有一些优化，就不详细分析了。这样__calc_delta最后返回值的效果就是，对于权重越大的（nice值越低），NICE_0_LOAD / weight这个比率就越小接近0，这样会把delta_exec缩放的越小，那么update_curr里的语句：
</p>
<pre class="example" id="org3a977fe">
curr-&gt;vruntime += calc_delta_fair(delta_exec, curr);
</pre>
<p>
往vruntime里累加的值就越小，而往进程红黑树里插入进程时比较的key值就是这里的vruntime（较新的调度算法是sched_entity::deadline，但原理类似），越小的vruntime越容易出现在进程调度红黑树的左半部分而选择被调度运行。
</p>

<p>
update_curr接下来调用update_deadline更新sched_entity::deadline的值：
</p>
<pre class="example" id="orgbad11c2">
/*
 * XXX: strictly: vd_i += N*r_i/w_i such that: vd_i &gt; ve_i
 * this is probably good enough.
 */
static bool update_deadline(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	if ((s64)(se-&gt;vruntime - se-&gt;deadline) &lt; 0)
		return false;

	/*
	 * For EEVDF the virtual time slope is determined by w_i (iow.
	 * nice) while the request time r_i is determined by
	 * sysctl_sched_base_slice.
	 */
	if (!se-&gt;custom_slice)
		se-&gt;slice = sysctl_sched_base_slice;

	/*
	 * EEVDF: vd_i = ve_i + r_i / w_i
	 */
	se-&gt;deadline = se-&gt;vruntime + calc_delta_fair(se-&gt;slice, se);

	/*
	 * The task has consumed its request, reschedule.
	 */
	return true;
}
</pre>
<p>
这里可以看到，新的EEVDF算法会sched_entity::deadline，它是vruntime以及slice也通过calc_delta_fair进行缩放后的和，vruntime前面介绍过，权重越大（nice越低），vruntime增长越慢，但是留给到下一次运行的时间也少，更高权重的任务，在申请同样的运行时间（slice）时，会得到一个“更短的deadline”，即期望更快完成调度。
</p>

<p>
update_curr后面调用update_min_vruntime：
</p>
<pre class="example" id="org6d3df74">
static u64 __update_min_vruntime(struct cfs_rq *cfs_rq, u64 vruntime)
{
	u64 min_vruntime = cfs_rq-&gt;min_vruntime;
	/*
	 * open coded max_vruntime() to allow updating avg_vruntime
	 */
	s64 delta = (s64)(vruntime - min_vruntime);
	if (delta &gt; 0) {
		avg_vruntime_update(cfs_rq, delta);
		min_vruntime = vruntime;
	}
	return min_vruntime;
}

static void update_min_vruntime(struct cfs_rq *cfs_rq)
{
	struct sched_entity *se = __pick_root_entity(cfs_rq);
	struct sched_entity *curr = cfs_rq-&gt;curr;
	u64 vruntime = cfs_rq-&gt;min_vruntime;

	if (curr) {
		if (curr-&gt;on_rq)
			vruntime = curr-&gt;vruntime;
		else
			curr = NULL;
	}

	if (se) {
		if (!curr)
			vruntime = se-&gt;min_vruntime;
		else
			vruntime = min_vruntime(vruntime, se-&gt;min_vruntime);
	}

	/* ensure we never gain time by being placed backwards. */
	cfs_rq-&gt;min_vruntime = __update_min_vruntime(cfs_rq, vruntime);
}
</pre>
<p>
这里要提下，更新cfs_rq::min_vruntime可不是delta &lt; 0才更新，而是delta &gt; 0，也就是新传进来的vruntime较大时，反而更新成这个vruntime，看起来不符合min_vruntime的字面意义，最小值不是应该越来越小吗？但实际上：这个vruntime是已经挑选好、即将要执行的任务的vruntime（cfs_rq::curr），也就是说，整个运行队列中，已经没有比它更小的vruntime了（小的都已经调度走了）。因此，这时可以安全地推进min_vruntime，它仍然代表“当前所有活跃任务中（在cfs_rq中的）最小的vruntime”。
</p>

<p>
如果cfs_rq::curr是一个任务的话，调用update_curr_task-&gt;account_group_exec_runtime去更新累加到所在线程组用的时间
</p>
<pre class="example" id="org02c6563">
static inline void update_curr_task(struct task_struct *p, s64 delta_exec)
{
	trace_sched_stat_runtime(p, delta_exec);
	account_group_exec_runtime(p, delta_exec);
	cgroup_account_cputime(p, delta_exec);
}
</pre>
<pre class="example" id="orgaef7067">
/**
 * account_group_exec_runtime - Maintain exec runtime for a thread group.
 *
 * @tsk:	Pointer to task structure.
 * @ns:		Time value by which to increment the sum_exec_runtime field
 *		of the thread_group_cputime structure.
 *
 * If thread group time is being maintained, get the structure for the
 * running CPU and update the sum_exec_runtime field there.
 */
static inline void account_group_exec_runtime(struct task_struct *tsk,
					      unsigned long long ns)
{
	struct thread_group_cputimer *cputimer = get_running_cputimer(tsk);

	if (!cputimer)
		return;

	atomic64_add(ns, &amp;cputimer-&gt;cputime_atomic.sum_exec_runtime);
}
</pre>
<p>
而随后的account_cfs_rq_runtime会从cfs_rq::runtime_remaining里减去运行的delta_exec，这个功能呢跟CONFIG_CFS_BANDWIDTH有关。
</p>

<p>
如果update_deadline返回的resched为true，也就是需要重新调度当前进程，那么就会resched_curr_lazy设置需要重新调度的标志TIF_NEED_RESCHED：
</p>
<pre class="example" id="orgba87a36">
void resched_curr_lazy(struct rq *rq)
{
	__resched_curr(rq, get_lazy_tif_bit());
}
</pre>
<pre class="example" id="org834b837">
static __always_inline int get_lazy_tif_bit(void)
{
	if (dynamic_preempt_lazy())
		return TIF_NEED_RESCHED_LAZY;

	return TIF_NEED_RESCHED;
}
</pre>
<pre class="example" id="org67ac323">
/*
 * resched_curr - mark rq's current task 'to be rescheduled now'.
 *
 * On UP this means the setting of the need_resched flag, on SMP it
 * might also involve a cross-CPU call to trigger the scheduler on
 * the target CPU.
 */
static void __resched_curr(struct rq *rq, int tif)
{
	struct task_struct *curr = rq-&gt;curr;
	struct thread_info *cti = task_thread_info(curr);
	int cpu;

	lockdep_assert_rq_held(rq);

	/*
	 * Always immediately preempt the idle task; no point in delaying doing
	 * actual work.
	 */
	if (is_idle_task(curr) &amp;&amp; tif == TIF_NEED_RESCHED_LAZY)
		tif = TIF_NEED_RESCHED;

	if (cti-&gt;flags &amp; ((1 &lt;&lt; tif) | _TIF_NEED_RESCHED))
		return;

	cpu = cpu_of(rq);

	if (cpu == smp_processor_id()) {
		set_ti_thread_flag(cti, tif);
		if (tif == TIF_NEED_RESCHED)
			set_preempt_need_resched();
		return;
	}

	if (set_nr_and_not_polling(cti, tif)) {
		if (tif == TIF_NEED_RESCHED)
			smp_send_reschedule(cpu);
	} else {
		trace_sched_wake_idle_without_ipi(cpu);
	}
}
</pre>
<p>
一旦设置，中断返回、抢占点、定时器中断等都会检测这个标志，内核会尽快调用schedule进行上下文切换，如果是跨cpu，会通过IPI使其他CPU尽快进入调度流程。
</p>

<p>
这样update_curr介绍完了，回到put_prev_entity，如果sched_entity::on_rq非0，注意为非0时（on_rq = 1），任务可能在等待（红黑树中），也可能在运行（当前CPU上）。这段时间都算作任务仍在runqueue中，只有cfs_rq::curr指向的任务当前才正在CPU上运行，所以回顾update_curr是要先取cfs_rq::curr，然后更新其统计运行信息。
</p>

<p>
这样sched_entity::on_rq为非0时，就需要调用__enqueue_entity重新入下红黑树：
</p>
<pre class="example" id="org32b7b7b">
/*
 * Enqueue an entity into the rb-tree:
 */
static void __enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	avg_vruntime_add(cfs_rq, se);
	se-&gt;min_vruntime = se-&gt;vruntime;
	se-&gt;min_slice = se-&gt;slice;
	rb_add_augmented_cached(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline,
				__entity_less, &amp;min_vruntime_cb);
}
</pre>
<pre class="example" id="org6ba1316">
static inline bool __entity_less(struct rb_node *a, const struct rb_node *b)
{
	return entity_before(__node_2_se(a), __node_2_se(b));
}
</pre>
<pre class="example" id="org6edf7d3">
static inline bool entity_before(const struct sched_entity *a,
				 const struct sched_entity *b)
{
	/*
	 * Tiebreak on vruntime seems unnecessary since it can
	 * hardly happen.
	 */
	return (s64)(a-&gt;deadline - b-&gt;deadline) &lt; 0;
}
</pre>
<p>
到这里就可以很清楚的看到，插入rq红黑树的比较依据就是deadline（较老的调度算法只看vruntime）小的在树的左半部分优先调用到，这就是进程调度相对核心的逻辑，具体的树结构tasks_timeline前面已经涉及到了。
</p>

<p>
最后cfs_rq::curr被设置为NULL，代表当前cfs_rq上没有进程运行。
</p>

<p>
这样pick_next_task_fair里的set/put动作都介绍完了。
</p>

<p>
往下想看下通过sched_balance_newidle去从别的rq上拉取任务的逻辑：
</p>
<pre class="example" id="orgdd152f7">
/*
 * sched_balance_newidle is called by schedule() if this_cpu is about to become
 * idle. Attempts to pull tasks from other CPUs.
 *
 * Returns:
 *   &lt; 0 - we released the lock and there are !fair tasks present
 *     0 - failed, no new tasks
 *   &gt; 0 - success, new (fair) tasks present
 */
static int sched_balance_newidle(struct rq *this_rq, struct rq_flags *rf)
{
	unsigned long next_balance = jiffies + HZ;
	int this_cpu = this_rq-&gt;cpu;
	int continue_balancing = 1;
	u64 t0, t1, curr_cost = 0;
	struct sched_domain *sd;
	int pulled_task = 0;

	update_misfit_status(NULL, this_rq);

	/*
	 * There is a task waiting to run. No need to search for one.
	 * Return 0; the task will be enqueued when switching to idle.
	 */
	if (this_rq-&gt;ttwu_pending)
		return 0;

	/*
	 * We must set idle_stamp _before_ calling sched_balance_rq()
	 * for CPU_NEWLY_IDLE, such that we measure the this duration
	 * as idle time.
	 */
	this_rq-&gt;idle_stamp = rq_clock(this_rq);

	/*
	 * Do not pull tasks towards !active CPUs...
	 */
	if (!cpu_active(this_cpu))
		return 0;

	/*
	 * This is OK, because current is on_cpu, which avoids it being picked
	 * for load-balance and preemption/IRQs are still disabled avoiding
	 * further scheduler activity on it and we're being very careful to
	 * re-start the picking loop.
	 */
	rq_unpin_lock(this_rq, rf);

	rcu_read_lock();
	sd = rcu_dereference_check_sched_domain(this_rq-&gt;sd);

	if (!get_rd_overloaded(this_rq-&gt;rd) ||
	    (sd &amp;&amp; this_rq-&gt;avg_idle &lt; sd-&gt;max_newidle_lb_cost)) {

		if (sd)
			update_next_balance(sd, &amp;next_balance);
		rcu_read_unlock();

		goto out;
	}
	rcu_read_unlock();

	raw_spin_rq_unlock(this_rq);

	t0 = sched_clock_cpu(this_cpu);
	sched_balance_update_blocked_averages(this_cpu);

	rcu_read_lock();
	for_each_domain(this_cpu, sd) {
		u64 domain_cost;

		update_next_balance(sd, &amp;next_balance);

		if (this_rq-&gt;avg_idle &lt; curr_cost + sd-&gt;max_newidle_lb_cost)
			break;

		if (sd-&gt;flags &amp; SD_BALANCE_NEWIDLE) {

			pulled_task = sched_balance_rq(this_cpu, this_rq,
						   sd, CPU_NEWLY_IDLE,
						   &amp;continue_balancing);

			t1 = sched_clock_cpu(this_cpu);
			domain_cost = t1 - t0;
			update_newidle_cost(sd, domain_cost);

			curr_cost += domain_cost;
			t0 = t1;
		}

		/*
		 * Stop searching for tasks to pull if there are
		 * now runnable tasks on this rq.
		 */
		if (pulled_task || !continue_balancing)
			break;
	}
	rcu_read_unlock();

	raw_spin_rq_lock(this_rq);

	if (curr_cost &gt; this_rq-&gt;max_idle_balance_cost)
		this_rq-&gt;max_idle_balance_cost = curr_cost;

	/*
	 * While browsing the domains, we released the rq lock, a task could
	 * have been enqueued in the meantime. Since we're not going idle,
	 * pretend we pulled a task.
	 */
	if (this_rq-&gt;cfs.h_nr_queued &amp;&amp; !pulled_task)
		pulled_task = 1;

	/* Is there a task of a high priority class? */
	if (this_rq-&gt;nr_running != this_rq-&gt;cfs.h_nr_queued)
		pulled_task = -1;

out:
	/* Move the next balance forward */
	if (time_after(this_rq-&gt;next_balance, next_balance))
		this_rq-&gt;next_balance = next_balance;

	if (pulled_task)
		this_rq-&gt;idle_stamp = 0;
	else
		nohz_newidle_balance(this_rq);

	rq_repin_lock(this_rq, rf);

	return pulled_task;
}
</pre>
<p>
pelt load计算以及上面的负载均衡都可以另开主题，本片主题主要是进程调度，就不详细分析了。
</p>

<p>
以上其实对pick_next_task的介绍整体上就差不多了，下面回到__schedule函数，开始介绍picked部分，picked部分主要的逻辑是切换mm，在prev和选出来要运行的next不是一个进程时，就涉及到切换mm，这主要是通过context_switch来完成的，这留给下一节去分析。
</p>
</div>
</div>
<div id="outline-container-org054ea4d" class="outline-2">
<h2 id="org054ea4d"><span class="section-number-2">3.</span> context_switch</h2>
<div class="outline-text-2" id="text-3">
<p>
context_switch是完成进程切换至关重要的函数，在context_switch-&gt;switch_to里面，CPU执行流其实已经去到了另外一个线程，在那个执行流里其实也是从context_switch里的switch_to开始，未来回到当前执行流第一入口点还是这里的context_swith-&gt;switch_to，也就是说__schedule返回了，__schedule自身是去往另一个CPU执行流（另一个线程的逻辑）。
</p>

<p>
以下是context_switch的代码：
</p>
<pre class="example" id="org1fc924f">
/*
 * context_switch - switch to the new MM and the new thread's register state.
 */
static __always_inline struct rq *
context_switch(struct rq *rq, struct task_struct *prev,
	       struct task_struct *next, struct rq_flags *rf)
{
	prepare_task_switch(rq, prev, next);

	/*
	 * For paravirt, this is coupled with an exit in switch_to to
	 * combine the page table reload and the switch backend into
	 * one hypercall.
	 */
	arch_start_context_switch(prev);

	/*
	 * kernel -&gt; kernel   lazy + transfer active
	 *   user -&gt; kernel   lazy + mmgrab_lazy_tlb() active
	 *
	 * kernel -&gt;   user   switch + mmdrop_lazy_tlb() active
	 *   user -&gt;   user   switch
	 *
	 * switch_mm_cid() needs to be updated if the barriers provided
	 * by context_switch() are modified.
	 */
	if (!next-&gt;mm) {                                // to kernel
		enter_lazy_tlb(prev-&gt;active_mm, next);

		next-&gt;active_mm = prev-&gt;active_mm;
		if (prev-&gt;mm)                           // from user
			mmgrab_lazy_tlb(prev-&gt;active_mm);
		else
			prev-&gt;active_mm = NULL;
	} else {                                        // to user
		membarrier_switch_mm(rq, prev-&gt;active_mm, next-&gt;mm);
		/*
		 * sys_membarrier() requires an smp_mb() between setting
		 * rq-&gt;curr / membarrier_switch_mm() and returning to userspace.
		 *
		 * The below provides this either through switch_mm(), or in
		 * case 'prev-&gt;active_mm == next-&gt;mm' through
		 * finish_task_switch()'s mmdrop().
		 */
		switch_mm_irqs_off(prev-&gt;active_mm, next-&gt;mm, next);
		lru_gen_use_mm(next-&gt;mm);

		if (!prev-&gt;mm) {                        // from kernel
			/* will mmdrop_lazy_tlb() in finish_task_switch(). */
			rq-&gt;prev_mm = prev-&gt;active_mm;
			prev-&gt;active_mm = NULL;
		}
	}

	/* switch_mm_cid() requires the memory barriers above. */
	switch_mm_cid(rq, prev, next);

	prepare_lock_switch(rq, next, rf);

	/* Here we just switch the register state and the stack. */
	switch_to(prev, next, prev);
	barrier();

	return finish_task_switch(prev);
}
</pre>
<p>
从这个函数可以看到，主要分几种情况可以延迟做tlb的刷新操作，切换到内核线程时不必做切换mm的操作，因为内核线程没有自己的mm，一般不会访问用户空间，只需通过enter_lazy_tlb设置上一个标志，表示延迟做tlb刷新操作：
</p>
<pre class="example" id="orgfdc83ee">
/*
 * Please ignore the name of this function.  It should be called
 * switch_to_kernel_thread().
 *
 * enter_lazy_tlb() is a hint from the scheduler that we are entering a
 * kernel thread or other context without an mm.  Acceptable implementations
 * include doing nothing whatsoever, switching to init_mm, or various clever
 * lazy tricks to try to minimize TLB flushes.
 *
 * The scheduler reserves the right to call enter_lazy_tlb() several times
 * in a row.  It will notify us that we're going back to a real mm by
 * calling switch_mm_irqs_off().
 */
void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
{
	if (this_cpu_read(cpu_tlbstate.loaded_mm) == &amp;init_mm)
		return;

	this_cpu_write(cpu_tlbstate_shared.is_lazy, true);
}
</pre>
<p>
先看prepare_task_switch的实现：
</p>
<pre class="example" id="org31e1539">
/**
 * prepare_task_switch - prepare to switch tasks
 * @rq: the runqueue preparing to switch
 * @prev: the current task that is being switched out
 * @next: the task we are going to switch to.
 *
 * This is called with the rq lock held and interrupts off. It must
 * be paired with a subsequent finish_task_switch after the context
 * switch.
 *
 * prepare_task_switch sets up locking and calls architecture specific
 * hooks.
 */
static inline void
prepare_task_switch(struct rq *rq, struct task_struct *prev,
		    struct task_struct *next)
{
	kcov_prepare_switch(prev);
	sched_info_switch(rq, prev, next);
	perf_event_task_sched_out(prev, next);
	rseq_preempt(prev);
	fire_sched_out_preempt_notifiers(prev, next);
	kmap_local_sched_out();
	prepare_task(next);
	prepare_arch_switch(next);
}
</pre>
<p>
kcov_prepare_switch主要是代码覆盖率统计方面的逻辑，该配置一般没配。接着看sched_info_switch：
</p>
<pre class="example" id="org519c919">
/*
 * Called when tasks are switched involuntarily due, typically, to expiring
 * their time slice.  (This may also be called when switching to or from
 * the idle task.)  We are only called when prev != next.
 */
static inline void
sched_info_switch(struct rq *rq, struct task_struct *prev, struct task_struct *next)
{
	/*
	 * prev now departs the CPU.  It's not interesting to record
	 * stats about how efficient we were at scheduling the idle
	 * process, however.
	 */
	if (prev != rq-&gt;idle)
		sched_info_depart(rq, prev);

	if (next != rq-&gt;idle)
		sched_info_arrive(rq, next);
}
</pre>
<p>
SCHED_INFO可以导出很多调度方面的信息，所以一般是开启的。这里主要分两种情况统计调度信息，只要即将被换出的prev或者即将被换入的next都不是idle的话，都会调用对应的函数进行统计操作，先看sched_info_depart函数：
</p>
<pre class="example" id="org8e50109">
/*
 * Called when a process ceases being the active-running process involuntarily
 * due, typically, to expiring its time slice (this may also be called when
 * switching to the idle task).  Now we can calculate how long we ran.
 * Also, if the process is still in the TASK_RUNNING state, call
 * sched_info_enqueue() to mark that it has now again started waiting on
 * the runqueue.
 */
static inline void sched_info_depart(struct rq *rq, struct task_struct *t)
{
	unsigned long long delta = rq_clock(rq) - t-&gt;sched_info.last_arrival;

	rq_sched_info_depart(rq, delta);

	if (task_is_running(t))
		sched_info_enqueue(rq, t);
}
</pre>
<p>
last_arrival是上次prev作为换入进程通过sched_info_arrive设置的，待会还会看到这个函数的分析。在sched_info_depart里，拿到现在的clock减去上次的last_arrival，就是本轮运行的delta，以这个参数调用rq_sched_info_depart：
</p>
<pre class="example" id="org0e8a170">
/*
 * Expects runqueue lock to be held for atomicity of update
 */
static inline void
rq_sched_info_depart(struct rq *rq, unsigned long long delta)
{
	if (rq)
		rq-&gt;rq_cpu_time += delta;
}
</pre>
<p>
可以看到该函数就是往该rq的rq_cpu_time上累加了delta时间，这个成员可以认为是该rq总共运行了多少cpu时间。task_is_running判断任务状态还是TASK_RUNNING的话，就会调用sched_info_enqueue重新记录排队时间戳：
</p>
<pre class="example" id="orgdd31fff">
#define task_is_running(task)		(READ_ONCE((task)-&gt;__state) == TASK_RUNNING)
</pre>
<pre class="example" id="org1742c51">
/*
 * This function is only called from enqueue_task(), but also only updates
 * the timestamp if it is already not set.  It's assumed that
 * sched_info_dequeue() will clear that stamp when appropriate.
 */
static inline void sched_info_enqueue(struct rq *rq, struct task_struct *t)
{
	if (!t-&gt;sched_info.last_queued)
		t-&gt;sched_info.last_queued = rq_clock(rq);
}
</pre>
<p>
就是进程只是下物理CPU了，但并没有离开rq运行队列，所以last_queued记录的是离开物理CPU在rq的时刻。
</p>

<p>
继续看sched_info_arrive，该函数处理将要调度上CPU的进程的统计信息：
</p>
<pre class="example" id="org421b144">
/*
 * Called when a task finally hits the CPU.  We can now calculate how
 * long it was waiting to run.  We also note when it began so that we
 * can keep stats on how long its time-slice is.
 */
static void sched_info_arrive(struct rq *rq, struct task_struct *t)
{
	unsigned long long now, delta = 0;

	if (!t-&gt;sched_info.last_queued)
		return;

	now = rq_clock(rq);
	delta = now - t-&gt;sched_info.last_queued;
	t-&gt;sched_info.last_queued = 0;
	t-&gt;sched_info.run_delay += delta;
	t-&gt;sched_info.last_arrival = now;
	t-&gt;sched_info.pcount++;
	if (delta &gt; t-&gt;sched_info.max_run_delay)
		t-&gt;sched_info.max_run_delay = delta;
	if (delta &amp;&amp; (!t-&gt;sched_info.min_run_delay || delta &lt; t-&gt;sched_info.min_run_delay))
		t-&gt;sched_info.min_run_delay = delta;

	rq_sched_info_arrive(rq, delta);
}
</pre>
<p>
该函数主要用现在的时间戳now减去之前排队的时间戳last_queued，这样就得到了等待时间delta，同时清除last_queued为0，也就是现在任务并不在rq红黑树上进行等待，而是得到了CPU即将运行。run_delay里记录了总的等待延迟，而max_run_delay里记录了最大的等待延迟，这个延迟需要每次比较重新记录，min_run_delay同理。
</p>

<p>
rq_sched_info_arrive主要是统计rq调度队列层面的信息（之前都是讲的进程task_struct层面的信息）：
</p>
<pre class="example" id="org79ad259">
static inline void
rq_sched_info_arrive(struct rq *rq, unsigned long long delta)
{
	if (rq) {
		rq-&gt;rq_sched_info.run_delay += delta;
		rq-&gt;rq_sched_info.pcount++;
	}
}
</pre>
<p>
随后的perf_event_task_sched_out是CONFIG_PERF_EVENTS的功能，perf事件包括软硬件事件，软件事件通过内建机制或通用tracepoints（跟踪点）来支持。大多数现代CPU支持通过性能计数器寄存器来收集性能事件。这些寄存器可以统计某些类型的硬件事件的数量，例如：执行的指令数、遭遇的缓存未命中（cache miss）、分支预测失败（分支错误预测）等，并且不会对内核或应用程序造成性能下降。这些寄存器还可以在事件次数达到某个阈值时触发中断，因此可以用于对运行在该CPU上的代码进行性能分析（profiling）。Linux 的性能事件子系统（Performance Event Subsystem）对这些软件和硬件事件能力进行了抽象，通过系统调用向用户空间提供服务，供tools/perf/目录下的perf工具使用。它提供了基于任务（task）和基于CPU的计数器，并在此基础上提供事件统计功能。
</p>

<p>
fire_sched_out_preempt_noifiers是调用注册在task_struct::preempt_notifiers上的通知链回调函数，比如现在prev要被调度出去了，就需要逐一调用注册在这上面的通知链的回调函数。
</p>

<p>
下一个比较关键的工作就是设置next任务的on_cpu为1，这通过prepare_task：
</p>
<pre class="example" id="orgd9ed42d">
static inline void prepare_task(struct task_struct *next)
{
#ifdef CONFIG_SMP
	/*
	 * Claim the task as running, we do this before switching to it
	 * such that any running task will have this set.
	 *
	 * See the smp_load_acquire(&amp;p-&gt;on_cpu) case in ttwu() and
	 * its ordering comment.
	 */
	WRITE_ONCE(next-&gt;on_cpu, 1);
#endif
}
</pre>
<p>
回到context_switch函数：
</p>
<pre class="example" id="org97fbe2c">
/*
 * kernel -&gt; kernel   lazy + transfer active
 *   user -&gt; kernel   lazy + mmgrab_lazy_tlb() active
 *
 * kernel -&gt;   user   switch + mmdrop_lazy_tlb() active
 *   user -&gt;   user   switch
 *
 * switch_mm_cid() needs to be updated if the barriers provided
 * by context_switch() are modified.
 */
if (!next-&gt;mm) {                                // to kernel
	enter_lazy_tlb(prev-&gt;active_mm, next);

	next-&gt;active_mm = prev-&gt;active_mm;
	if (prev-&gt;mm)                           // from user
		mmgrab_lazy_tlb(prev-&gt;active_mm);
	else
		prev-&gt;active_mm = NULL;
} else {                                        // to user
	membarrier_switch_mm(rq, prev-&gt;active_mm, next-&gt;mm);
	/*
	 * sys_membarrier() requires an smp_mb() between setting
	 * rq-&gt;curr / membarrier_switch_mm() and returning to userspace.
	 *
	 * The below provides this either through switch_mm(), or in
	 * case 'prev-&gt;active_mm == next-&gt;mm' through
	 * finish_task_switch()'s mmdrop().
	 */
	switch_mm_irqs_off(prev-&gt;active_mm, next-&gt;mm, next);
	lru_gen_use_mm(next-&gt;mm);

	if (!prev-&gt;mm) {                        // from kernel
		/* will mmdrop_lazy_tlb() in finish_task_switch(). */
		rq-&gt;prev_mm = prev-&gt;active_mm;
		prev-&gt;active_mm = NULL;
	}
}
</pre>
<p>
如果next是一个内核线程，并不会立即flush tlb，通过enter_lazy_tlb仅设置了一个标记，active_mm是内核线程借用的用户态的mm。
</p>

<p>
else分支是真正会马上进行切换mm的情况，具体调用函数就是switch_mm_irqs_off。
</p>

<p>
下面分析switch_mm_irqs_off函数：
</p>
<pre class="example" id="org736040d">
/*
 * This optimizes when not actually switching mm's.  Some architectures use the
 * 'unused' argument for this optimization, but x86 must use
 * 'cpu_tlbstate.loaded_mm' instead because it does not always keep
 * 'current-&gt;active_mm' up to date.
 */
void switch_mm_irqs_off(struct mm_struct *unused, struct mm_struct *next,
			struct task_struct *tsk)
{
	struct mm_struct *prev = this_cpu_read(cpu_tlbstate.loaded_mm);
	u16 prev_asid = this_cpu_read(cpu_tlbstate.loaded_mm_asid);
	bool was_lazy = this_cpu_read(cpu_tlbstate_shared.is_lazy);
	unsigned cpu = smp_processor_id();
	unsigned long new_lam;
	struct new_asid ns;
	u64 next_tlb_gen;


	/* We don't want flush_tlb_func() to run concurrently with us. */
	if (IS_ENABLED(CONFIG_PROVE_LOCKING))
		WARN_ON_ONCE(!irqs_disabled());

	/*
	 * Verify that CR3 is what we think it is.  This will catch
	 * hypothetical buggy code that directly switches to swapper_pg_dir
	 * without going through leave_mm() / switch_mm_irqs_off() or that
	 * does something like write_cr3(read_cr3_pa()).
	 *
	 * Only do this check if CONFIG_DEBUG_VM=y because __read_cr3()
	 * isn't free.
	 */
#ifdef CONFIG_DEBUG_VM
	if (WARN_ON_ONCE(__read_cr3() != build_cr3(prev-&gt;pgd, prev_asid,
						   tlbstate_lam_cr3_mask()))) {
		/*
		 * If we were to BUG here, we'd be very likely to kill
		 * the system so hard that we don't see the call trace.
		 * Try to recover instead by ignoring the error and doing
		 * a global flush to minimize the chance of corruption.
		 *
		 * (This is far from being a fully correct recovery.
		 *  Architecturally, the CPU could prefetch something
		 *  back into an incorrect ASID slot and leave it there
		 *  to cause trouble down the road.  It's better than
		 *  nothing, though.)
		 */
		__flush_tlb_all();
	}
#endif
	if (was_lazy)
		this_cpu_write(cpu_tlbstate_shared.is_lazy, false);

	/*
	 * The membarrier system call requires a full memory barrier and
	 * core serialization before returning to user-space, after
	 * storing to rq-&gt;curr, when changing mm.  This is because
	 * membarrier() sends IPIs to all CPUs that are in the target mm
	 * to make them issue memory barriers.  However, if another CPU
	 * switches to/from the target mm concurrently with
	 * membarrier(), it can cause that CPU not to receive an IPI
	 * when it really should issue a memory barrier.  Writing to CR3
	 * provides that full memory barrier and core serializing
	 * instruction.
	 */
	if (prev == next) {
		/* Not actually switching mm's */
		VM_WARN_ON(is_dyn_asid(prev_asid) &amp;&amp;
			   this_cpu_read(cpu_tlbstate.ctxs[prev_asid].ctx_id) !=
			   next-&gt;context.ctx_id);

		/*
		 * If this races with another thread that enables lam, 'new_lam'
		 * might not match tlbstate_lam_cr3_mask().
		 */

		/*
		 * Even in lazy TLB mode, the CPU should stay set in the
		 * mm_cpumask. The TLB shootdown code can figure out from
		 * cpu_tlbstate_shared.is_lazy whether or not to send an IPI.
		 */
		if (IS_ENABLED(CONFIG_DEBUG_VM) &amp;&amp;
		    WARN_ON_ONCE(prev != &amp;init_mm &amp;&amp; !is_notrack_mm(prev) &amp;&amp;
				 !cpumask_test_cpu(cpu, mm_cpumask(next))))
			cpumask_set_cpu(cpu, mm_cpumask(next));

		/* Check if the current mm is transitioning to a global ASID */
		if (mm_needs_global_asid(next, prev_asid)) {
			next_tlb_gen = atomic64_read(&amp;next-&gt;context.tlb_gen);
			ns = choose_new_asid(next, next_tlb_gen);
			goto reload_tlb;
		}

		/*
		 * Broadcast TLB invalidation keeps this ASID up to date
		 * all the time.
		 */
		if (is_global_asid(prev_asid))
			return;

		/*
		 * If the CPU is not in lazy TLB mode, we are just switching
		 * from one thread in a process to another thread in the same
		 * process. No TLB flush required.
		 */
		if (!was_lazy)
			return;

		/*
		 * Read the tlb_gen to check whether a flush is needed.
		 * If the TLB is up to date, just use it.
		 * The barrier synchronizes with the tlb_gen increment in
		 * the TLB shootdown code.
		 */
		smp_mb();
		next_tlb_gen = atomic64_read(&amp;next-&gt;context.tlb_gen);
		if (this_cpu_read(cpu_tlbstate.ctxs[prev_asid].tlb_gen) ==
				next_tlb_gen)
			return;

		/*
		 * TLB contents went out of date while we were in lazy
		 * mode. Fall through to the TLB switching code below.
		 */
		ns.asid = prev_asid;
		ns.need_flush = true;
	} else {
		/*
		 * Apply process to process speculation vulnerability
		 * mitigations if applicable.
		 */
		cond_mitigation(tsk);

		/*
		 * Indicate that CR3 is about to change. nmi_uaccess_okay()
		 * and others are sensitive to the window where mm_cpumask(),
		 * CR3 and cpu_tlbstate.loaded_mm are not all in sync.
		 */
		this_cpu_write(cpu_tlbstate.loaded_mm, LOADED_MM_SWITCHING);
		barrier();

		/* Start receiving IPIs and then read tlb_gen (and LAM below) */
		if (next != &amp;init_mm &amp;&amp; !cpumask_test_cpu(cpu, mm_cpumask(next)))
			cpumask_set_cpu(cpu, mm_cpumask(next));
		next_tlb_gen = atomic64_read(&amp;next-&gt;context.tlb_gen);

		ns = choose_new_asid(next, next_tlb_gen);
	}

reload_tlb:
	new_lam = mm_lam_cr3_mask(next);
	if (ns.need_flush) {
		VM_WARN_ON_ONCE(is_global_asid(ns.asid));
		this_cpu_write(cpu_tlbstate.ctxs[ns.asid].ctx_id, next-&gt;context.ctx_id);
		this_cpu_write(cpu_tlbstate.ctxs[ns.asid].tlb_gen, next_tlb_gen);
		load_new_mm_cr3(next-&gt;pgd, ns.asid, new_lam, true);

		trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);
	} else {
		/* The new ASID is already up to date. */
		load_new_mm_cr3(next-&gt;pgd, ns.asid, new_lam, false);

		trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, 0);
	}

	/* Make sure we write CR3 before loaded_mm. */
	barrier();

	this_cpu_write(cpu_tlbstate.loaded_mm, next);
	this_cpu_write(cpu_tlbstate.loaded_mm_asid, ns.asid);
	cpu_tlbstate_update_lam(new_lam, mm_untag_mask(next));

	if (next != prev) {
		cr4_update_pce_mm(next);
		switch_ldt(prev, next);
	}
}
</pre>
<p>
如果之前处于lazy tlb模式下，这时就要清除is_lazy标志了，因为switch_mm_irqs_off函数本身就是要切换mm空间，不再是之前的lazy模式了。在Linux的lazy TLB机制中，当一个进程（task）从CPU上被切换出去后，如果下一个任务共享相同的mm_struct（比如另一个线程），我们不立即清除TLB或切换页表，而只切换寄存器上下文，CPU处于一种“懒惰”的状态，即虽然任务被切走，但它的页表依然保留在TLB 中，直到真正有需要（比如切换到另一个不同的mm）时才清除或更新，这种机制优化了上下文切换的性能，避免不必要的TLB flush和CR3写入。这个状态通过cpu_tlbstate_shared.is_lazy来记录。它是一个每CPU状态变量。
</p>

<p>
随后的逻辑分两个大的部分，一是如果prev和next是同一个进程，那么就很有可能不做真正的切换动作，提前return。但如果prev和next不一样，也就是else分支，那么肯定是要切换mm，所谓切换mm主要有两个方面的事情，一是按新的next进程的页表基地址作为构成cr3的一个部分写到cr3，二是刷新tlb（根据条件看是否要做这个动作）。下面继续分析，首先是prev == next满足的情况，这个分支下先有一个warn判断：
</p>
<pre class="example" id="orgb1323e5">
VM_WARN_ON(is_dyn_asid(prev_asid) &amp;&amp;
	   this_cpu_read(cpu_tlbstate.ctxs[prev_asid].ctx_id) !=
	   next-&gt;context.ctx_id);
</pre>
<p>
context是内嵌在mm_context_t里的，也就是说mm_struct::context::ctx_id也可以唯一标识一个mm_struct，在init_new_context函数里，会初始化这个ctx_id：
</p>
<pre class="example" id="orgf2b1634">
mm-&gt;context.ctx_id = atomic64_inc_return(&amp;last_mm_ctx_id);
</pre>
<p>
last_mm_ctx_id是64位全局只增不回退的计数器，每次当有新的mm_struct申请出来时，都会自增这个计数并初始化给ctx_id，用以唯一确定一个mm_struct，而在switch_mm_irqs_off稍后的逻辑，真正切换了mm_struct时，才会更新cpu_tlbstate.loaded_mm_asid，也就是保证per-cpu上（tlb_state结构体）的loaded_mm_asid准确反应现在用的是哪个ASID（槽），所谓ASID槽，具体指的其实就是tlb_state结构体里的ctxs数组，它的大小为TLB_NR_DYN_ASIDS，x86下是6。tlb_state::ctxs[]共计6个槽，当前正在用的槽由tlb_state::loaded_mm_asid指明，而当前正在用的槽对应是哪个mm_struct，由tlb_state::ctxs[loaded_mm_asid].ctx_id指明。
</p>

<p>
有了以上认知再来继续深入后面X86 tlb管理的代码就容易一些。
</p>

<p>
回到前面的WARN判断，这个WARN判断是在prev == next满足的情况下，那么自然正常情况下，per-cpu上正在使用的tlb_context::ctx_id就该等于task_struct::context::ctx_id，因为在随后的逻辑，就会设置per-cpu里的ctx_id（当然是在刷新tlb时才做这个动作）：
</p>
<pre class="example" id="org9079998">
this_cpu_write(cpu_tlbstate.ctxs[ns.asid].ctx_id, next-&gt;context.ctx_id);
</pre>
<p>
再往下看：
</p>
<pre class="example" id="org83c6866">
/*
 * Even in lazy TLB mode, the CPU should stay set in the
 * mm_cpumask. The TLB shootdown code can figure out from
 * cpu_tlbstate_shared.is_lazy whether or not to send an IPI.
 */
if (IS_ENABLED(CONFIG_DEBUG_VM) &amp;&amp;
    WARN_ON_ONCE(prev != &amp;init_mm &amp;&amp; !is_notrack_mm(prev) &amp;&amp;
		 !cpumask_test_cpu(cpu, mm_cpumask(next))))
	cpumask_set_cpu(cpu, mm_cpumask(next));
</pre>
<p>
正常来说CONFIG_DEBUG_VM不会开启，因为它会影响性能：
</p>
<pre class="example" id="orga972c7b">
Enable this to turn on extended checks in the virtual-memory system
that may impact performance.	 
</pre>
<p>
即使开启了，一般后面的WARN_ON_ONCE也不会满足条件得到执行，但是这些条件和下面的cpumask_set_cpu就是要兜底保证一个mm_struct在某个cpu上使用时，需要将cpu号记录在mm_struct::cpu_bitmap里，这样将来假如其它CPU上也使用了这个mm_struct，然后可以通过如下一些例子路径发送IPI通知到本CPU：
</p>
<pre class="example" id="org517ba49">
unmap_region-&gt;tlb_finish_mmu-&gt;tlb_flush_mmu-&gt;tlb_flush_mmu_tlbonly-&gt;tlb_flush-&gt;flush_tlb_mm-&gt;flush_tlb_mm_range-&gt;flush_tlb_multi-&gt;__flush_tlb_multi-&gt;native_flush_tlb_multi
try_to_unmap-&gt;rmap_walk-&gt;rmap_walk_anon-&gt;rmap_one(try_to_unmap_one)-&gt;flush_tlb_mm_range-&gt;flush_tlb_multi-&gt;__flush_tlb_multi-&gt;native_flush_tlb_multi
exit_mmap-&gt;unmap_vmas-&gt;unmap_single_vma-&gt;unmap_page_range-&gt;zap_p4d_range-&gt;zap_pud_range-&gt;zap_pmd_range-&gt;zap_pte_range-&gt;tlb_flush_mmu_tlbonly-&gt;tlb_flush-&gt;flush_tlb_mm-&gt;flush_tlb_mm_range-&gt;flush_tlb_multi-&gt;__flush_tlb_multi-&gt;native_flush_tlb_multi
</pre>
<p>
在native_flush_tlb_multi里就有针对cpumask里每个cpu去调用flush_tlb_func：
</p>
<pre class="example" id="orgaad65b0">
on_each_cpu_mask(cpumask, flush_tlb_func, (void *)info, true);
</pre>
<p>
可以看到，unmap时就会刷新tlb，可能通知到其它cpu，本质上tlb其实就是缓存的虚拟地址到物理地址的缓存，所以页表变了的话肯定也会刷新tlb以反应新的虚拟地址到物理地址的映射。
</p>

<p>
前面提到了，上面的检查cpu是否在mm_struct::cpu_bitmap里，一般都不会做，那么往mm_struct::cpu_bitmap里设置cpu号是在哪里呢？实际就在switch_mm_irqs_off稍后的逻辑，就是prev== next不满足，确实会切换为不同mm_struct，就会设置上当前cpu号到next的cpu_bitmap：
</p>
<pre class="example" id="org6103f38">
/* Start receiving IPIs and then read tlb_gen (and LAM below) */
if (next != &amp;init_mm &amp;&amp; !cpumask_test_cpu(cpu, mm_cpumask(next)))
	cpumask_set_cpu(cpu, mm_cpumask(next));
</pre>
<p>
这样假如将来需要在next这个mm_struct上执行flush_tlb_func，就可以通过mm_cpumask找到是哪些CPU需要执行这个tlb刷新函数，tlb是每个CPU私有的per-CPU硬件资源，内容不会自动在核间同步，需要显式失效机制来保持一致性，也就是做：
</p>
<pre class="example" id="org4fed738">
flush_tlb_func-&gt;flush_tlb_one_user-&gt;__flush_tlb_one_user-&gt;native_flush_tlb_one_user-&gt;invpcid_flush_one-&gt;__invpcid
</pre>
<p>
最后其实就是invpcid指令，关于它的详细介绍可以参考Intel SDM3 Chapter 4.10。
</p>

<p>
继续往下分析，mm_needs_global_asid-&gt;mm_global_asid主要在AMD平台上使用，因为mm_global_asid在CONFIG_BROADCAST_TLB_FLUSH配置下，但是这个配置：
</p>
<pre class="example" id="org0158c31">
config BROADCAST_TLB_FLUSH
	def_bool y
	depends on CPU_SUP_AMD &amp;&amp; 64BIT
</pre>
<p>
可以看到在AMD平台上使用。
</p>

<p>
往下的代码：
</p>
<pre class="example" id="org613e4f8">
/*
 * Broadcast TLB invalidation keeps this ASID up to date
 * all the time.
 */
if (is_global_asid(prev_asid))
	return;
</pre>
<p>
也主要针对AMD平台，is_global_asid将大于6的asid都识别为global的，主要依靠amd平台的invlpgb指令。
</p>

<p>
随后的代码也是提前返回，不做实际的tlb reload：
</p>
<pre class="example" id="org65f3d9b">
/*
 * If the CPU is not in lazy TLB mode, we are just switching
 * from one thread in a process to another thread in the same
 * process. No TLB flush required.
 */
if (!was_lazy)
	return;
</pre>
<p>
也就是说，之前并没有在kernel thread里，并且上面的代码是在prev == next满足的情况下，就是说是在同一个进程的多个线程间切换，多个线程共享一个mm_struct空间，自然也不需要reloadtlb（mm_struct没有改变，页表也就没有改变）。
</p>

<p>
再往下分析：
</p>
<pre class="example" id="orgef839a9">
/*
 * Read the tlb_gen to check whether a flush is needed.
 * If the TLB is up to date, just use it.
 * The barrier synchronizes with the tlb_gen increment in
 * the TLB shootdown code.
 */
smp_mb();
next_tlb_gen = atomic64_read(&amp;next-&gt;context.tlb_gen);
if (this_cpu_read(cpu_tlbstate.ctxs[prev_asid].tlb_gen) ==
		next_tlb_gen)
	return;
</pre>
<p>
tlb_gen指示了内存页表是否改变，如果内存页表改变了，那么tlb就不是up to date的了，tlb的本质是缓存了虚拟地址到物理地址的映射，如果内存里的页表改变了，自然TLB需要重新同步，注意这里prev_asid来自loaded_mm_asid：
</p>
<pre class="example" id="org82eb2b4">
u16 prev_asid = this_cpu_read(cpu_tlbstate.loaded_mm_asid);
</pre>
<p>
并且之前某次切换流程里，那时prev作为next，假如是真的进行了tlb flush，也就是ns.need_flush是true，在那时cpu_tlbstate里的tlb_gen会更新成next里的：
</p>
<pre class="example" id="org158745a">
this_cpu_write(cpu_tlbstate.ctxs[ns.asid].tlb_gen, next_tlb_gen);
</pre>
<p>
自那次后到本次进程切换，如果next_tlb_gen有改变，那么上面的判断相等就不会满足，也就是说这期间进程有改变自己的页表，此时再切换到prev（或next，因为整个大的条件在prev == next满足的情况下），就需要刷新tlb，让tlb部件和内存里的页表重新进行同步。那么什么情况下，mm_struct::context::tlb_gen可能会增加呢？其实就是前面有列举出的ipi的路径上就会增加这个计数，flush_tlb_mm_range都会调用inc_mm_tlb_gen：
</p>
<pre class="example" id="org6cab285">
static inline u64 inc_mm_tlb_gen(struct mm_struct *mm)
{
	/*
	 * Bump the generation count.  This also serves as a full barrier
	 * that synchronizes with switch_mm(): callers are required to order
	 * their read of mm_cpumask after their writes to the paging
	 * structures.
	 */
	return atomic64_inc_return(&amp;mm-&gt;context.tlb_gen);
}
</pre>

<p>
那么再往下的代码就比较容易理解了：
</p>
<pre class="example" id="orgc893703">
/*
 * TLB contents went out of date while we were in lazy
 * mode. Fall through to the TLB switching code below.
 */
ns.asid = prev_asid;
ns.need_flush = true;
</pre>
<p>
上面的代码还是在prev == next满足的情况下，但是这时没有提前返回，也就是要进行实质的reload tlb动作，上面的代码跑到，实际是说前面几个判断可以提前跳过reload tlb的条件都没有满足，虽然是在同一个进程的多个线程间切换，但是mm_struct改变了，所以需要设置need_flush为true，进而fall through到后面真正的tlb reload操作。总结起来就是，某个进程的页表虽然改变了，但是可能在当时不会立即刷新tlb，而只是增长一个tlb_gen计数，这样在下次真正要切换到这个进程时再检测到这个情况进行tlb刷新，也是一种惰性策略，可以提高性能，因为在更新了页表时就立即做了tlb刷新，但下次切换进程时，不一定切换到做了页表更新的进程，这样白白浪费了之前做的tlb刷新，注意这种“计数改变”的方法是一种实现惰性的手段。
</p>

<p>
在分析reload_tlb分支前，先分析前面if的else分支，也就是说prev == next没有满足的代码，这时需要切换到另一个不同的进程的mm_struct。
</p>

<p>
cond_mitigation主要是安全方面的措施，和进程切换的流程关系不大，本文跳过。
</p>

<p>
else分支的主要逻辑其实是调用到choose_new_asid，去选择一个在当前cpu上可用的tlb_state::ctxs[]，至于再前一点的调用cpumask_set_cpu前面有提到，是将当前cpu号标记到mm_struct::cpu_bitmap里，以便将来有其它cpu更新页表时，可以通过ipi通知到本CPU去刷新tlb，注意init_mm表示的内核的页表，它是内核页表映射，所有CPU共享，不需要进行TLB shootdown，因为它永远不会动态更改（不会换页表，也不会取消映射）。
</p>

<p>
next_tlb_gen先将要切换到的next进程的tlb_gen读上来，然后以这个参数调用choose_new_asid函数，下面分析这个函数：
</p>
<pre class="example" id="orgeee2c04">
static struct new_asid choose_new_asid(struct mm_struct *next, u64 next_tlb_gen)
{
	struct new_asid ns;
	u16 asid;

	if (!static_cpu_has(X86_FEATURE_PCID)) {
		ns.asid = 0;
		ns.need_flush = 1;
		return ns;
	}

	/*
	 * TLB consistency for global ASIDs is maintained with hardware assisted
	 * remote TLB flushing. Global ASIDs are always up to date.
	 */
	if (cpu_feature_enabled(X86_FEATURE_INVLPGB)) {
		u16 global_asid = mm_global_asid(next);

		if (global_asid) {
			ns.asid = global_asid;
			ns.need_flush = 0;
			return ns;
		}
	}

	if (this_cpu_read(cpu_tlbstate.invalidate_other))
		clear_asid_other();

	for (asid = 0; asid &lt; TLB_NR_DYN_ASIDS; asid++) {
		if (this_cpu_read(cpu_tlbstate.ctxs[asid].ctx_id) !=
		    next-&gt;context.ctx_id)
			continue;

		ns.asid = asid;
		ns.need_flush = (this_cpu_read(cpu_tlbstate.ctxs[asid].tlb_gen) &lt; next_tlb_gen);
		return ns;
	}

	/*
	 * We don't currently own an ASID slot on this CPU.
	 * Allocate a slot.
	 */
	ns.asid = this_cpu_add_return(cpu_tlbstate.next_asid, 1) - 1;
	if (ns.asid &gt;= TLB_NR_DYN_ASIDS) {
		ns.asid = 0;
		this_cpu_write(cpu_tlbstate.next_asid, 1);
	}
	ns.need_flush = true;

	return ns;
}
</pre>
<p>
该函数的逻辑分为几个部分，X86_FEATURE_PCID判定CPU是否支持硬件PCID功能，前面的分析已经提到了pcid，那么到底什么是pcid呢，这在Intel SDM3 Chapter4.10.1有介绍，它其实是CR3寄存器的0:11这十二个比特位的值，当用虚拟地址+物理地址填tlb条目时，也会将这个条目关联上当前的pcid值cr3.[11:0]，而当CPU访问虚拟地址查询物理地址时，也仅会使用当前pcid指明的哪些TLB条目，并且在切换进程（mm_struct）时，不相关的pcid的tlb条目可以继续留在tlb cache上，不至于刷新整个tlb，而影响其它进程缓存的tlb信息，这主要是靠invpcid指令以type 1运行时（Intel SDM3 4.10.4.1），这样可以提高性能。
</p>

<p>
现代CPU一般都支持PCID功能，而随后的invlpgb功能主要在AMD平台上使用，本文不做介绍。
</p>

<p>
下面invalidate_other的逻辑主要是通过clear_asid_other函数将ctx_id设置为0，ctxs::ctx_id一般是用于指明mm_struct，但为0的ctx_id有特别的用途：
</p>
<pre class="example" id="org93071a3">
/*
 * We get here when we do something requiring a TLB invalidation
 * but could not go invalidate all of the contexts.  We do the
 * necessary invalidation by clearing out the 'ctx_id' which
 * forces a TLB flush when the context is loaded.
 */
static void clear_asid_other(void)
{
	u16 asid;

	/*
	 * This is only expected to be set if we have disabled
	 * kernel _PAGE_GLOBAL pages.
	 */
	if (!static_cpu_has(X86_FEATURE_PTI)) {
		WARN_ON_ONCE(1);
		return;
	}

	for (asid = 0; asid &lt; TLB_NR_DYN_ASIDS; asid++) {
		/* Do not need to flush the current asid */
		if (asid == this_cpu_read(cpu_tlbstate.loaded_mm_asid))
			continue;
		/*
		 * Make sure the next time we go to switch to
		 * this asid, we do a flush:
		 */
		this_cpu_write(cpu_tlbstate.ctxs[asid].ctx_id, 0);
	}
	this_cpu_write(cpu_tlbstate.invalidate_other, false);
}
</pre>
<p>
下面的for循环，针对每个cpu的6个tlb_context结构体，看其对应的ctx_id是否和即将切换到要运行的next:context::ctx_id是否相等，如果有相等的，证明之前这个进程在这个cpu上运行过，并且已经分配了一个tlb_context槽，那么本次再在这个cpu上运行到next进程的话，就会复用上次之前用过的asid，当然tlb_gen可能会增加，也就是可能改过next对应的页表，这时就需要刷新tlb了，need_flush为true了。当然如果这个cpu上的所有六个tlb_context::ctx_id都和将要运行的context::ctx_id不一样，代表之前没有运行过，这包括之前提到过的，如果在clear_asid_other里将所有per-cpu里的ctxs::ctx_id设为0的话，这里自然不可能复用，走到choose_new_asid最后的逻辑，自然就是need_flush设置为true，同时后面的逻辑其实是为将要运行的next这个mm_struct在这个cpu上分配一个asid，当这个asid号大于TLB_NR_DYN_ASIDS时，还需要回绕到0，注意next_asid记录的是下次要用的asid号，所以这里先加1到next_asid，表征下次可以用的asid，再减1才是本次可以用的asid号。
</p>

<p>
现在终于到reload_tlb的逻辑了，其实这部分逻辑前面已经有涉及了，比如如果need_flush为true的话，代表需要切换进程mm_struct空间，这时per-cpu上对应asid编号的ctx_id也要更新为现在即将要运行next这个mm_struct里的ctx_id，per-cpu上对应asid编号的tlb_gen也要更新为next进程的next_tlb_gen，而per-cpu的cpu_tlbstate的loaded_mm也要反应为现在的next进程，per-cpu的cpu_tlbstate::loaded_mm_asid要更新为前面新选择的ns.asid，真正写cr3的动作是在load_new_mm_cr3里，该函数会调用build_cr3或者build_cr3_noflush来构建要往cr3里写的值，noflush版本会明确将cr3寄存器的最高位设置为1(通过CR3_NOFLUSH宏)也就是在写cr3时不要刷新tlb，至于CR3本身的值现在回过头来看就很简单了，低12位为asid的值，中间的位是mm_struct对应的顶级页表的地址的指针。
</p>

<p>
继续往下看lru_gen_use_mm，mm_struct::lru_gen::bitmap用于内存回收的代码，在这里切换到某个进程运行时，就会通过lru_gen_use_mm将其只为全1（-1）：
</p>
<pre class="example" id="orge5d58e9">
static inline void lru_gen_use_mm(struct mm_struct *mm)
{
	/*
	 * When the bitmap is set, page reclaim knows this mm_struct has been
	 * used since the last time it cleared the bitmap. So it might be worth
	 * walking the page tables of this mm_struct to clear the accessed bit.
	 */
	WRITE_ONCE(mm-&gt;lru_gen.bitmap, -1);
}
</pre>
<p>
这里既然马上要切换到next运行了，自然需要将其bitmap设置为-1，代表这个mm_struct访问过，那么在vmscan（内存回收）的代码里，就会判断这个bitmap是否设置了，如果设置了，就会clear掉bitmap里的标志为0，并且返回这个mm_struct，代表需要内存回收代码进一步进行处理，这由linux/mm/vmscan.c里的get_next_mm函数体现。关于内存回收后面有文章分析。
</p>

<p>
继续往下如果之前是在内核线程里运行，那么需要将prev-&gt;active_mm保存到rq-&gt;prev_mm。
</p>

<p>
switch_mm_cid在SCHED_MM_CID配置下起效，这个配置主要是用来区分某个进程的mm_struct被多个线程贡献访问时来区分哪个线程的，本文不介绍这个主题。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cauchy(pqy7172@gmail.com)</p>
<p class="date">Created: 2025-07-05 Sat 22:40</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
