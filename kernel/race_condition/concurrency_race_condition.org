#+TITLE: 并发与竟态
#+AUTHOR: Cauchy(pqy7172@gmail.com)
#+OPTIONS: ^:nil
#+EMAIL: pqy7172@gmail.com
#+HTML_HEAD: <link rel="stylesheet" href="../../org-manual.css" type="text/css">

之前的系列文章里，都没有关注过并发，比如系统里同时做多件事该发生什么．并发相关的操作很容易形成bug但却不易排查．

在早期的内核里，比较少有并发的情况产生．那时SMP系统还不被内核支持，唯一可能引起并发情况的就是中断服务．这种情况尽管简单，却没有利用起多处理器的性能．对于现代硬件以及应用的情况，Linux已经进化成可以做到许多事情同时进行．这种改变可以带来更大的性能提升以及灵活性．当然，这也加剧了内核编程的复杂性．设备驱动程序员必须一开始就考虑到并发的因素，并且对内核提供的并发管理功能也要能理解到位．

来看下面这段代码，是有问题的：
#+begin_src c
if (!dptr->data[s_pos]) {
    dptr->data[s_pos] = kmalloc(quantum, GFP_KERNEL);
    if (!dptr->data[s_pos])
        goto out;
}
#+end_src

假设在某个时刻，有两个进程同时独立的尝试写scull设备里相同的偏移处，那么这两个进程会同时到达if的条件测试，如果这个指针是空，每个进程都会分配内存，那么每个进程都会在dptr->data[s_pos]里分配指针．因为两个都在相同的位置，当然只有一个是有效的．

可以想见，第二个赋值的指针会是有效的．如果A先赋值．那么它赋的值就会被B覆盖．

这种情况展示了一个竞态．竞态意味着对于共享数据不受控制的访问．竞态问题会引起意想不到的后果．在这里讨论的竞态问题，会引起内存泄漏．但是竞态还可能会引起系统crash，污染数据或者是其它安全问题．
