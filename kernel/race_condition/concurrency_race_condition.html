<!DOCTYPE html>
<html lang="cn">
<head>
<!-- 2021-10-20 Wed 21:43 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>并发与竟态</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Cauchy(pqy7172@gmail.com)">
<link rel="stylesheet" href="../../org-manual.css" type="text/css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">并发与竟态</h1>
<p>
之前的系列文章里，都没有关注过并发，比如系统里同时做多件事该发生什么．并发相关的操作很容易形成bug但却不易排查．
</p>

<p>
在早期的内核里，比较少有并发的情况产生．那时SMP系统还不被内核支持，唯一可能引起并发情况的就是中断服务．这种情况尽管简单，却没有利用起多处理器的性能．对于现代硬件以及应用的情况，Linux已经进化成可以做到许多事情同时进行．这种改变可以带来更大的性能提升以及灵活性．当然，这也加剧了内核编程的复杂性．设备驱动程序员必须一开始就考虑到并发的因素，并且对内核提供的并发管理功能也要能理解到位．
</p>

<p>
来看下面这段代码，是有问题的：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>dptr-&gt;data[s_pos]) {
    dptr-&gt;data[s_pos] = kmalloc(quantum, GFP_KERNEL);
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>dptr-&gt;data[s_pos])
        <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">out</span>;
}
</pre>
</div>

<p>
假设在某个时刻，有两个进程同时独立的尝试写scull设备里相同的偏移处，那么这两个进程会同时到达if的条件测试，如果这个指针是空，每个进程都会分配内存，那么每个进程都会在dptr-&gt;data[s_pos]里分配指针．因为两个都在相同的位置，当然只有一个是有效的．
</p>

<p>
可以想见，第二个赋值的指针会是有效的．如果A先赋值．那么它赋的值就会被B覆盖．
</p>

<p>
这种情况展示了一个竞态．竞态意味着对于共享数据不受控制的访问．竞态问题会引起意想不到的后果．在这里讨论的竞态问题，会引起内存泄漏．但是竞态还可能会引起系统crash，污染数据或者是其它安全问题．
</p>

<p>
在现代的Linux系统上，并发的来源有很多，这意味着很多机会可以产生竞态．许多用户态程序在运行，它们可能会以各种组合访问内核代码．SMP系统可以在不同的核上同时执行用户程序．内核也是可以抢占的，驱动代码可以在任何时候不再拥有处理器．异步事件的设备中断也可以造成代码的并发执行．而内核还会提供各种各样的延迟执行机制，比如workqueue，tasklets以及timers．而现在的热插拔世界里，当正在使用设备时，设备也可能会消失．
</p>

<p>
竞态主要来自共享资源．当多个线程有必要和共同的数据交互时，就会有竞态问题．所以第一个经验是，尽量避免可能的资源共享．最明显的例子就是应当尽量避免使用全局变量．
</p>

<p>
然而，共享却是十分有必要的．硬件资源本身就是共享的，而软件资源通常也是提供给多个线程．全局变量也不是变量共享的唯一形式，只要代码以指针形式传递到函数，就有可能形成一个共享的情形．
</p>

<p>
硬件或软件被超过一个线程共享时，就有可能，一个线程在观察这个资源时遇到不一致的情况，所以必须有意识的管理起来．
</p>

<p>
另外一个重要的规则是，当内核代码创建了一个共享的对象时，这个对象应当持续存在并且保证功能正确直到没有外部依赖存在．这其实对共享对象提出了两点要求，一是直到共享对象完全准备好能正确工作时才能提供给内核使用，二是对共享对象的引用计数必须追踪起来．
</p>

<p>
信号量和互斥体是内核提供用来同步的两个常用操作．在介绍它们之前，先得引入临界区的概念：在任意给定的时间都只能被一个线程执行的代码．
</p>

<p>
不是所有的关键区都是一样的，所以对于不同的需求，内核提供了不同的操作原语．
</p>

<p>
进程睡眠在内核里是有其特定定义的，当Linux进程到达一个点，此时不能再进一步运行，就可以睡眠，并让渡处理器给其它进程，直到未来条件满足又可以执行．比如在等待I/O完成时，进程可以睡眠，后面会看到，在有些情形下进程是不能睡眠的．而使用某些锁机制却可能引起进程睡眠．
</p>

<p>
信号量是一种常见的锁机制，本质上，信号量就是一个整数连带一些操作的函数，通常叫做P或V．一个希望进入临界区的进程，可以在相关的信号量上调用P操作，如果信号量的值大于0，那么该值递减1，并允许此次访问．如果是0的话，进程就得等待其它进程释放该值，通过调用V操作．该操作会增加信号量的值，并且在必要的时候唤醒等待的进程．
</p>

<p>
当信号量的值被初始化为1时，这样的信号量在给定的时间就只能有一个进程访问了，这就是互斥体．
</p>

<p>
为了使用信号量，内核代码必须包含&lt;asm/semaphore.h&gt;，相关的结构体就叫semaphore. 可以使用sema_init函数来初始化：
</p>

<p>
void sema_init(struct semaphore *sem, int val);
</p>

<p>
其中val就是初始化给sem的初始值．
</p>

<p>
通常，信号量使用在互斥模式下，为了简化这种情况的使用，内核提供了一些辅助函数和宏：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">DECLARE_MUTEX</span>(name);
<span style="color: #93E0E3;">DECLARE_MUTEX_LOCKED</span>(name);
</pre>
</div>

<p>
这时，一个名为name的信号量被初始化为1(DECLARE_MUTEX)或者是初始化为0(DECLARE_MUTEX_LOCKED)．后一种情况，mutex自一个锁住状态开始，在线程能访问前必须显式的解锁．
</p>

<p>
在Linux的世界里，P函数被叫做down操作．down是指该函数或递减信号量的值，并且有可能使得调用者进入睡眠状态，直到信号量可以提供．对于down是有几个版本可以提供的：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">down</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">semaphore</span> *<span style="color: #DFAF8F;">sem</span>);
<span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">down_interruptible</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">semaphore</span> *<span style="color: #DFAF8F;">sem</span>);
<span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">down_trylock</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">semaphore</span> *<span style="color: #DFAF8F;">sem</span>);
</pre>
</div>

<p>
down会递减信号量的值．down_interruptible做类似的事情，但是操作是可以中断的，几乎所有情形下都是使用这个版本的，这个版本允许正在一个信号量上等待的进程被中止等待．使用down_interruptible需要一点额外的小心，如果操作被中断，函数就会返回一个非零的值，这是调用者就并未持有信号量，需要检查它的返回值，并且根据不同的情况做不同的处理．
</p>

<p>
而最后一个down_trylock不会睡眠，如果信号量在调用时不可提供的话，它会立即以一个非0的值返回．
</p>

<p>
一旦线程成功的调用了down，就是说持有了信号量，线程现在就可以访问由信号量保护起来的临界区．当操作完成后，信号量必须被返回．所谓的V操作，就是函数up：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">up</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">semaphore</span> *<span style="color: #DFAF8F;">sem</span>);
</pre>
</div>

<p>
可以看出，任何持有信号量的线程都必须通过调用up释放一次(且仅一次)．如果在持有信号量的时候遭遇了错误，那么在返回给调用者前必须先释放信号量．未释放信号量是一个容易出现的错误，进程可能在毫无关联的地方挂掉，并且这样的问题很难复现．
</p>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cauchy(pqy7172@gmail.com)</p>
<p class="date">Created: 2021-10-20 Wed 21:43</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
