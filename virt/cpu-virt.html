<!DOCTYPE html>
<html lang="cn">
<head>
<!-- 2023-12-10 Sun 12:00 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CPU计算虚拟化：KVM与QEMU</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Cauchy(pqy7172@gmail.com)">
<link rel="stylesheet" href="../org-manual.css" type="text/css">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">CPU计算虚拟化：KVM与QEMU</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb5feb83">1. 虚拟机的创建</a></li>
<li><a href="#orgbe097ea">2. QEMU CPU创建</a></li>
<li><a href="#orgf745996">3. KVM CPU创建</a></li>
<li><a href="#orgf7111b0">4. VCPU的运行</a></li>
<li><a href="#org4b085cf">5. VCPU的调度</a></li>
</ul>
</div>
</div>
<p>
本文主要分析下KVM/QEMU对CPU的虚拟化。KVM/QEMU还完成了许多的功能，比如内存虚拟化，中断虚拟化等，但这些功能不是本文的主题。
</p>

<p>
本文的硬件平台是AMD Ryzen 7 4800U。
</p>

<p>
本文分五个方面来分析CPU的虚拟化，依次展开。
</p>

<div id="outline-container-orgb5feb83" class="outline-2">
<h2 id="orgb5feb83"><span class="section-number-2">1.</span> 虚拟机的创建</h2>
<div class="outline-text-2" id="text-1">
<p>
QEMU在初始化阶段，通过如下调用链到kvm_init函数：
</p>
<pre class="example">
main-&gt;qemu_init-&gt;configure_accelerators-&gt;qemu_opts_foreach-&gt;do_configure_accelerator-&gt;accel_init_machine-&gt;kvm_init
</pre>

<p>
在kvm_init函数中有如下代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">KVMState</span> *<span style="color: #DFAF8F;">s</span>;
s = KVM_STATE(ms-&gt;accelerator);
s-&gt;fd = qemu_open_old(<span style="color: #CC9393;">"/dev/kvm"</span>, O_RDWR);
</pre>
</div>
<p>
可以看到，这里打开了/dev/kvm文件，并且将返回的文件描述符保存在了KVMState的fd成员里。将来通过这个fd可以调用ioctl，内核的kvm模块其功能就是通过/dev/kvm设备文件导出的。关于这点后面再详细分析。现在还需要继续详细分析这几行QEMU代码。
</p>

<p>
首先是类型为KVMState的变量s的来源。代码中出现了KVM_STATE宏，QEMU代码中到处充斥中这种大写的宏，其定义都是类似的方式，针对KVM_STATE来说如下代码定义了它：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">DECLARE_INSTANCE_CHECKER</span>(KVMState, KVM_STATE,
                         TYPE_KVM_ACCEL)
</pre>
</div>
<p>
而DECLARE_INSTANCE_CHECKER定义在include/qom/object.h中。
</p>

<p>
简单介绍下qom，qom是QEMU Object Model的简写，是一种用于构建和管理QEMU设备的对象模型。QOM允许以一种层次化和组合性的方式构建虚拟设备，使得设备的模拟和管理更加灵活和可扩展。
</p>

<p>
QOM为设备提供了一种统一的方式来定义和组织属性、方法和信号。每个设备都是一个QOM实例，具有一组属性（例如，CPU的时钟频率、内存大小等）、方法（例如，设备初始化、读取寄存器等）以及可能的信号（事件通知）。同时也提供了更好的代码复用性。
</p>

<p>
在QEMU源代码中，有许多与QOM相关的代码，包括设备的定义、实例化、属性、方法和信号的设置等。
</p>

<p>
说回DECLARE_INSTANCE_CHECKER，其定义为：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">DECLARE_INSTANCE_CHECKER</span>(<span style="color: #DFAF8F;">InstanceType</span>, <span style="color: #DFAF8F;">OBJ_NAME</span>, <span style="color: #DFAF8F;">TYPENAME</span>)      \
        <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">G_GNUC_UNUSED</span> <span style="color: #DFAF8F;">InstanceType</span> *                      \
        OBJ_NAME(<span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">obj</span>)                                       \
        { <span style="color: #F0DFAF; font-weight: bold;">return</span> OBJECT_CHECK(InstanceType, obj, TYPENAME); }
</pre>
</div>
<p>
可以看到，OBJ_NAME作为传进来的参数，被定义为只有一行return的函数，当然这个函数很短，肯定是要内联的，但这不影响在分析代码时，就把它当作函数看待。继续看OBJECT_CHECK：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">OBJECT_CHECK</span>(<span style="color: #DFAF8F;">type</span>, <span style="color: #DFAF8F;">obj</span>, <span style="color: #DFAF8F;">name</span>)                                   \
        ((<span style="color: #7CB8BB;">type</span> *)object_dynamic_cast_assert(OBJECT(obj), (name),        \
                                            __FILE__, __LINE__, __func__))
</pre>
</div>
<p>
看到这里就明白了，其实就是个强转，将传进来的void *指针转换为指向KVMState类型的指针。ms-&gt;accelerator的类型是AccelState，那么想必KVMState的第一个成员就是AccelState类型的成员了，这样它们才能强转。相当于（ms）拥有一个AccelState类型的指针时，而该AccelState来自KVMState，那么可以直接强转为KVMState类型，就可以引用KVMState里除开AccelState外的其它成员了。这种强转其实就是个继承关系了，在各种软件项目里屡见不鲜，不论它们以何种方式（外衣）出现。
</p>

<p>
那么现在就是分析ms-&gt;accelerator的出处了。在accel_init_machine里有：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">accel_init_machine</span>(<span style="color: #7CB8BB;">AccelState</span> *<span style="color: #DFAF8F;">accel</span>, <span style="color: #7CB8BB;">MachineState</span> *<span style="color: #DFAF8F;">ms</span>)
{
        ms-&gt;accelerator = accel;
}
</pre>
</div>
<p>
还需要再往上看父函数，在do_configure_accelerator中：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">do_configure_accelerator</span>(<span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">opaque</span>, <span style="color: #7CB8BB;">QemuOpts</span> *<span style="color: #DFAF8F;">opts</span>, <span style="color: #7CB8BB;">Error</span> **<span style="color: #DFAF8F;">errp</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">acc</span> = qemu_opt_get(opts, <span style="color: #CC9393;">"accel"</span>);
        <span style="color: #7CB8BB;">AccelClass</span> *<span style="color: #DFAF8F;">ac</span> = accel_find(acc);
        <span style="color: #7CB8BB;">AccelState</span> *<span style="color: #DFAF8F;">accel</span>;
        accel = ACCEL(object_new_with_class(OBJECT_CLASS(ac)));
        ret = accel_init_machine(accel, current_machine);
}
</pre>
</div>
<p>
看到这里就明晰了，qemu_opt_get就是根据传入的参数去找accelerator的字符串名字，比如在启动qemu时传入了-enable-kvm，那么这里的acc就是指向串“kvm”了。而accel_find往下一路调用，最后会来到glib提供的g_hash_table_lookup函数，也就是说，包括accelerator在内的很多对象，都会事先存在hash表里，然后后面要用时通过“kvm”这样的key去找，当然真正的key串可能是组合了一些其它的字符，比如kvm-accel，见accel_find-&gt;ACCEL_CLASS_NAME。
</p>

<p>
顺便提下，current_machine也是先在初始化阶段的qemu_create_machine里创建出来：
</p>
<div class="org-src-container">
<pre class="src src-c">current_machine = MACHINE(object_new_with_class(OBJECT_CLASS(machine_class)));
</pre>
</div>

<p>
这里以kvm accelerator这种type类型的对象注册为例，来分析下一个对象的注册到hash表的流程，有此一例，其它对象的注册类似。在accel/kvm/kvm-all.c中，有如下代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">kvm_accel_type</span> = {
        .name = TYPE_KVM_ACCEL,
        .parent = TYPE_ACCEL,
        .instance_init = kvm_accel_instance_init,
        .class_init = kvm_accel_class_init,
        .instance_size = <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(KVMState),
};
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">kvm_type_init</span>(<span style="color: #7CB8BB;">void</span>)
{
        type_register_static(&amp;kvm_accel_type);
}
</pre>
</div>
<p>
从type_register_static一路往下的话，就会看到g_hash_table_insert，这个就和前面通过
g_hash_table_lookup去寻找加速器对应起来了，只有这里insert，后面才能lookup。现在还有唯一一
个问题，那就是kvm_type_init这个函数何时执行，qemu项目的代码里并没有找到直接调用这个函数的
地方。秘密就在这行代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">type_init</span>(kvm_type_init);
</pre>
</div>
<p>
type_init定义如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">type_init</span>(<span style="color: #DFAF8F;">function</span>) module_init(function, MODULE_INIT_QOM)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">module_init</span>(<span style="color: #DFAF8F;">function</span>, <span style="color: #DFAF8F;">type</span>)                                           \
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #F0DFAF; font-weight: bold;">__attribute__</span>((constructor)) <span style="color: #DFAF8F;">do_qemu_init_</span> ## function(<span style="color: #7CB8BB;">void</span>)    \
{                                                                             \
    register_module_init(function, type);                               \ 
}
</pre>
</div>
<p>
可以看到这里用了constructor修饰，被这个gcc属性修饰的函数，会先于main函数的执行，而register_module_init关键的就下面几行：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">ModuleEntry</span> *<span style="color: #DFAF8F;">e</span>;
e-&gt;init = fn;
<span style="color: #93E0E3;">QTAILQ_INSERT_TAIL</span>(l, e, node);
</pre>
</div>
<p>
可以看到也就是把传进来的kvm_type_init给放到了e-&gt;init里，可以理解为先于main执行的这段代码，主要是个注册作用，而真正调用这个动作还是在main里做的：
</p>
<pre class="example">
main-&gt;qemu_init-&gt;qemu_init_subsystems-&gt;module_call_init-&gt;kvm_type_init
</pre>


<p>
上述流程当然是先于configure_accelerator里通过accel_find去寻找加速器的，也就是main调用的qemu_init函数里，是先调用qemu_init_subsystems而后调用configure_accelerator的。
</p>

<p>
继续看给accel真正分配空间就是在object_new_with_with_class里了：
</p>
<pre class="example">
object_new_with_class-&gt;object_new_with_type-&gt;g_malloc
</pre>


<p>
这里又出现了大写的ACCEL宏，可以想见其作用无非就是强转指针类型了：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">ACCEL</span>(<span style="color: #DFAF8F;">obj</span>)                                      \
        OBJECT_CHECK(AccelState, (obj), TYPE_ACCEL)
</pre>
</div>
<p>
到现在就有了一个KVMState，现在回过头来给出KVMState的一些作用，可以理解为内核实现了KVM模块，那么它在QEMU这样的用户程序里有一个代表就是KVMState，其中的fd成员就保存了打开/dev/kvm时返回的fd。每次运行一个QEMU程序，就会申请一个这个结构体。
</p>

<p>
回到kvm_init函数，再往下有如下重要的代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">do</span>{
        ret = kvm_ioctl(s, KVM_CREATE_VM, type);
 } <span style="color: #F0DFAF; font-weight: bold;">while</span> (ret == -EINTR);
s-&gt;vmfd = ret;
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">kvm_ioctl</span>(<span style="color: #7CB8BB;">KVMState</span> *<span style="color: #DFAF8F;">s</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">type</span>, ...)
{
        ret = ioctl(s-&gt;fd, type, arg);
        <span style="color: #F0DFAF; font-weight: bold;">return</span> ret;
}
</pre>
</div>
<p>
可以看到这里就使用了前面打开/dev/kvm的fd来调用ioctl，这个ioctl支持KVM_CREATE_VM这样的命令，在内核里的实现是kvm_dev_ioctl。并且将返回的ret文件描述符保存到了KVMState的vmfd成员，将来又可以在这个fd上调用它的ioctl，比如创建vcpu，在内核里对应这个vmfd的ioctl函数实现是kvm_vm_ioctl。关于这点后面还会分析。
</p>

<p>
<b>可以总结下，通过调用qemu_open_old函数，由/dev/kvm文件得到的fd，表示了一个KVM模块功能的合集，而通过KVM_CREATE_VM命令在/dev/kvm上的fd调用ioctl得到的vmfd，表示了一台虚拟机。</b>
</p>

<p>
在分析内核侧前，想特别的提下，QEMU作为一个用户程序，不论其代码怎么写，其起始入口函数都是softmmu/main.c:main，从这里入口会运行很多复杂的流程。而分析代码从这个函数起始，也算是扭住了千头万绪的线头。一些流程上先后顺序的确定也会很清晰。
</p>

<p>
现在可以看下内核KVM侧关于虚拟机创建的实现了。首先是初始化阶段/dev/kvm设备文件的注册，只有注册好了这个文件，用户程序才能open它，并在这上面使用ioctl函数。
</p>

<p>
内核的虚拟化实现是作为一个模块而存在，amd的svm，和intel的vmx实现不一样。但是内核抽出了公共部分在virt/kvm下。具体来说，针对/dev/kvm的初始化注册，由kvm_init函数里调用misc_register来实现。而对kvm_init的调用，对于intel来说就是arch/x86/kvm/vmx/vmx.c：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">module_init</span>(vmx_init);
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">__init</span> vmx_init(<span style="color: #7CB8BB;">void</span>)
{
        r = kvm_init(&amp;vmx_x86_ops, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">vcpu_vmx</span>),
                     __alignof__(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">vcpu_vmx</span>), THIS_MODULE);
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">kvm_init</span>(<span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">opaque</span>, <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">vcpu_size</span>, <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">vcpu_align</span>,
             <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">module</span> *<span style="color: #DFAF8F;">module</span>)
{
        r = misc_register(&amp;kvm_dev);
}
</pre>
</div>
<p>
这里的kvm_dev定义为：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file_operations</span> <span style="color: #DFAF8F;">kvm_chardev_ops</span> = {
        .unlocked_ioctl = kvm_dev_ioctl,
        .llseek         = noop_llseek,
        KVM_COMPAT(kvm_dev_ioctl),
};

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">miscdevice</span> <span style="color: #DFAF8F;">kvm_dev</span> = {
        KVM_MINOR,
        <span style="color: #CC9393;">"kvm"</span>,
        &amp;kvm_chardev_ops,
};
</pre>
</div>
<p>
可以看到，/dev/kvm文件关联的fop就是kvm_chardev_ops，对/dev/kvm使用ioctl时，就会来到kvm_dev_ioctl函数。现在主要关心kvm_ioctl以KVM_CREATE_VM调用ioctl时的内核代码，在这个命令下，内核会进入kvm_dev_ioctl_create_vm函数。该函数比较关键的流程如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">r</span>;
<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">kvm</span> *<span style="color: #DFAF8F;">kvm</span>;
kvm = kvm_create_vm(type);
r = get_unused_fd_flags(O_CLOEXEC);
file = anon_inode_getfile(<span style="color: #CC9393;">"kvm-vm"</span>, &amp;kvm_vm_fops, kvm, O_RDWR);
<span style="color: #93E0E3;">fd_install</span>(r, file);
<span style="color: #F0DFAF; font-weight: bold;">return</span> r;
</pre>
</div>
<p>
先是创建一个kvm结构体，一台vm都有一个kvm结构体，而kvm结构体里有内核对VCPU的表示比如kvm_cpu结构体，所有VCPU都在vcpus数组里，也有mm_struct结构体，vm所用的虚拟内存就是用户进程的虚拟地址空间，当然还有其它很多信息。
</p>

<p>
然后通过get_unused_fd_flags得到一个文件描述符r，最后返回的是这个文件描述符。随后调用anon_inode_getfile分配一个匿名的inode，file-&gt;private_data就是kvm，将来通过这个file（或fd）都可以找到kvm结构体。当然，fd和file要关联到当前进程的打开文件描述符表current-&gt;files里，后面通过fdget函数得到fd关联的file。
</p>

<p>
前面已经总结强调过了，get_unused_fd_flags返回的vmfd就是代表了一台虚拟机，Linux一切皆文件，针对这个文件（虚拟机），其操作的函数集就是kvm_vm_fops，这个fops里最关键的就是kvm_vm_ioctl函数了。比如针对一台虚拟机可以创建vcpu，这些事情都是后面小节的主题了。
</p>

<p>
总之到目前，总算是有了一台虚拟机，对比真实硬件机器来说，可以理解为主板以及上面的插槽这些都做好了，就等后面插上CPU（创建VCPU），插上需要的外设等。
</p>
</div>
</div>
<div id="outline-container-orgbe097ea" class="outline-2">
<h2 id="orgbe097ea"><span class="section-number-2">2.</span> QEMU CPU创建</h2>
<div class="outline-text-2" id="text-2">
<p>
QEMU里虚拟CPU的创建主要是通过kvm_start_vcpu_thread，新起一个线程去创建的，并且这个线程就代表了VCPU去运行。以下是kvm_start_vcpu_thread被如下调用链调用：
</p>
<pre class="example">
main-&gt;qemu_init-&gt;qmp_x_exit_preconfig-&gt;qemu_init_board-&gt;machine_run_board_init-&gt;pc_init1-&gt;x86_cpus_init-&gt;x86_cpu_new-&gt;qdev_realize-&gt;object_property_set_bool-&gt;object_property_set_qobject-&gt;object_property_set-&gt;
property_set_bool-&gt;device_set_realized-&gt;x86_cpu_realizefn-&gt;qemu_init_vcpu-&gt;kvm_start_vcpu_thread
</pre>

<p>
以上其实就是主板的初始化流程，就这个调用链而言，最后的函数才关心的是CPU具现化。以下分析这个调用链本身是怎么被调用起来的，分析这点更多的是涉及到QOM，也就是QEMU代码的组织，而关于在QEMU代码里VCPU创建本身在本节偏后部分会介绍到。
</p>

<p>
首先看machine_run_board_init是如何调用起pc_init1的，在machine_run_board_init函数里：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">machine_run_board_init</span>(<span style="color: #7CB8BB;">MachineState</span> *<span style="color: #DFAF8F;">machine</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">mem_path</span>, <span style="color: #7CB8BB;">Error</span> **<span style="color: #DFAF8F;">errp</span>)
{
        <span style="color: #7CB8BB;">MachineClass</span> *<span style="color: #DFAF8F;">machine_class</span> = MACHINE_GET_CLASS(machine);
        machine_class-&gt;init(machine);
}
</pre>
</div>
<p>
这里init函数在我的硬件平台就是pc_init1。这个回调是怎么设置的呢？
</p>

<p>
QEMU里x86平台的虚拟主板分为两类，一是i440fx，二是q35。i440fx是一个用于模拟Intel 440fx芯片组的虚拟平台。Intel i440fx芯片组是20世纪90年代早期的一个常见的PC主板芯片组，用于支持Intel的Pentium和Pentium Pro处理器。在虚拟化环境中，i440fx主板模拟了这个旧型号的主板，以便运行旧的操作系统或应用程序，或者为测试和开发目的。而q35模拟了更现代的主板和硬件特性，以便更好地支持现代操作系统和应用程序。
</p>

<p>
不论是i440fx还是q35，都是通过DEFINE_PC_MACHINE宏来注册一个具体的pc machine实例。而DEFINE_PC_MACHINE里就会设置好init函数，init本身是pc_init_##suffix，但这个函数里面会调用pc_init1。对于i440fx来说，就是DEFINE_I440FX_MACHINE里调用DEFINE_PC_MACHINE。
</p>

<p>
继续往后看object_property_set函数，在object_property_set里有个set回调，它主要是看一个对象（这里是CPU）是否具有realized属性，
若有的话， <b>那么object_property_set里怎么就能按如下方式调用set函数呢？</b>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">bool</span> <span style="color: #93E0E3;">object_property_set</span>(<span style="color: #7CB8BB;">Object</span> *<span style="color: #DFAF8F;">obj</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">name</span>, <span style="color: #7CB8BB;">Visitor</span> *<span style="color: #DFAF8F;">v</span>,
                         <span style="color: #7CB8BB;">Error</span> **<span style="color: #DFAF8F;">errp</span>)
{
        <span style="color: #7CB8BB;">ObjectProperty</span> *<span style="color: #DFAF8F;">prop</span> = object_property_find_err(obj, name, errp);
        prop-&gt;set(obj, v, name, prop-&gt;opaque, errp);
}
</pre>
</div>
<p>
这里set函数其实就是property_set_bool。
先列一个调用链：
</p>
<pre class="example">
main-&gt;qemu_init-&gt;qemu_create_machine-&gt;select_machine-&gt;object_class_get_list-&gt;object_class_foreach-&gt;g_hash_table_foreach-&gt;object_class_foreach_tramp-&gt;type_initialize(递归三次)-&gt;device_class_init-&gt;object_class_property_add_bool
</pre>

<p>
这里先分析下这个调用链是在干什么，再分析最后的object_class_property_add_bool。简要的说，这个调用链是要对加入type_table哈希表中的所有类型进行初始化，具体的说，包括设置（ <b>不是调用</b>
）具现化的回调函数，比如device_set_realized，后面真正具现化的时候再调用这样的回调函数。
</p>

<p>
到这里可以总结下QEMU代码的流程了，主要是以下几个阶段：
</p>
<ol class="org-ol">
<li>注册。</li>
<li>初始化。</li>
<li>具现化。</li>
<li>运行时。</li>
</ol>
<p>
记住这几个阶段，以后在处理QEMU+KVM的具体问题或者继续深挖代码时，能时刻清晰自己处于哪个阶段，而不只是具体问题的“指哪打哪”很局部，还多了一点全局观念或角度。
</p>

<p>
上面object_class_property_add_bool的调用链包括后面分析的object_class_property_add_bool都是归结于初始化阶段。而本节一开始分析CPU的创建过程其实是具体设备的具现化阶段了。下面再介绍一下注册阶段。以设备类的TypeInfo，device_type_info量为例来分析这个注册过程。其实关于这个type init的过程上节对kvm_accel_type注册的分析已经涉及过了，已经不是新鲜玩意了，首先有：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">type_init</span>(qdev_register_types)
</pre>
</div>
<p>
这个type_init怎么运行起来上节已经介绍了，这里只是从qdev_register_types一路往下，看看type_table_add函数：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">type_table_add</span>(<span style="color: #7CB8BB;">TypeImpl</span> *<span style="color: #DFAF8F;">ti</span>)
{
        g_hash_table_insert(type_table_get(), (<span style="color: #7CB8BB;">void</span> *)ti-&gt;name, ti);
}
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">GHashTable</span> *<span style="color: #93E0E3;">type_table_get</span>(<span style="color: #7CB8BB;">void</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">GHashTable</span> *<span style="color: #DFAF8F;">type_table</span>;
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (type_table == <span style="color: #BFEBBF;">NULL</span>) {
                type_table = g_hash_table_new(g_str_hash, g_str_equal);
        }
        <span style="color: #F0DFAF; font-weight: bold;">return</span> type_table;
}
</pre>
</div>
<p>
这里可以看到这个类型表的落脚点，名字就叫：type_table，是个static类型的，初始化一次为NULL，第一次运行创建这样一个表，在函数退出时依旧有效。并且可以将各种类型加入到这个表中。这样注册完成后，就可以在初始化阶段时，调用各个TypeInfo的class_init函数了，就是在type_initialize（可能递归多次）里调用class_init函数。
</p>

<p>
以上其实又涉及到了QOM的概念， 在上节已经首次提出了QOM的一方面。这里针对本节的角度再次总结QOM的另一方面。 <b>QOM：Qemu Object Model。所谓model，就是有一定的套路或范式，不论来多少类型、设备，都按这个注册、初始化最后具现的流程来编码，具体点就是到处设置回调函数。</b>
</p>

<p>
后面还会遇到QOM的体现，本文会更多的以具体代码里去阐述QOM的概念，不然只是上节的QOM概念会空洞。
</p>

<p>
现在开始分析object_class_property_add_bool，以解答前面的问题“object_property_set里怎么就能按如下方式调用set函数呢”。在这个函数中有：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">ObjectProperty</span> *
<span style="color: #93E0E3;">object_class_property_add_bool</span>(<span style="color: #7CB8BB;">ObjectClass</span> *<span style="color: #DFAF8F;">klass</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">name</span>,
                               <span style="color: #7CB8BB;">bool</span> (*<span style="color: #93E0E3;">get</span>)(<span style="color: #7CB8BB;">Object</span> *, <span style="color: #7CB8BB;">Error</span> **),
                               <span style="color: #7CB8BB;">void</span> (*<span style="color: #93E0E3;">set</span>)(<span style="color: #7CB8BB;">Object</span> *, <span style="color: #7CB8BB;">bool</span>, <span style="color: #7CB8BB;">Error</span> **))
{
        <span style="color: #7CB8BB;">BoolProperty</span> *<span style="color: #DFAF8F;">prop</span> = g_malloc0(<span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(*prop));
        prop-&gt;get = get;
        prop-&gt;set = set;
        <span style="color: #F0DFAF; font-weight: bold;">return</span> object_class_property_add(klass, name, <span style="color: #CC9393;">"bool"</span>,
                                         get ? property_get_bool : <span style="color: #BFEBBF;">NULL</span>,
                                         set ? property_set_bool : <span style="color: #BFEBBF;">NULL</span>,
                                         <span style="color: #BFEBBF;">NULL</span>,
                                         prop);
}
</pre>
</div>
<p>
上面的set函数其实就是device_set_realized，这在object_class_property_add_bool的父函数device_class_init里可以看到，这里要注意，object_class_property_add_bool自己也构造了一个BoolProperty类型的prop属性，这个BoolProperty的set函数是device_set_realized，并将它作为最后一个参数传递给了object_class_property_add，这个函数在下面马上会分析，它也构造了一个prop，不过是ObjectProperty类型的。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">ObjectProperty</span> *
<span style="color: #93E0E3;">object_class_property_add</span>(<span style="color: #7CB8BB;">ObjectClass</span> *<span style="color: #DFAF8F;">klass</span>,
                          <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">name</span>,
                          <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">type</span>,
                          <span style="color: #7CB8BB;">ObjectPropertyAccessor</span> *<span style="color: #DFAF8F;">get</span>,
                          <span style="color: #7CB8BB;">ObjectPropertyAccessor</span> *<span style="color: #DFAF8F;">set</span>,
                          <span style="color: #7CB8BB;">ObjectPropertyRelease</span> *<span style="color: #DFAF8F;">release</span>,
                          <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">opaque</span>)
{
        <span style="color: #7CB8BB;">ObjectProperty</span> *<span style="color: #DFAF8F;">prop</span>;
        prop = g_malloc0(<span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(*prop));
        prop-&gt;set = set;
        prop-&gt;opaque = opaque;
        g_hash_table_insert(klass-&gt;properties, prop-&gt;name, prop);
        <span style="color: #F0DFAF; font-weight: bold;">return</span> prop;
}
</pre>
</div>
<p>
可以看到这里调用了g_hash_table_insert函数将一个prop加入到了properties哈希表中，其key就是传进来的name字符串，为realized。这样在前面的object_property_set函数中就可以通过object_property_find_err函数，以name参数为realized找到其对应的prop，进而调用这个prop对应的set函数：property_set_bool。同时还有很重要的一点，opaque被保存在了prop-&gt;opaue成员里，这样在早先分析过的object_property_set函数里，在先找到了ObjectProperty类型的prop后，才能从这个prop里取出opaque，而opaque又作为一个BoolProperty类型的参数传递给object_property_set里调用的set函数（也就是property_set_bool），这样在这个set函数里又才调用BoolProperty的set回调为device_set_realized，进而去执行具现化的流程。
</p>

<p>
分析完device_set_realized，往下打算分析下x86_cpu_realizefn函数的调用。device_set_realized里对x86_cpu_realizefn调用是这样的：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">device_set_realized</span>(<span style="color: #7CB8BB;">Object</span> *<span style="color: #DFAF8F;">obj</span>, <span style="color: #7CB8BB;">bool</span> <span style="color: #DFAF8F;">value</span>, <span style="color: #7CB8BB;">Error</span> **<span style="color: #DFAF8F;">errp</span>)
{
        <span style="color: #7CB8BB;">DeviceState</span> *<span style="color: #DFAF8F;">dev</span> = DEVICE(obj);
        <span style="color: #7CB8BB;">DeviceClass</span> *<span style="color: #DFAF8F;">dc</span> = DEVICE_GET_CLASS(dev);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (dc-&gt;realize) {
                dc-&gt;realize(dev, &amp;local_err);
        }
}
</pre>
</div>

<p>
这里出现了大写的DEVICE，这点在前面提到过，也是QOM的一个方面。但是具体的DEVICE的实现，前面没有提到，这里简要分析下。
</p>

<p>
DEVICE的最开始定义在include/hw/qdev-core.h里有：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">OBJECT_DECLARE_TYPE</span>(DeviceState, DeviceClass, DEVICE)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">OBJECT_DECLARE_TYPE</span>(<span style="color: #DFAF8F;">InstanceType</span>, <span style="color: #DFAF8F;">ClassType</span>, <span style="color: #DFAF8F;">MODULE_OBJ_NAME</span>) \
        <span style="color: #F0DFAF; font-weight: bold;">typedef</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">InstanceType</span> <span style="color: #7CB8BB;">InstanceType</span>; \
        <span style="color: #F0DFAF; font-weight: bold;">typedef</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">ClassType</span> <span style="color: #7CB8BB;">ClassType</span>; \
        \
        G_DEFINE_AUTOPTR_CLEANUP_FUNC(InstanceType, object_unref) \
        \
        DECLARE_OBJ_CHECKERS(InstanceType, ClassType, \
                             MODULE_OBJ_NAME, TYPE_##MODULE_OBJ_NAME)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">DECLARE_OBJ_CHECKERS</span>(<span style="color: #DFAF8F;">InstanceType</span>, <span style="color: #DFAF8F;">ClassType</span>, <span style="color: #DFAF8F;">OBJ_NAME</span>, <span style="color: #DFAF8F;">TYPENAME</span>) \
        DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME)      \
        \
        DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME)
</pre>
</div>
<p>
可以看到上节介绍过的DECLARE_INSTANCE_CHECKER，里面会有DEVICE的定义，就不再进一步贴代码了。这里主要关心下DECLARE_CLASS_CHECKERS，这个前面没有介绍过。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">define</span> <span style="color: #93E0E3;">DECLARE_CLASS_CHECKERS</span>(ClassType, OBJ_NAME, TYPENAME) \
     <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">G_GNUC_UNUSED</span> <span style="color: #DFAF8F;">ClassType</span> * \
     OBJ_NAME##_GET_CLASS(<span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">obj</span>) \
{ <span style="color: #F0DFAF; font-weight: bold;">return</span> OBJECT_GET_CLASS(ClassType, obj, TYPENAME); } \
\
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">G_GNUC_UNUSED</span> <span style="color: #DFAF8F;">ClassType</span> * \
OBJ_NAME##_CLASS(<span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">klass</span>) \
{ <span style="color: #F0DFAF; font-weight: bold;">return</span> OBJECT_CLASS_CHECK(ClassType, klass, TYPENAME); }
</pre>
</div>
<p>
可以看到，OBJ_NAME被替换为OBJECT_DECLARE_TYPE宏的第三个参数为DEVICE，这样就有了device_set_realized函数里可以用DEVICE_GET_CLASS了。再往下跟OBJECT_GET_CLASS-&gt;object_get_class的话会知道，最后实际获取的就是obj-&gt;class，这里就不再贴代码了。
</p>

<p>
回到device_set_realized函数，里面最主要的就是通过dc调用了realize函数（就是x86_cpu_realizefn）了。这又是一个回调，那么这个回调在哪里设置的呢，分析这个问题，又要引出QOM的另一方面了： <b>object的继承</b> 。下面分析这个问题。
</p>

<p>
先看几个结构体：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">x86_cpu_type_info</span> = {
        name = TYPE_X86_CPU,
        .parent = TYPE_CPU,
        .class_init = x86_cpu_common_class_init,
};
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">cpu_type_info</span> = {
        .name = TYPE_CPU,
        .parent = TYPE_DEVICE,
        .class_init = cpu_class_init,
};
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">device_type_info</span> = {
        .name = TYPE_DEVICE,
        .parent = TYPE_OBJECT,
        .class_init = device_class_init,
};
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">object_info</span> = {
        .name = TYPE_OBJECT,
        .class_init = object_class_init,
};
</pre>
</div>
<p>
观察以上TypeInfo定义，可以很清楚的看到，它们构成了父子继承关系，这就是QOM对各种虚拟计算机对象的一种抽象，在类型的初始化阶段时，会递归调用type_initialize函数，就是如果一个TypeInfo如果有parent，会先对parent这个TypeImpl调用type_initialize，然后到递归的最底层时，会调用class_init（如果有的话）：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">type_initialize</span>(<span style="color: #7CB8BB;">TypeImpl</span> *<span style="color: #DFAF8F;">ti</span>)
{
        parent = type_get_parent(ti);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (parent) {
                type_initialize(parent);
        }
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (ti-&gt;class_init) {
                ti-&gt;class_init(ti-&gt;class, ti-&gt;class_data);
        }
}
</pre>
</div>
<p>
而对于x86_cpu_type_info的class_init来说（x86_cpu_common_class_init），就会调用device_class_set_parent_realize来设置realize回调函数：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">x86_cpu_common_class_init</span>(<span style="color: #7CB8BB;">ObjectClass</span> *<span style="color: #DFAF8F;">oc</span>, <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">data</span>)
{
        <span style="color: #7CB8BB;">X86CPUClass</span> *<span style="color: #DFAF8F;">xcc</span> = X86_CPU_CLASS(oc);
        <span style="color: #7CB8BB;">DeviceClass</span> *<span style="color: #DFAF8F;">dc</span> = DEVICE_CLASS(oc);
        device_class_set_parent_realize(dc, x86_cpu_realizefn,
                                        &amp;xcc-&gt;parent_realize);
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">device_class_set_parent_realize</span>(<span style="color: #7CB8BB;">DeviceClass</span> *<span style="color: #DFAF8F;">dc</span>,
                                     <span style="color: #7CB8BB;">DeviceRealize</span> <span style="color: #DFAF8F;">dev_realize</span>,
                                     <span style="color: #7CB8BB;">DeviceRealize</span> *<span style="color: #DFAF8F;">parent_realize</span>)
{
        *parent_realize = dc-&gt;realize;
        dc-&gt;realize = dev_realize;
}
</pre>
</div>
<p>
这样设置好以后，在device_set_realized中就可以以dc-&gt;realize这样的方式调用了。至于上面具有继承关系的各个TypeInfo，它们是如何注册的，这点不再赘述，前面已经有多个例子分析到。
</p>

<p>
再往后看调用链，来到qemu_init_vcpu，里面有：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">qemu_init_vcpu</span>(<span style="color: #7CB8BB;">CPUState</span> *<span style="color: #DFAF8F;">cpu</span>)
{
        cpus_accel-&gt;create_vcpu_thread(cpu);
}
</pre>
</div>
<p>
create_vcpu_thread（就是kvm_start_vcpu_thread）是一开始kvm_start_vcpu_thread调用链里的最后一个回调了，对于它笔者不打算详细分析了，因为到这里对于QOM的套路已经驾轻就熟了，这里只是简单列下代码并简单解释下，以验证或加深理解。以后的QEMU+KVM关于QOM的主题分析也不会这么详细了，在那些文档里，涉及到QOM的分析，都会请移步至此。
</p>

<p>
关于如何调用起create_vcpu_thread，如下一些代码所示：
</p>
<div class="org-src-container">
<pre class="src src-c">main-&gt;qemu_init-&gt;qmp_x_exit_preconfig-&gt;qemu_init_board-&gt;machine_run_board_init-&gt;accel_init_interfaces-&gt;accel_init_ops_interfaces-&gt;cpus_register_accel

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> AccelOpsClass *cpus_accel;

<span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">cpus_register_accel</span>(<span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">AccelOpsClass</span> *<span style="color: #DFAF8F;">ops</span>)
{
        cpus_accel = ops;
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">accel_init_ops_interfaces</span>(<span style="color: #7CB8BB;">AccelClass</span> *<span style="color: #DFAF8F;">ac</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">ac_name</span>;
        <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">ops_name</span>;
        <span style="color: #7CB8BB;">ObjectClass</span> *<span style="color: #DFAF8F;">oc</span>;
        <span style="color: #7CB8BB;">AccelOpsClass</span> *<span style="color: #DFAF8F;">ops</span>;
        ac_name = object_class_get_name(OBJECT_CLASS(ac));
        ops_name = g_strdup_printf(<span style="color: #CC9393;">"%s"</span> ACCEL_OPS_SUFFIX, ac_name);
        oc = module_object_class_by_name(ops_name);
        ops = ACCEL_OPS_CLASS(oc);
        cpus_register_accel(ops);
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">machine_run_board_init</span>(<span style="color: #7CB8BB;">MachineState</span> *<span style="color: #DFAF8F;">machine</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">mem_path</span>, <span style="color: #7CB8BB;">Error</span> **<span style="color: #DFAF8F;">errp</span>)
{
        accel_init_interfaces(ACCEL_GET_CLASS(machine-&gt;accelerator));
}
</pre>
</div>
<p>
可以看到，在machine有了accelerator之后，就可以从里面取出ops交给全局静态变量cpus_accel了。
</p>

<p>
但这些还不涉及到把create_vcpu_thread设置为kvm_start_vcpu_thread。可以想见这是在object_class_foreach_tramp-&gt;type_initialize里调用class_init完成的：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">DECLARE_CLASS_CHECKERS</span>(AccelOpsClass, ACCEL_OPS, TYPE_ACCEL_OPS)
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">kvm_accel_ops_class_init</span>(<span style="color: #7CB8BB;">ObjectClass</span> *<span style="color: #DFAF8F;">oc</span>, <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">data</span>)
{
        <span style="color: #7CB8BB;">AccelOpsClass</span> *<span style="color: #DFAF8F;">ops</span> = ACCEL_OPS_CLASS(oc);
        ops-&gt;create_vcpu_thread = kvm_start_vcpu_thread;
}
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">kvm_accel_ops_type</span> = {
        .name = ACCEL_OPS_NAME(<span style="color: #CC9393;">"kvm"</span>),
        .parent = TYPE_ACCEL_OPS,
        .class_init = kvm_accel_ops_class_init,
        .abstract = <span style="color: #BFEBBF;">true</span>,
};
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">kvm_accel_ops_register_types</span>(<span style="color: #7CB8BB;">void</span>)
{
        type_register_static(&amp;kvm_accel_ops_type);
}
<span style="color: #93E0E3;">type_init</span>(kvm_accel_ops_register_types);
</pre>
</div>
<p>
看到type_init一切就明晰了。
</p>

<p>
到目前为止，本文花了很多篇幅去阐述QOM，还较少涉及虚拟化本身，笔者认为这是必要的，从某种角度来说，QOM就代表了QEMU代码的组织，并且弄清楚这种组织或调用关系有可能比虚拟化本身更费劲。但对QOM的清晰，会有助于对QEMU代码的全局把握。当然虚拟化本身后面肯定还会深入的。
</p>

<p>
以上着重对QOM进行了介绍， <b>从现在开始，会更多的偏向于虚拟化本身了</b> ，在本节也就是QEMU里对于CPU的创建到底做了哪些事情。
</p>

<p>
在本节一开始，列出了创建VCPU的函数流程，只是到目前都只关注了这个调用流程是怎么调用起来的（在哪里设置回调，在哪里调用回调）．下面再贴下这个函数流程，后续就是主要关注这些流程上函数的逻辑了：
</p>
<pre class="example">
main-&gt;qemu_init-&gt;qmp_x_exit_preconfig-&gt;qemu_init_board-&gt;machine_run_board_init-&gt;pc_init1-&gt;x86_cpus_init-&gt;x86_cpu_new-&gt;qdev_realize-&gt;object_property_set_bool-&gt;object_property_set_qobject-&gt;object_property_set-&gt;
property_set_bool-&gt;device_set_realized-&gt;x86_cpu_realizefn-&gt;qemu_init_vcpu-&gt;kvm_start_vcpu_thread
</pre>


<p>
从machine_run_board_init调用pc_init1说起。QEMU中，主板模型有两种，一是i440fx，另外一个是q35，本文主要基于前者研究。不论是i440fx还是q35，都要通过DEFINE_PC_MACHINE去定义MachineClass的init函数：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">DEFINE_I440FX_MACHINE</span>(<span style="color: #DFAF8F;">suffix</span>, <span style="color: #DFAF8F;">name</span>, <span style="color: #DFAF8F;">compatfn</span>, <span style="color: #DFAF8F;">optionfn</span>) \
    <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #DFAF8F;">pc_init_</span>##suffix(<span style="color: #7CB8BB;">MachineState</span> *<span style="color: #DFAF8F;">machine</span>) \
    { \
        <span style="color: #7CB8BB;">void</span> (*<span style="color: #93E0E3;">compat</span>)(<span style="color: #7CB8BB;">MachineState</span> *<span style="color: #DFAF8F;">m</span>) = (compatfn); \
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (compat) { \
            compat(machine); \
        } \
        pc_init1(machine, TYPE_I440FX_PCI_HOST_BRIDGE, \
                 TYPE_I440FX_PCI_DEVICE); \
    } \
    DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">DEFINE_PC_MACHINE</span>(<span style="color: #DFAF8F;">suffix</span>, <span style="color: #DFAF8F;">namestr</span>, <span style="color: #DFAF8F;">initfn</span>, <span style="color: #DFAF8F;">optsfn</span>) \
    <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #DFAF8F;">pc_machine_</span>##suffix##_class_init(<span style="color: #7CB8BB;">ObjectClass</span> *<span style="color: #DFAF8F;">oc</span>, <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">data</span>) \
    { \
        <span style="color: #7CB8BB;">MachineClass</span> *<span style="color: #DFAF8F;">mc</span> = MACHINE_CLASS(oc); \
        optsfn(mc); \
        mc-&gt;init = initfn; \
        mc-&gt;kvm_type = pc_machine_kvm_type; \
    } \
    <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">pc_machine_type_</span>##suffix = { \
        .name       = namestr TYPE_MACHINE_SUFFIX, \
        .parent     = TYPE_PC_MACHINE, \
        .class_init = pc_machine_##suffix##_class_init, \
    }; \
    <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #DFAF8F;">pc_machine_init_</span>##suffix(<span style="color: #7CB8BB;">void</span>) \
    { \
        type_register(&amp;pc_machine_type_##suffix); \
    } \
    type_init(pc_machine_init_##suffix)
</pre>
</div>
<p>
对于q35的话就是宏DEFINE_Q35_MACHINE。这里suffix其实就是i440fx主板的版本，比如v8_2、v8_1等。可以看到initfn其实主要就是调用了pc_init1，而initfn又是作为MachineClass的init回调，所以在machine_run_board_init的最后可以这样调用：
</p>
<div class="org-src-container">
<pre class="src src-c">machine_class-&gt;init(machine);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf745996" class="outline-2">
<h2 id="orgf745996"><span class="section-number-2">3.</span> KVM CPU创建</h2>
</div>

<div id="outline-container-orgf7111b0" class="outline-2">
<h2 id="orgf7111b0"><span class="section-number-2">4.</span> VCPU的运行</h2>
</div>

<div id="outline-container-org4b085cf" class="outline-2">
<h2 id="org4b085cf"><span class="section-number-2">5.</span> VCPU的调度</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cauchy(pqy7172@gmail.com)</p>
<p class="date">Created: 2023-12-10 Sun 12:00</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
