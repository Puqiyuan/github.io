<!DOCTYPE html>
<html lang="cn">
<head>
<!-- 2024-01-04 Thu 23:30 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CPU计算虚拟化：KVM与QEMU</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Cauchy(pqy7172@gmail.com)">
<link rel="stylesheet" href="../org-manual.css" type="text/css">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">CPU计算虚拟化：KVM与QEMU</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgaf3cf8e">1. 虚拟机的创建</a></li>
<li><a href="#org8d73ffe">2. QEMU CPU创建</a></li>
<li><a href="#orgd711611">3. KVM CPU创建</a></li>
<li><a href="#org7fd4616">4. VCPU的运行</a></li>
<li><a href="#org2a8ddad">5. VCPU的调度</a></li>
</ul>
</div>
</div>
<p>
本文主要分析下KVM/QEMU对CPU的虚拟化。KVM/QEMU还完成了许多的功能，比如内存虚拟化，中断虚拟化等，但这些功能不是本文的主题。
</p>

<p>
本文分五个方面来分析CPU的虚拟化，依次展开。
</p>

<div id="outline-container-orgaf3cf8e" class="outline-2">
<h2 id="orgaf3cf8e"><span class="section-number-2">1.</span> 虚拟机的创建</h2>
<div class="outline-text-2" id="text-1">
<p>
QEMU在初始化阶段，通过如下调用链到kvm_init函数：
</p>
<pre class="example">
main-&gt;qemu_init-&gt;configure_accelerators-&gt;qemu_opts_foreach-&gt;do_configure_accelerator-&gt;accel_init_machine-&gt;kvm_init
</pre>

<p>
在kvm_init函数中有如下代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">KVMState</span> *<span style="color: #DFAF8F;">s</span>;
s = KVM_STATE(ms-&gt;accelerator);
s-&gt;fd = qemu_open_old(<span style="color: #CC9393;">"/dev/kvm"</span>, O_RDWR);
</pre>
</div>
<p>
可以看到，这里打开了/dev/kvm文件，并且将返回的文件描述符保存在了KVMState的fd成员里。将来通过这个fd可以调用ioctl，内核的kvm模块其功能就是通过/dev/kvm设备文件导出的。关于这点后面再详细分析。现在还需要继续详细分析这几行QEMU代码。
</p>

<p>
首先是类型为KVMState的变量s的来源。代码中出现了KVM_STATE宏，QEMU代码中到处充斥中这种大写的宏，其定义都是类似的方式，针对KVM_STATE来说如下代码定义了它：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">DECLARE_INSTANCE_CHECKER</span>(KVMState, KVM_STATE,
                         TYPE_KVM_ACCEL)
</pre>
</div>
<p>
而DECLARE_INSTANCE_CHECKER定义在include/qom/object.h中。
</p>

<p>
简单介绍下qom，qom是QEMU Object Model的简写，是一种用于构建和管理QEMU设备的对象模型。QOM允许以一种层次化和组合性的方式构建虚拟设备，使得设备的模拟和管理更加灵活和可扩展。
</p>

<p>
QOM为设备提供了一种统一的方式来定义和组织属性、方法和信号。每个设备都是一个QOM实例，具有一组属性（例如，CPU的时钟频率、内存大小等）、方法（例如，设备初始化、读取寄存器等）以及可能的信号（事件通知）。同时也提供了更好的代码复用性。
</p>

<p>
在QEMU源代码中，有许多与QOM相关的代码，包括设备的定义、实例化、属性、方法和信号的设置等。
</p>

<p>
说回DECLARE_INSTANCE_CHECKER，其定义为：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">DECLARE_INSTANCE_CHECKER</span>(<span style="color: #DFAF8F;">InstanceType</span>, <span style="color: #DFAF8F;">OBJ_NAME</span>, <span style="color: #DFAF8F;">TYPENAME</span>)      \
        <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">G_GNUC_UNUSED</span> <span style="color: #DFAF8F;">InstanceType</span> *                      \
        OBJ_NAME(<span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">obj</span>)                                       \
        { <span style="color: #F0DFAF; font-weight: bold;">return</span> OBJECT_CHECK(InstanceType, obj, TYPENAME); }
</pre>
</div>
<p>
可以看到，OBJ_NAME作为传进来的参数，被定义为只有一行return的函数，当然这个函数很短，肯定是要内联的，但这不影响在分析代码时，就把它当作函数看待。继续看OBJECT_CHECK：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">OBJECT_CHECK</span>(<span style="color: #DFAF8F;">type</span>, <span style="color: #DFAF8F;">obj</span>, <span style="color: #DFAF8F;">name</span>)                                   \
        ((<span style="color: #7CB8BB;">type</span> *)object_dynamic_cast_assert(OBJECT(obj), (name),        \
                                            __FILE__, __LINE__, __func__))
</pre>
</div>
<p>
看到这里就明白了，其实就是个强转，将传进来的void *指针转换为指向KVMState类型的指针。ms-&gt;accelerator的类型是AccelState，那么想必KVMState的第一个成员就是AccelState类型的成员了，这样它们才能强转。相当于（ms）拥有一个AccelState类型的指针时，而该AccelState来自KVMState，那么可以直接强转为KVMState类型，就可以引用KVMState里除开AccelState外的其它成员了。这种强转其实就是个继承关系了，在各种软件项目里屡见不鲜，不论它们以何种方式（外衣）出现。
</p>

<p>
那么现在就是分析ms-&gt;accelerator的出处了。在accel_init_machine里有：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">accel_init_machine</span>(<span style="color: #7CB8BB;">AccelState</span> *<span style="color: #DFAF8F;">accel</span>, <span style="color: #7CB8BB;">MachineState</span> *<span style="color: #DFAF8F;">ms</span>)
{
        ms-&gt;accelerator = accel;
}
</pre>
</div>
<p>
还需要再往上看父函数，在do_configure_accelerator中：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">do_configure_accelerator</span>(<span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">opaque</span>, <span style="color: #7CB8BB;">QemuOpts</span> *<span style="color: #DFAF8F;">opts</span>, <span style="color: #7CB8BB;">Error</span> **<span style="color: #DFAF8F;">errp</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">acc</span> = qemu_opt_get(opts, <span style="color: #CC9393;">"accel"</span>);
        <span style="color: #7CB8BB;">AccelClass</span> *<span style="color: #DFAF8F;">ac</span> = accel_find(acc);
        <span style="color: #7CB8BB;">AccelState</span> *<span style="color: #DFAF8F;">accel</span>;
        accel = ACCEL(object_new_with_class(OBJECT_CLASS(ac)));
        ret = accel_init_machine(accel, current_machine);
}
</pre>
</div>
<p>
看到这里就明晰了，qemu_opt_get就是根据传入的参数去找accelerator的字符串名字，比如在启动qemu时传入了-enable-kvm，那么这里的acc就是指向串“kvm”了。而accel_find往下一路调用，最后会来到glib提供的g_hash_table_lookup函数，也就是说，包括accelerator在内的很多对象，都会事先存在hash表里，然后后面要用时通过“kvm”这样的key去找，当然真正的key串可能是组合了一些其它的字符，比如kvm-accel，见accel_find-&gt;ACCEL_CLASS_NAME。
</p>

<p>
顺便提下，current_machine也是先在初始化阶段的qemu_create_machine里创建出来：
</p>
<div class="org-src-container">
<pre class="src src-c">current_machine = MACHINE(object_new_with_class(OBJECT_CLASS(machine_class)));
</pre>
</div>

<p>
这里以kvm accelerator这种type类型的对象注册为例，来分析下一个对象的注册到hash表的流程，有此一例，其它对象的注册类似。在accel/kvm/kvm-all.c中，有如下代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">kvm_accel_type</span> = {
        .name = TYPE_KVM_ACCEL,
        .parent = TYPE_ACCEL,
        .instance_init = kvm_accel_instance_init,
        .class_init = kvm_accel_class_init,
        .instance_size = <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(KVMState),
};
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">kvm_type_init</span>(<span style="color: #7CB8BB;">void</span>)
{
        type_register_static(&amp;kvm_accel_type);
}
</pre>
</div>
<p>
从type_register_static一路往下的话，就会看到g_hash_table_insert，这个就和前面通过
g_hash_table_lookup去寻找加速器对应起来了，只有这里insert，后面才能lookup。现在还有唯一一
个问题，那就是kvm_type_init这个函数何时执行，qemu项目的代码里并没有找到直接调用这个函数的
地方。秘密就在这行代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">type_init</span>(kvm_type_init);
</pre>
</div>
<p>
type_init定义如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">type_init</span>(<span style="color: #DFAF8F;">function</span>) module_init(function, MODULE_INIT_QOM)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">module_init</span>(<span style="color: #DFAF8F;">function</span>, <span style="color: #DFAF8F;">type</span>)                                           \
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #F0DFAF; font-weight: bold;">__attribute__</span>((constructor)) <span style="color: #DFAF8F;">do_qemu_init_</span> ## function(<span style="color: #7CB8BB;">void</span>)    \
{                                                                             \
    register_module_init(function, type);                               \ 
}
</pre>
</div>
<p>
可以看到这里用了constructor修饰，被这个gcc属性修饰的函数，会先于main函数的执行，而register_module_init关键的就下面几行：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">ModuleEntry</span> *<span style="color: #DFAF8F;">e</span>;
e-&gt;init = fn;
<span style="color: #93E0E3;">QTAILQ_INSERT_TAIL</span>(l, e, node);
</pre>
</div>
<p>
可以看到也就是把传进来的kvm_type_init给放到了e-&gt;init里，可以理解为先于main执行的这段代码，主要是个注册作用，而真正调用这个动作还是在main里做的：
</p>
<pre class="example">
main-&gt;qemu_init-&gt;qemu_init_subsystems-&gt;module_call_init-&gt;kvm_type_init
</pre>


<p>
上述流程当然是先于configure_accelerator里通过accel_find去寻找加速器的，也就是main调用的qemu_init函数里，是先调用qemu_init_subsystems而后调用configure_accelerator的。
</p>

<p>
继续看给accel真正分配空间就是在object_new_with_with_class里了：
</p>
<pre class="example">
object_new_with_class-&gt;object_new_with_type-&gt;g_malloc
</pre>


<p>
这里又出现了大写的ACCEL宏，可以想见其作用无非就是强转指针类型了：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">ACCEL</span>(<span style="color: #DFAF8F;">obj</span>)                                      \
        OBJECT_CHECK(AccelState, (obj), TYPE_ACCEL)
</pre>
</div>
<p>
到现在就有了一个KVMState，现在回过头来给出KVMState的一些作用，可以理解为内核实现了KVM模块，那么它在QEMU这样的用户程序里有一个代表就是KVMState，其中的fd成员就保存了打开/dev/kvm时返回的fd。每次运行一个QEMU程序，就会申请一个这个结构体。
</p>

<p>
回到kvm_init函数，再往下有如下重要的代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">do</span>{
        ret = kvm_ioctl(s, KVM_CREATE_VM, type);
 } <span style="color: #F0DFAF; font-weight: bold;">while</span> (ret == -EINTR);
s-&gt;vmfd = ret;
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">kvm_ioctl</span>(<span style="color: #7CB8BB;">KVMState</span> *<span style="color: #DFAF8F;">s</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">type</span>, ...)
{
        ret = ioctl(s-&gt;fd, type, arg);
        <span style="color: #F0DFAF; font-weight: bold;">return</span> ret;
}
</pre>
</div>
<p>
可以看到这里就使用了前面打开/dev/kvm的fd来调用ioctl，这个ioctl支持KVM_CREATE_VM这样的命令，在内核里的实现是kvm_dev_ioctl。并且将返回的ret文件描述符保存到了KVMState的vmfd成员，将来又可以在这个fd上调用它的ioctl，比如创建vcpu，在内核里对应这个vmfd的ioctl函数实现是kvm_vm_ioctl。关于这点后面还会分析。
</p>

<p>
<b>可以总结下，通过调用qemu_open_old函数，由/dev/kvm文件得到的fd，表示了一个KVM模块功能的合集，而通过KVM_CREATE_VM命令在/dev/kvm上的fd调用ioctl得到的vmfd，表示了一台虚拟机。</b>
</p>

<p>
在分析内核侧前，想特别的提下，QEMU作为一个用户程序，不论其代码怎么写，其起始入口函数都是softmmu/main.c:main，从这里入口会运行很多复杂的流程。而分析代码从这个函数起始，也算是扭住了千头万绪的线头。一些流程上先后顺序的确定也会很清晰。
</p>

<p>
现在可以看下内核KVM侧关于虚拟机创建的实现了。首先是初始化阶段/dev/kvm设备文件的注册，只有注册好了这个文件，用户程序才能open它，并在这上面使用ioctl函数。
</p>

<p>
内核的虚拟化实现是作为一个模块而存在，amd的svm，和intel的vmx实现不一样。但是内核抽出了公共部分在virt/kvm下。具体来说，针对/dev/kvm的初始化注册，由kvm_init函数里调用misc_register来实现。而对kvm_init的调用，对于intel来说就是arch/x86/kvm/vmx/vmx.c：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">module_init</span>(vmx_init);
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">__init</span> vmx_init(<span style="color: #7CB8BB;">void</span>)
{
        r = kvm_init(&amp;vmx_x86_ops, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">vcpu_vmx</span>),
                     __alignof__(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">vcpu_vmx</span>), THIS_MODULE);
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">kvm_init</span>(<span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">opaque</span>, <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">vcpu_size</span>, <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">vcpu_align</span>,
             <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">module</span> *<span style="color: #DFAF8F;">module</span>)
{
        r = misc_register(&amp;kvm_dev);
}
</pre>
</div>
<p>
这里的kvm_dev定义为：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file_operations</span> <span style="color: #DFAF8F;">kvm_chardev_ops</span> = {
        .unlocked_ioctl = kvm_dev_ioctl,
        .llseek         = noop_llseek,
        KVM_COMPAT(kvm_dev_ioctl),
};

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">miscdevice</span> <span style="color: #DFAF8F;">kvm_dev</span> = {
        KVM_MINOR,
        <span style="color: #CC9393;">"kvm"</span>,
        &amp;kvm_chardev_ops,
};
</pre>
</div>
<p>
可以看到，/dev/kvm文件关联的fop就是kvm_chardev_ops，对/dev/kvm使用ioctl时，就会来到kvm_dev_ioctl函数。现在主要关心kvm_ioctl以KVM_CREATE_VM调用ioctl时的内核代码，在这个命令下，内核会进入kvm_dev_ioctl_create_vm函数。该函数比较关键的流程如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">r</span>;
<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">kvm</span> *<span style="color: #DFAF8F;">kvm</span>;
kvm = kvm_create_vm(type);
r = get_unused_fd_flags(O_CLOEXEC);
file = anon_inode_getfile(<span style="color: #CC9393;">"kvm-vm"</span>, &amp;kvm_vm_fops, kvm, O_RDWR);
<span style="color: #93E0E3;">fd_install</span>(r, file);
<span style="color: #F0DFAF; font-weight: bold;">return</span> r;
</pre>
</div>
<p>
先是创建一个kvm结构体，一台vm都有一个kvm结构体，而kvm结构体里有内核对VCPU的表示比如kvm_cpu结构体，所有VCPU都在vcpus数组里，也有mm_struct结构体，vm所用的虚拟内存就是用户进程的虚拟地址空间，当然还有其它很多信息。
</p>

<p>
然后通过get_unused_fd_flags得到一个文件描述符r，最后返回的是这个文件描述符。随后调用anon_inode_getfile分配一个匿名的inode，file-&gt;private_data就是kvm，将来通过这个file（或fd）都可以找到kvm结构体。当然，fd和file要关联到当前进程的打开文件描述符表current-&gt;files里，后面通过fdget函数得到fd关联的file。
</p>

<p>
前面已经总结强调过了，get_unused_fd_flags返回的vmfd就是代表了一台虚拟机，Linux一切皆文件，针对这个文件（虚拟机），其操作的函数集就是kvm_vm_fops，这个fops里最关键的就是kvm_vm_ioctl函数了。比如针对一台虚拟机可以创建vcpu，这些事情都是后面小节的主题了。
</p>

<p>
总之到目前，总算是有了一台虚拟机，对比真实硬件机器来说，可以理解为主板以及上面的插槽这些都做好了，就等后面插上CPU（创建VCPU），插上需要的外设等。
</p>
</div>
</div>
<div id="outline-container-org8d73ffe" class="outline-2">
<h2 id="org8d73ffe"><span class="section-number-2">2.</span> QEMU CPU创建</h2>
<div class="outline-text-2" id="text-2">
<p>
QEMU里虚拟CPU的创建主要是通过kvm_start_vcpu_thread，新起一个线程去创建的，并且这个线程就代表了VCPU去运行。以下是kvm_start_vcpu_thread被如下调用链调用：
</p>
<pre class="example">
main-&gt;qemu_init-&gt;qmp_x_exit_preconfig-&gt;qemu_init_board-&gt;machine_run_board_init-&gt;pc_init1-&gt;x86_cpus_init-&gt;x86_cpu_new-&gt;qdev_realize-&gt;object_property_set_bool-&gt;object_property_set_qobject-&gt;object_property_set-&gt;
property_set_bool-&gt;device_set_realized-&gt;x86_cpu_realizefn-&gt;qemu_init_vcpu-&gt;kvm_start_vcpu_thread
</pre>

<p>
以上其实就是主板的初始化流程，就这个调用链而言，最后的函数才关心的是CPU具现化。以下分析这个调用链本身是怎么被调用起来的，分析这点更多的是涉及到QOM，也就是QEMU代码的组织，而关于在QEMU代码里VCPU创建本身在本节偏后部分会介绍到。
</p>

<p>
首先看machine_run_board_init是如何调用起pc_init1的，在machine_run_board_init函数里：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">machine_run_board_init</span>(<span style="color: #7CB8BB;">MachineState</span> *<span style="color: #DFAF8F;">machine</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">mem_path</span>, <span style="color: #7CB8BB;">Error</span> **<span style="color: #DFAF8F;">errp</span>)
{
        <span style="color: #7CB8BB;">MachineClass</span> *<span style="color: #DFAF8F;">machine_class</span> = MACHINE_GET_CLASS(machine);
        machine_class-&gt;init(machine);
}
</pre>
</div>
<p>
这里init函数在我的硬件平台就是pc_init1。这个回调是怎么设置的呢？
</p>

<p>
QEMU里x86平台的虚拟主板分为两类，一是i440fx，二是q35。i440fx是一个用于模拟Intel 440fx芯片组的虚拟平台。Intel i440fx芯片组是20世纪90年代早期的一个常见的PC主板芯片组，用于支持Intel的Pentium和Pentium Pro处理器。在虚拟化环境中，i440fx主板模拟了这个旧型号的主板，以便运行旧的操作系统或应用程序，或者为测试和开发目的。而q35模拟了更现代的主板和硬件特性，以便更好地支持现代操作系统和应用程序。
</p>

<p>
不论是i440fx还是q35，都是通过DEFINE_PC_MACHINE宏来注册一个具体的pc machine实例。而DEFINE_PC_MACHINE里就会设置好init函数，init本身是pc_init_##suffix，但这个函数里面会调用pc_init1。对于i440fx来说，就是DEFINE_I440FX_MACHINE里调用DEFINE_PC_MACHINE。
</p>

<p>
继续往后看object_property_set函数，在object_property_set里有个set回调，它主要是看一个对象（这里是CPU）是否具有realized属性，
若有的话， <b>那么object_property_set里怎么就能按如下方式调用set函数呢？</b>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">bool</span> <span style="color: #93E0E3;">object_property_set</span>(<span style="color: #7CB8BB;">Object</span> *<span style="color: #DFAF8F;">obj</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">name</span>, <span style="color: #7CB8BB;">Visitor</span> *<span style="color: #DFAF8F;">v</span>,
                         <span style="color: #7CB8BB;">Error</span> **<span style="color: #DFAF8F;">errp</span>)
{
        <span style="color: #7CB8BB;">ObjectProperty</span> *<span style="color: #DFAF8F;">prop</span> = object_property_find_err(obj, name, errp);
        prop-&gt;set(obj, v, name, prop-&gt;opaque, errp);
}
</pre>
</div>
<p>
这里set函数其实就是property_set_bool。
先列一个调用链：
</p>
<pre class="example">
main-&gt;qemu_init-&gt;qemu_create_machine-&gt;select_machine-&gt;object_class_get_list-&gt;object_class_foreach-&gt;g_hash_table_foreach-&gt;object_class_foreach_tramp-&gt;type_initialize(递归三次)-&gt;device_class_init-&gt;object_class_property_add_bool
</pre>

<p>
这里先分析下这个调用链是在干什么，再分析最后的object_class_property_add_bool。简要的说，这个调用链是要对加入type_table哈希表中的所有类型进行初始化，具体的说，包括设置（ <b>不是调用</b>
）具现化的回调函数，比如device_set_realized，后面真正具现化的时候再调用这样的回调函数。
</p>

<p>
到这里可以总结下QEMU代码的流程了，主要是以下几个阶段：
</p>
<ol class="org-ol">
<li>注册。</li>
<li>初始化。</li>
<li>具现化。</li>
<li>运行时。</li>
</ol>
<p>
记住这几个阶段，以后在处理QEMU+KVM的具体问题或者继续深挖代码时，能时刻清晰自己处于哪个阶段，而不只是具体问题的“指哪打哪”很局部，还多了一点全局观念或角度。
</p>

<p>
上面object_class_property_add_bool的调用链包括后面分析的object_class_property_add_bool都是归结于初始化阶段。而本节一开始分析CPU的创建过程其实是具体设备的具现化阶段了。下面再介绍一下注册阶段。以设备类的TypeInfo，device_type_info量为例来分析这个注册过程。其实关于这个type init的过程上节对kvm_accel_type注册的分析已经涉及过了，已经不是新鲜玩意了，首先有：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">type_init</span>(qdev_register_types)
</pre>
</div>
<p>
这个type_init怎么运行起来上节已经介绍了，这里只是从qdev_register_types一路往下，看看type_table_add函数：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">type_table_add</span>(<span style="color: #7CB8BB;">TypeImpl</span> *<span style="color: #DFAF8F;">ti</span>)
{
        g_hash_table_insert(type_table_get(), (<span style="color: #7CB8BB;">void</span> *)ti-&gt;name, ti);
}
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">GHashTable</span> *<span style="color: #93E0E3;">type_table_get</span>(<span style="color: #7CB8BB;">void</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">GHashTable</span> *<span style="color: #DFAF8F;">type_table</span>;
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (type_table == <span style="color: #BFEBBF;">NULL</span>) {
                type_table = g_hash_table_new(g_str_hash, g_str_equal);
        }
        <span style="color: #F0DFAF; font-weight: bold;">return</span> type_table;
}
</pre>
</div>
<p>
这里可以看到这个类型表的落脚点，名字就叫：type_table，是个static类型的，初始化一次为NULL，第一次运行创建这样一个表，在函数退出时依旧有效。并且可以将各种类型加入到这个表中。这样注册完成后，就可以在初始化阶段时，调用各个TypeInfo的class_init函数了，就是在type_initialize（可能递归多次）里调用class_init函数。
</p>

<p>
以上其实又涉及到了QOM的概念， 在上节已经首次提出了QOM的一方面。这里针对本节的角度再次总结QOM的另一方面。 <b>QOM：Qemu Object Model。所谓model，就是有一定的套路或范式，不论来多少类型、设备，都按这个注册、初始化最后具现的流程来编码，具体点就是到处设置回调函数。</b>
</p>

<p>
后面还会遇到QOM的体现，本文会更多的以具体代码里去阐述QOM的概念，不然只是上节的QOM概念会空洞。
</p>

<p>
现在开始分析object_class_property_add_bool，以解答前面的问题“object_property_set里怎么就能按如下方式调用set函数呢”。在这个函数中有：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">ObjectProperty</span> *
<span style="color: #93E0E3;">object_class_property_add_bool</span>(<span style="color: #7CB8BB;">ObjectClass</span> *<span style="color: #DFAF8F;">klass</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">name</span>,
                               <span style="color: #7CB8BB;">bool</span> (*<span style="color: #93E0E3;">get</span>)(<span style="color: #7CB8BB;">Object</span> *, <span style="color: #7CB8BB;">Error</span> **),
                               <span style="color: #7CB8BB;">void</span> (*<span style="color: #93E0E3;">set</span>)(<span style="color: #7CB8BB;">Object</span> *, <span style="color: #7CB8BB;">bool</span>, <span style="color: #7CB8BB;">Error</span> **))
{
        <span style="color: #7CB8BB;">BoolProperty</span> *<span style="color: #DFAF8F;">prop</span> = g_malloc0(<span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(*prop));
        prop-&gt;get = get;
        prop-&gt;set = set;
        <span style="color: #F0DFAF; font-weight: bold;">return</span> object_class_property_add(klass, name, <span style="color: #CC9393;">"bool"</span>,
                                         get ? property_get_bool : <span style="color: #BFEBBF;">NULL</span>,
                                         set ? property_set_bool : <span style="color: #BFEBBF;">NULL</span>,
                                         <span style="color: #BFEBBF;">NULL</span>,
                                         prop);
}
</pre>
</div>
<p>
上面的set函数其实就是device_set_realized，这在object_class_property_add_bool的父函数device_class_init里可以看到，这里要注意，object_class_property_add_bool自己也构造了一个BoolProperty类型的prop属性，这个BoolProperty的set函数是device_set_realized，并将它作为最后一个参数传递给了object_class_property_add，这个函数在下面马上会分析，它也构造了一个prop，不过是ObjectProperty类型的。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">ObjectProperty</span> *
<span style="color: #93E0E3;">object_class_property_add</span>(<span style="color: #7CB8BB;">ObjectClass</span> *<span style="color: #DFAF8F;">klass</span>,
                          <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">name</span>,
                          <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">type</span>,
                          <span style="color: #7CB8BB;">ObjectPropertyAccessor</span> *<span style="color: #DFAF8F;">get</span>,
                          <span style="color: #7CB8BB;">ObjectPropertyAccessor</span> *<span style="color: #DFAF8F;">set</span>,
                          <span style="color: #7CB8BB;">ObjectPropertyRelease</span> *<span style="color: #DFAF8F;">release</span>,
                          <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">opaque</span>)
{
        <span style="color: #7CB8BB;">ObjectProperty</span> *<span style="color: #DFAF8F;">prop</span>;
        prop = g_malloc0(<span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(*prop));
        prop-&gt;set = set;
        prop-&gt;opaque = opaque;
        g_hash_table_insert(klass-&gt;properties, prop-&gt;name, prop);
        <span style="color: #F0DFAF; font-weight: bold;">return</span> prop;
}
</pre>
</div>
<p>
可以看到这里调用了g_hash_table_insert函数将一个prop加入到了properties哈希表中，其key就是传进来的name字符串，为realized。这样在前面的object_property_set函数中就可以通过object_property_find_err函数，以name参数为realized找到其对应的prop，进而调用这个prop对应的set函数：property_set_bool。同时还有很重要的一点，opaque被保存在了prop-&gt;opaue成员里，这样在早先分析过的object_property_set函数里，在先找到了ObjectProperty类型的prop后，才能从这个prop里取出opaque，而opaque又作为一个BoolProperty类型的参数传递给object_property_set里调用的set函数（也就是property_set_bool），这样在这个set函数里又才调用BoolProperty的set回调为device_set_realized，进而去执行具现化的流程。
</p>

<p>
分析完device_set_realized，往下打算分析下x86_cpu_realizefn函数的调用。device_set_realized里对x86_cpu_realizefn调用是这样的：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">device_set_realized</span>(<span style="color: #7CB8BB;">Object</span> *<span style="color: #DFAF8F;">obj</span>, <span style="color: #7CB8BB;">bool</span> <span style="color: #DFAF8F;">value</span>, <span style="color: #7CB8BB;">Error</span> **<span style="color: #DFAF8F;">errp</span>)
{
        <span style="color: #7CB8BB;">DeviceState</span> *<span style="color: #DFAF8F;">dev</span> = DEVICE(obj);
        <span style="color: #7CB8BB;">DeviceClass</span> *<span style="color: #DFAF8F;">dc</span> = DEVICE_GET_CLASS(dev);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (dc-&gt;realize) {
                dc-&gt;realize(dev, &amp;local_err);
        }
}
</pre>
</div>

<p>
这里出现了大写的DEVICE，这点在前面提到过，也是QOM的一个方面。但是具体的DEVICE的实现，前面没有提到，这里简要分析下。
</p>

<p>
DEVICE的最开始定义在include/hw/qdev-core.h里有：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">OBJECT_DECLARE_TYPE</span>(DeviceState, DeviceClass, DEVICE)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">OBJECT_DECLARE_TYPE</span>(<span style="color: #DFAF8F;">InstanceType</span>, <span style="color: #DFAF8F;">ClassType</span>, <span style="color: #DFAF8F;">MODULE_OBJ_NAME</span>) \
        <span style="color: #F0DFAF; font-weight: bold;">typedef</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">InstanceType</span> <span style="color: #7CB8BB;">InstanceType</span>; \
        <span style="color: #F0DFAF; font-weight: bold;">typedef</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">ClassType</span> <span style="color: #7CB8BB;">ClassType</span>; \
        \
        G_DEFINE_AUTOPTR_CLEANUP_FUNC(InstanceType, object_unref) \
        \
        DECLARE_OBJ_CHECKERS(InstanceType, ClassType, \
                             MODULE_OBJ_NAME, TYPE_##MODULE_OBJ_NAME)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">DECLARE_OBJ_CHECKERS</span>(<span style="color: #DFAF8F;">InstanceType</span>, <span style="color: #DFAF8F;">ClassType</span>, <span style="color: #DFAF8F;">OBJ_NAME</span>, <span style="color: #DFAF8F;">TYPENAME</span>) \
        DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME)      \
        \
        DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME)
</pre>
</div>
<p>
可以看到上节介绍过的DECLARE_INSTANCE_CHECKER，里面会有DEVICE的定义，就不再进一步贴代码了。这里主要关心下DECLARE_CLASS_CHECKERS，这个前面没有介绍过。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">define</span> <span style="color: #93E0E3;">DECLARE_CLASS_CHECKERS</span>(ClassType, OBJ_NAME, TYPENAME) \
     <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">G_GNUC_UNUSED</span> <span style="color: #DFAF8F;">ClassType</span> * \
     OBJ_NAME##_GET_CLASS(<span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">obj</span>) \
{ <span style="color: #F0DFAF; font-weight: bold;">return</span> OBJECT_GET_CLASS(ClassType, obj, TYPENAME); } \
\
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">G_GNUC_UNUSED</span> <span style="color: #DFAF8F;">ClassType</span> * \
OBJ_NAME##_CLASS(<span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">klass</span>) \
{ <span style="color: #F0DFAF; font-weight: bold;">return</span> OBJECT_CLASS_CHECK(ClassType, klass, TYPENAME); }
</pre>
</div>
<p>
可以看到，OBJ_NAME被替换为OBJECT_DECLARE_TYPE宏的第三个参数为DEVICE，这样就有了device_set_realized函数里可以用DEVICE_GET_CLASS了。再往下跟OBJECT_GET_CLASS-&gt;object_get_class的话会知道，最后实际获取的就是obj-&gt;class，这里就不再贴代码了。
</p>

<p>
回到device_set_realized函数，里面最主要的就是通过dc调用了realize函数（就是x86_cpu_realizefn）了。这又是一个回调，那么这个回调在哪里设置的呢，分析这个问题，又要引出QOM的另一方面了： <b>object的继承</b> 。下面分析这个问题。
</p>

<p>
先看几个结构体：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">x86_cpu_type_info</span> = {
        name = TYPE_X86_CPU,
        .parent = TYPE_CPU,
        .class_init = x86_cpu_common_class_init,
};
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">cpu_type_info</span> = {
        .name = TYPE_CPU,
        .parent = TYPE_DEVICE,
        .class_init = cpu_class_init,
};
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">device_type_info</span> = {
        .name = TYPE_DEVICE,
        .parent = TYPE_OBJECT,
        .class_init = device_class_init,
};
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">object_info</span> = {
        .name = TYPE_OBJECT,
        .class_init = object_class_init,
};
</pre>
</div>
<p>
观察以上TypeInfo定义，可以很清楚的看到，它们构成了父子继承关系，这就是QOM对各种虚拟计算机对象的一种抽象，在类型的初始化阶段时，会递归调用type_initialize函数，就是如果一个TypeInfo如果有parent，会先对parent这个TypeImpl调用type_initialize，然后到递归的最底层时，会调用class_init（如果有的话）：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">type_initialize</span>(<span style="color: #7CB8BB;">TypeImpl</span> *<span style="color: #DFAF8F;">ti</span>)
{
        parent = type_get_parent(ti);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (parent) {
                type_initialize(parent);
        }
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (ti-&gt;class_init) {
                ti-&gt;class_init(ti-&gt;class, ti-&gt;class_data);
        }
}
</pre>
</div>
<p>
而对于x86_cpu_type_info的class_init来说（x86_cpu_common_class_init），就会调用device_class_set_parent_realize来设置realize回调函数：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">x86_cpu_common_class_init</span>(<span style="color: #7CB8BB;">ObjectClass</span> *<span style="color: #DFAF8F;">oc</span>, <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">data</span>)
{
        <span style="color: #7CB8BB;">X86CPUClass</span> *<span style="color: #DFAF8F;">xcc</span> = X86_CPU_CLASS(oc);
        <span style="color: #7CB8BB;">DeviceClass</span> *<span style="color: #DFAF8F;">dc</span> = DEVICE_CLASS(oc);
        device_class_set_parent_realize(dc, x86_cpu_realizefn,
                                        &amp;xcc-&gt;parent_realize);
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">device_class_set_parent_realize</span>(<span style="color: #7CB8BB;">DeviceClass</span> *<span style="color: #DFAF8F;">dc</span>,
                                     <span style="color: #7CB8BB;">DeviceRealize</span> <span style="color: #DFAF8F;">dev_realize</span>,
                                     <span style="color: #7CB8BB;">DeviceRealize</span> *<span style="color: #DFAF8F;">parent_realize</span>)
{
        *parent_realize = dc-&gt;realize;
        dc-&gt;realize = dev_realize;
}
</pre>
</div>
<p>
这样设置好以后，在device_set_realized中就可以以dc-&gt;realize这样的方式调用了。至于上面具有继承关系的各个TypeInfo，它们是如何注册的，这点不再赘述，前面已经有多个例子分析到。
</p>

<p>
再往后看调用链，来到qemu_init_vcpu，里面有：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">qemu_init_vcpu</span>(<span style="color: #7CB8BB;">CPUState</span> *<span style="color: #DFAF8F;">cpu</span>)
{
        cpus_accel-&gt;create_vcpu_thread(cpu);
}
</pre>
</div>
<p>
create_vcpu_thread（就是kvm_start_vcpu_thread）是一开始kvm_start_vcpu_thread调用链里的最后一个回调了，对于它笔者不打算详细分析了，因为到这里对于QOM的套路已经驾轻就熟了，这里只是简单列下代码并简单解释下，以验证或加深理解。以后的QEMU+KVM关于QOM的主题分析也不会这么详细了，在那些文档里，涉及到QOM的分析，都会请移步至此。
</p>

<p>
关于如何调用起create_vcpu_thread，如下一些代码所示：
</p>
<div class="org-src-container">
<pre class="src src-c">main-&gt;qemu_init-&gt;qmp_x_exit_preconfig-&gt;qemu_init_board-&gt;machine_run_board_init-&gt;accel_init_interfaces-&gt;accel_init_ops_interfaces-&gt;cpus_register_accel

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> AccelOpsClass *cpus_accel;

<span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">cpus_register_accel</span>(<span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">AccelOpsClass</span> *<span style="color: #DFAF8F;">ops</span>)
{
        cpus_accel = ops;
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">accel_init_ops_interfaces</span>(<span style="color: #7CB8BB;">AccelClass</span> *<span style="color: #DFAF8F;">ac</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">ac_name</span>;
        <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">ops_name</span>;
        <span style="color: #7CB8BB;">ObjectClass</span> *<span style="color: #DFAF8F;">oc</span>;
        <span style="color: #7CB8BB;">AccelOpsClass</span> *<span style="color: #DFAF8F;">ops</span>;
        ac_name = object_class_get_name(OBJECT_CLASS(ac));
        ops_name = g_strdup_printf(<span style="color: #CC9393;">"%s"</span> ACCEL_OPS_SUFFIX, ac_name);
        oc = module_object_class_by_name(ops_name);
        ops = ACCEL_OPS_CLASS(oc);
        cpus_register_accel(ops);
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">machine_run_board_init</span>(<span style="color: #7CB8BB;">MachineState</span> *<span style="color: #DFAF8F;">machine</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">mem_path</span>, <span style="color: #7CB8BB;">Error</span> **<span style="color: #DFAF8F;">errp</span>)
{
        accel_init_interfaces(ACCEL_GET_CLASS(machine-&gt;accelerator));
}
</pre>
</div>
<p>
可以看到，在machine有了accelerator之后，就可以从里面取出ops交给全局静态变量cpus_accel了。
</p>

<p>
但这些还不涉及到把create_vcpu_thread设置为kvm_start_vcpu_thread。可以想见这是在object_class_foreach_tramp-&gt;type_initialize里调用class_init完成的：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">DECLARE_CLASS_CHECKERS</span>(AccelOpsClass, ACCEL_OPS, TYPE_ACCEL_OPS)
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">kvm_accel_ops_class_init</span>(<span style="color: #7CB8BB;">ObjectClass</span> *<span style="color: #DFAF8F;">oc</span>, <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">data</span>)
{
        <span style="color: #7CB8BB;">AccelOpsClass</span> *<span style="color: #DFAF8F;">ops</span> = ACCEL_OPS_CLASS(oc);
        ops-&gt;create_vcpu_thread = kvm_start_vcpu_thread;
}
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">kvm_accel_ops_type</span> = {
        .name = ACCEL_OPS_NAME(<span style="color: #CC9393;">"kvm"</span>),
        .parent = TYPE_ACCEL_OPS,
        .class_init = kvm_accel_ops_class_init,
        .abstract = <span style="color: #BFEBBF;">true</span>,
};
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">kvm_accel_ops_register_types</span>(<span style="color: #7CB8BB;">void</span>)
{
        type_register_static(&amp;kvm_accel_ops_type);
}
<span style="color: #93E0E3;">type_init</span>(kvm_accel_ops_register_types);
</pre>
</div>
<p>
看到type_init一切就明晰了。
</p>

<p>
到目前为止，本文花了很多篇幅去阐述QOM，还较少涉及虚拟化本身，笔者认为这是必要的，从某种角度来说，QOM就代表了QEMU代码的组织，并且弄清楚这种组织或调用关系有可能比虚拟化本身更费劲。但对QOM的清晰，会有助于对QEMU代码的全局把握。当然虚拟化本身后面肯定还会深入的。
</p>

<p>
以上着重对QOM进行了介绍， <b>从现在开始，会更多的偏向于虚拟化本身了</b> ，在本节也就是QEMU里对于CPU的创建到底做了哪些事情。
</p>

<p>
在本节一开始，列出了创建VCPU的函数流程，只是到目前都只关注了这个调用流程是怎么调用起来的（在哪里设置回调，在哪里调用回调）．下面再贴下这个函数流程，后续就是主要关注这些流程上函数的逻辑了：
</p>
<pre class="example">
main-&gt;qemu_init-&gt;qmp_x_exit_preconfig-&gt;qemu_init_board-&gt;machine_run_board_init-&gt;pc_init1-&gt;x86_cpus_init-&gt;x86_cpu_new-&gt;qdev_realize-&gt;object_property_set_bool-&gt;object_property_set_qobject-&gt;object_property_set-&gt;
property_set_bool-&gt;device_set_realized-&gt;x86_cpu_realizefn-&gt;qemu_init_vcpu-&gt;kvm_start_vcpu_thread
</pre>


<p>
从machine_run_board_init调用pc_init1说起。QEMU中，主板模型有两种，一是i440fx，另外一个是q35，本文主要基于前者研究。不论是i440fx还是q35，都要通过DEFINE_PC_MACHINE去定义MachineClass的init函数：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">DEFINE_I440FX_MACHINE</span>(<span style="color: #DFAF8F;">suffix</span>, <span style="color: #DFAF8F;">name</span>, <span style="color: #DFAF8F;">compatfn</span>, <span style="color: #DFAF8F;">optionfn</span>) \
    <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #DFAF8F;">pc_init_</span>##suffix(<span style="color: #7CB8BB;">MachineState</span> *<span style="color: #DFAF8F;">machine</span>) \
    { \
        <span style="color: #7CB8BB;">void</span> (*<span style="color: #93E0E3;">compat</span>)(<span style="color: #7CB8BB;">MachineState</span> *<span style="color: #DFAF8F;">m</span>) = (compatfn); \
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (compat) { \
            compat(machine); \
        } \
        pc_init1(machine, TYPE_I440FX_PCI_HOST_BRIDGE, \
                 TYPE_I440FX_PCI_DEVICE); \
    } \
    DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">DEFINE_PC_MACHINE</span>(<span style="color: #DFAF8F;">suffix</span>, <span style="color: #DFAF8F;">namestr</span>, <span style="color: #DFAF8F;">initfn</span>, <span style="color: #DFAF8F;">optsfn</span>) \
    <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #DFAF8F;">pc_machine_</span>##suffix##_class_init(<span style="color: #7CB8BB;">ObjectClass</span> *<span style="color: #DFAF8F;">oc</span>, <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">data</span>) \
    { \
        <span style="color: #7CB8BB;">MachineClass</span> *<span style="color: #DFAF8F;">mc</span> = MACHINE_CLASS(oc); \
        optsfn(mc); \
        mc-&gt;init = initfn; \
        mc-&gt;kvm_type = pc_machine_kvm_type; \
    } \
    <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">pc_machine_type_</span>##suffix = { \
        .name       = namestr TYPE_MACHINE_SUFFIX, \
        .parent     = TYPE_PC_MACHINE, \
        .class_init = pc_machine_##suffix##_class_init, \
    }; \
    <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #DFAF8F;">pc_machine_init_</span>##suffix(<span style="color: #7CB8BB;">void</span>) \
    { \
        type_register(&amp;pc_machine_type_##suffix); \
    } \
    type_init(pc_machine_init_##suffix)
</pre>
</div>
<p>
对于q35的话就是宏DEFINE_Q35_MACHINE。这里suffix其实就是i440fx主板的版本，比如v8_2、v8_1等。可以看到initfn其实主要就是调用了pc_init1，而initfn又是作为MachineClass的init回调，所以在machine_run_board_init的最后可以这样调用：
</p>
<div class="org-src-container">
<pre class="src src-c">machine_class-&gt;init(machine);
</pre>
</div>

<p>
下面继续分析pc_init1调用的x86_cpus_init函数，该函数的最后会调用x86_cpu_new：
</p>
<div class="org-src-container">
<pre class="src src-c">possible_cpus = mc-&gt;possible_cpu_arch_ids(ms);
<span style="color: #F0DFAF; font-weight: bold;">for</span> (i = 0; i &lt; ms-&gt;smp.cpus; i++) {
    x86_cpu_new(x86ms, possible_cpus-&gt;cpus[i].arch_id, &amp;error_fatal);
}
</pre>
</div>
<p>
可以看到这里先调用了possible_cpu_arch_ids函数去返回一个CPUArchIDList类型的指针，该类型里主要是存放了当前所有可用CPU的arch_id以及其它一些信息。possible_cpu_arch_ids函数对于x86架构就是x86_possible_cpu_arch_ids函数，这是在x86_machine_class_init函数中设置的回调。在x86_possible_cpu_arch_ids中可以看到，返回的CPUArchIdList实际就来自ms-&gt;possible_cpus成员，第一次调用x86_possible_cpu_arch_ids时，possible_cpus指针是没有空间的，x86_possible_cpu_arch_ids第一次被调用时，会使用g_malloc0给ms-&gt;possible_cpus分配空间。同时在这个函数里还会使用ms-&gt;smp.max_cpus获取当前的最大可用cpu数目，这个smp.max_cpus在machine_parse_smp_config函数中通过用户配置获得，比如-smp参数设置为16，那么
x86_possible_cpu_arch_ids中看到的smp.max_cpus可能就是这个16。x86_possible_cpu_arch_ids中最重要的逻辑就是为每个cpu构建arch_id，这个arch_id其实就是个uint32_t类型，32位的数值，里面按比特位存放了pkg_id、die_id、core_id以及smt_id。这里有必要简单的介绍下cpu的拓扑结构，看两个结构体就明白了：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">typedef</span> <span style="color: #7CB8BB;">uint32_t</span> <span style="color: #7CB8BB;">apic_id_t</span>;

<span style="color: #F0DFAF; font-weight: bold;">typedef</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">X86CPUTopoIDs</span> {
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">pkg_id</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">die_id</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">core_id</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">smt_id</span>;
} <span style="color: #7CB8BB;">X86CPUTopoIDs</span>;

<span style="color: #F0DFAF; font-weight: bold;">typedef</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">X86CPUTopoInfo</span> {
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">dies_per_pkg</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">cores_per_die</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">threads_per_core</span>;
} <span style="color: #7CB8BB;">X86CPUTopoInfo</span>;
</pre>
</div>
<p>
可以很清楚的看到处理器的拓扑结构，首先处理器有若干个package，一个package下有若干个dies，而每个die下又有若干个cores，core下又有若干个threads，最下层又分是否是否支持超线程（SMT，Simultaneous Multi-threading）从而有smt_id，每个id成员其实就是指明自己在哪个层级的id号。
</p>

<p>
现在回到x86_possible_cpu_arch_ids函数，继续研究arch_id是如何构建的：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">for</span> (i = 0; i &lt; ms-&gt;possible_cpus-&gt;len; i++) {
        ms-&gt;possible_cpus-&gt;cpus[i].arch_id =
                x86_cpu_apic_id_from_index(x86ms, i);
 }

<span style="color: #7CB8BB;">uint32_t</span> <span style="color: #93E0E3;">x86_cpu_apic_id_from_index</span>(<span style="color: #7CB8BB;">X86MachineState</span> *<span style="color: #DFAF8F;">x86ms</span>,
                                    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">cpu_index</span>)
{
        <span style="color: #7CB8BB;">X86CPUTopoInfo</span> <span style="color: #DFAF8F;">topo_info</span>;

        init_topo_info(&amp;topo_info, x86ms);

        <span style="color: #F0DFAF; font-weight: bold;">return</span> x86_apicid_from_cpu_idx(&amp;topo_info, cpu_index);
}

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">init_topo_info</span>(<span style="color: #7CB8BB;">X86CPUTopoInfo</span> *<span style="color: #DFAF8F;">topo_info</span>,
                           <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">X86MachineState</span> *<span style="color: #DFAF8F;">x86ms</span>)
{
        <span style="color: #7CB8BB;">MachineState</span> *<span style="color: #DFAF8F;">ms</span> = MACHINE(x86ms);

        topo_info-&gt;dies_per_pkg = ms-&gt;smp.dies;
        topo_info-&gt;cores_per_die = ms-&gt;smp.cores;
        topo_info-&gt;threads_per_core = ms-&gt;smp.threads;
}
</pre>
</div>
<p>
可以看到，函数x86_cpu_apic_id_from_index用于构造arch_id，该函数首先使用init_topo_info初始化一个topo_info结构体，这个结构体里有一些成员，会记录每个pkg有多少die，每个die又有多少个core，每个core又有多少个thread，这些成员的值都来自machine_parse_smp_config函数，这个函数前面提到过，都是依据用户的配置填充便是。
</p>

<p>
继续看x86_apicid_from_cpu_idx函数：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">apic_id_t</span> <span style="color: #93E0E3;">x86_apicid_from_cpu_idx</span>(<span style="color: #7CB8BB;">X86CPUTopoInfo</span> *<span style="color: #DFAF8F;">topo_info</span>,
                                                <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">cpu_index</span>)
{
    <span style="color: #7CB8BB;">X86CPUTopoIDs</span> <span style="color: #DFAF8F;">topo_ids</span>;
    x86_topo_ids_from_idx(topo_info, cpu_index, &amp;topo_ids);
    <span style="color: #F0DFAF; font-weight: bold;">return</span> x86_apicid_from_topo_ids(topo_info, &amp;topo_ids);
}

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">x86_topo_ids_from_idx</span>(<span style="color: #7CB8BB;">X86CPUTopoInfo</span> *<span style="color: #DFAF8F;">topo_info</span>,
                                         <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">cpu_index</span>,
                                         <span style="color: #7CB8BB;">X86CPUTopoIDs</span> *<span style="color: #DFAF8F;">topo_ids</span>)
{
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">nr_dies</span> = topo_info-&gt;dies_per_pkg;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">nr_cores</span> = topo_info-&gt;cores_per_die;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">nr_threads</span> = topo_info-&gt;threads_per_core;

    topo_ids-&gt;pkg_id = cpu_index / (nr_dies * nr_cores * nr_threads);
    topo_ids-&gt;die_id = cpu_index / (nr_cores * nr_threads) % nr_dies;
    topo_ids-&gt;core_id = cpu_index / nr_threads % nr_cores;
    topo_ids-&gt;smt_id = cpu_index % nr_threads;
}
</pre>
</div>

<p>
x86_apicid_from_cpu_idx调用了x86_topo_ids_from_idx初始化一个topo_ids结构体，该结构体记录了针对现在传进来的cpu_index（实际就是for循环里的循环变量），其对应的pkg_id、die_id、core_id以及smt_id各是多少，注意这些id在x86_topo_ids_from_idx函数里是如何计算的，针对每级id，要计算其下的级别共能容纳多少，然后除以这个数字得到的值再对本级能容纳多少取余得到了本级的id。
</p>

<p>
有了各级别的id存于topo_ids里就可以调用x86_apicid_from_topo_ids了：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">apic_id_t</span> <span style="color: #93E0E3;">x86_apicid_from_topo_ids</span>(<span style="color: #7CB8BB;">X86CPUTopoInfo</span> *<span style="color: #DFAF8F;">topo_info</span>,
                                                 <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">X86CPUTopoIDs</span> *<span style="color: #DFAF8F;">topo_ids</span>)
{
    <span style="color: #F0DFAF; font-weight: bold;">return</span> (topo_ids-&gt;pkg_id  &lt;&lt; apicid_pkg_offset(topo_info)) |
           (topo_ids-&gt;die_id  &lt;&lt; apicid_die_offset(topo_info)) |
           (topo_ids-&gt;core_id &lt;&lt; apicid_core_offset(topo_info)) |
           topo_ids-&gt;smt_id;
}


</pre>
</div>
<p>
在这里就可以看到各级id左移拼接在一起形成一个apic_id，至于apicid_xxx_offset的代码细节就不分析了，原理就是左移出来下级所有id需要的bit位就可以了。
</p>

<p>
x86_possible_cpu_arch_ids再后面的逻辑就是填充possible_cpus里各个cpu属性（props）的各级id了，就不详细分析了。
</p>

<p>
介绍完了x86_possible_cpu_arch_ids，得到了possible_cpus，现在回到x86_cpus_init，这时就可以使用possible_cpus-&gt;cpus[i].arch_id去调用x86_cpu_new函数了，x86_cpu_new函数定义如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">x86_cpu_new</span>(<span style="color: #7CB8BB;">X86MachineState</span> *<span style="color: #DFAF8F;">x86ms</span>, <span style="color: #7CB8BB;">int64_t</span> <span style="color: #DFAF8F;">apic_id</span>, <span style="color: #7CB8BB;">Error</span> **<span style="color: #DFAF8F;">errp</span>)
{
    <span style="color: #7CB8BB;">Object</span> *<span style="color: #DFAF8F;">cpu</span> = object_new(MACHINE(x86ms)-&gt;cpu_type);

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>object_property_set_uint(cpu, <span style="color: #CC9393;">"apic-id"</span>, apic_id, errp)) {
        <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">out</span>;
    }
    qdev_realize(DEVICE(cpu), <span style="color: #BFEBBF;">NULL</span>, errp);

<span style="color: #BFEBBF;">out</span>:
    object_unref(cpu);
}
</pre>
</div>
<p>
object_new函数定义如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">Object</span> *<span style="color: #93E0E3;">object_new</span>(<span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">typename</span>)
{
    <span style="color: #7CB8BB;">TypeImpl</span> *<span style="color: #DFAF8F;">ti</span> = type_get_by_name(typename);

    <span style="color: #F0DFAF; font-weight: bold;">return</span> object_new_with_type(ti);
}
</pre>
</div>
<p>
从object_new函数定义可以看到，type_get_by_name里根据传入的字符串名（cpu_type或typename，在x86-64平台这个串就是qemu64-x86_64-cpu）找到TypeImpl，那么可以想见对应typename的TypeImpl先前就已经放入到type_table哈希表里了，这个流程如下：
</p>
<pre class="example">
main-&gt;qemu_init-&gt;qemu_init_subsystems-&gt;module_call_init-&gt;x86_cpu_register_types-&gt;x86_register_cpudef_types-&gt;x86_register_cpu_model_type-&gt;type_register-&gt;type_register_internal-&gt;type_table_add
</pre>
<p>
注意用于注册到type_table哈希表的TypeInfo在x86_register_cpu_model_type里初始化：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">x86_register_cpu_model_type</span>(<span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">name</span>, <span style="color: #7CB8BB;">X86CPUModel</span> *<span style="color: #DFAF8F;">model</span>)
{
    g_autofree <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">typename</span> = x86_cpu_type_name(name);
    <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">ti</span> = {
        .name = typename,
        .parent = TYPE_X86_CPU,
        .class_init = x86_cpu_cpudef_class_init,
        .class_data = model,
    };

    type_register(&amp;ti);
}
</pre>
</div>
<p>
注意这里ti是个局部变量，插入到type_table的当然不可能就是这个ti，因为局部变量在x86_register_cpu_model_type函数返回时就会销毁，真正插入到type_table的TypeInfo在type_register_internal中调用type_new里会使用malloc函数申请内存，而这里定义的局部ti会在type_new里作为一个构建插入到type_table中ti的信息来源。
</p>

<p>
查看这个局部ti的定义，可以看到被初始化的成员很有限，尤其是在object_new函数里调用object_new_with_type时，要使用instance_size成员作为参数调用g_malloc申请内存，该成员在定义TypeInfo类型的ti变量时没有被初始化，这个成员的初始化流程如下：
</p>
<pre class="example">
main-&gt;qemu_init-&gt;qemu_create_machine-&gt;select_machine-&gt;object_class_get_list-&gt;object_class_foreach-&gt;g_hash_table_foreach-&gt;object_class_foreach_tramp-&gt;type_initialize
</pre>
<p>
type_initialize里有如下代码：
</p>
<div class="org-src-container">
<pre class="src src-c">ti-&gt;instance_size = type_object_get_size(ti);
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">size_t</span> <span style="color: #93E0E3;">type_object_get_size</span>(<span style="color: #7CB8BB;">TypeImpl</span> *<span style="color: #DFAF8F;">ti</span>)
{
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (ti-&gt;instance_size) {
        <span style="color: #F0DFAF; font-weight: bold;">return</span> ti-&gt;instance_size;
    }

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (type_has_parent(ti)) {
        <span style="color: #F0DFAF; font-weight: bold;">return</span> type_object_get_size(type_get_parent(ti));
    }

    <span style="color: #F0DFAF; font-weight: bold;">return</span> 0;
}
</pre>
</div>
<p>
可以看到是在类型初始化时设置instance_size成员，其实际是父TypeImpl的大小，还有很多成员都来自父TypeImpl。在前面x86_register_cpu_model_type函数中定义局部变量ti时，就有parent了，其为TYPE_X86_CPU，就是串x86_64-cpu，这对应的TypeImpl其实就是x86_cpu_type_info，具体定义这里就不展开了。
</p>

<p>
回到object_new函数，现在终于搞清楚了这个函数的第一行变量ti的来龙去脉，在object_new就可以继续调用object_new_with_type，在这里面可以使用得到的ti里的信息去malloc出cpu Object，并返回到x86_cpu_new函数里。
</p>

<p>
回到x86_cpu_new继续分析，随后调用了object_property_set_uint来设置cpu的apic-id属性为刚生成的apic_id。
</p>

<p>
现在详细分析object_property_set_uint函数，按照上面说的它的作用，对它的分析从两个方面来进行，一是apic-id这个属性的设置流程，二是对这个设的值本身进行的操作。
</p>

<p>
先看第一个方面，有一个下面调用的流程：
</p>
<pre class="example">
x86_cpu_new-&gt;object_property_set_uint-&gt;object_property_set_qobject-&gt;object_property_set
</pre>


<p>
最后的object_property_set里面有下面的代码：
</p>
<div class="org-src-container">
<pre class="src src-c">prop-&gt;set(obj, v, name, prop-&gt;opaque, errp);
</pre>
</div>

<p>
所谓第一个方面，就是研究上面的set函数是怎么被设置，进而在这里可以调用起来。x86架构有个Property数组叫x86_cpu_properties，里面定义了所有X86 cpu可能有的Property，针对apic-id属性使用DEFINE_PROP_UINT32宏定义一个类型为Property数组元素：
</p>
</div>
</div>

<div id="outline-container-orgd711611" class="outline-2">
<h2 id="orgd711611"><span class="section-number-2">3.</span> KVM CPU创建</h2>
</div>

<div id="outline-container-org7fd4616" class="outline-2">
<h2 id="org7fd4616"><span class="section-number-2">4.</span> VCPU的运行</h2>
</div>

<div id="outline-container-org2a8ddad" class="outline-2">
<h2 id="org2a8ddad"><span class="section-number-2">5.</span> VCPU的调度</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cauchy(pqy7172@gmail.com)</p>
<p class="date">Created: 2024-01-04 Thu 23:30</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
