<!DOCTYPE html>
<html lang="cn">
<head>
<!-- 2023-08-25 Fri 10:43 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CPU计算虚拟化：KVM与QEMU</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Cauchy(pqy7172@gmail.com)">
<link rel="stylesheet" href="../org-manual.css" type="text/css">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">CPU计算虚拟化：KVM与QEMU</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdd0ae41">1. 虚拟机的创建</a></li>
<li><a href="#orga9d8b4c">2. QEMU CPU创建</a></li>
<li><a href="#orgdb71851">3. KVM CPU创建</a></li>
<li><a href="#org96b4ef6">4. VCPU的运行</a></li>
<li><a href="#org2bf45b5">5. VCPU的调度</a></li>
</ul>
</div>
</div>
<p>
本文主要分析下KVM/QEMU对CPU的虚拟化。KVM/QEMU还完成了许多的功能，比如内存虚拟化，中断虚拟化等，但这些功能不是本文的主题。
</p>

<p>
本文分五个方面来分析CPU的虚拟化，依次展开。
</p>

<div id="outline-container-orgdd0ae41" class="outline-2">
<h2 id="orgdd0ae41"><span class="section-number-2">1.</span> 虚拟机的创建</h2>
<div class="outline-text-2" id="text-1">
<p>
QEMU在初始化阶段，通过如下调用链到kvm_init函数：
</p>
<pre class="example">
main-&gt;qemu_init-&gt;configure_accelerators-&gt;qemu_opts_foreach-&gt;do_configure_accelerator-&gt;accel_init_machine-&gt;kvm_init
</pre>

<p>
在kvm_init函数中有如下代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">KVMState</span> *<span style="color: #DFAF8F;">s</span>;
s = KVM_STATE(ms-&gt;accelerator);
s-&gt;fd = qemu_open_old(<span style="color: #CC9393;">"/dev/kvm"</span>, O_RDWR);
</pre>
</div>
<p>
可以看到，这里打开了/dev/kvm文件，并且将返回的文件描述符保存在了KVMState的fd成员里。将来通过这个fd可以调用ioctl，内核的kvm模块其功能就是通过/dev/kvm设备文件导出的。关于这点后面再详细分析。现在还需要继续详细分析这几行QEMU代码。
</p>

<p>
首先是类型为KVMState的变量s的来源。代码中出现了KVM_STATE宏，QEMU代码中到处充斥中这种大写的宏，其定义都是类似的方式，针对KVM_STATE来说如下代码定义了它：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">DECLARE_INSTANCE_CHECKER</span>(KVMState, KVM_STATE,
                         TYPE_KVM_ACCEL)
</pre>
</div>
<p>
而DECLARE_INSTANCE_CHECKER定义在include/qom/object.h中。
</p>

<p>
简单介绍下qom，qom是QEMU Object Model的简写，是一种用于构建和管理QEMU设备的对象模型。QOM允许以一种层次化和组合性的方式构建虚拟设备，使得设备的模拟和管理更加灵活和可扩展。
</p>

<p>
QOM为设备提供了一种统一的方式来定义和组织属性、方法和信号。每个设备都是一个QOM实例，具有一组属性（例如，CPU的时钟频率、内存大小等）、方法（例如，设备初始化、读取寄存器等）以及可能的信号（事件通知）。同时也提供了更好的代码复用性。
</p>

<p>
在QEMU源代码中，有许多与QOM相关的代码，包括设备的定义、实例化、属性、方法和信号的设置等。
</p>

<p>
说回DECLARE_INSTANCE_CHECKER，其定义为：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">DECLARE_INSTANCE_CHECKER</span>(<span style="color: #DFAF8F;">InstanceType</span>, <span style="color: #DFAF8F;">OBJ_NAME</span>, <span style="color: #DFAF8F;">TYPENAME</span>)      \
        <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">G_GNUC_UNUSED</span> <span style="color: #DFAF8F;">InstanceType</span> *                      \
        OBJ_NAME(<span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">obj</span>)                                       \
        { <span style="color: #F0DFAF; font-weight: bold;">return</span> OBJECT_CHECK(InstanceType, obj, TYPENAME); }
</pre>
</div>
<p>
可以看到，OBJ_NAME作为传进来的参数，被定义为只有一行return的函数，当然这个函数很短，肯定是要内联的，但这不影响在分析代码时，就把它当作函数看待。继续看OBJECT_CHECK：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">OBJECT_CHECK</span>(<span style="color: #DFAF8F;">type</span>, <span style="color: #DFAF8F;">obj</span>, <span style="color: #DFAF8F;">name</span>)                                   \
        ((<span style="color: #7CB8BB;">type</span> *)object_dynamic_cast_assert(OBJECT(obj), (name),        \
                                            __FILE__, __LINE__, __func__))
</pre>
</div>
<p>
看到这里就明白了，其实就是个强转，将传进来的void *指针转换为指向KVMState类型的指针。ms-&gt;accelerator的类型是AccelState，那么想必KVMState的第一个成员就是AccelState类型的成员了，这样它们才能强转。相当于（ms）拥有一个AccelState类型的指针时，而该AccelState来自KVMState，那么可以直接强转为KVMState类型，就可以引用KVMState里除开AccelState外的其它成员了。这种强转其实就是个继承关系了，在各种软件项目里屡见不鲜，不论它们以何种方式（外衣）出现。
</p>

<p>
那么现在就是分析ms-&gt;accelerator的出处了。在accel_init_machine里有：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">accel_init_machine</span>(<span style="color: #7CB8BB;">AccelState</span> *<span style="color: #DFAF8F;">accel</span>, <span style="color: #7CB8BB;">MachineState</span> *<span style="color: #DFAF8F;">ms</span>)
{
        ms-&gt;accelerator = accel;
}
</pre>
</div>
<p>
还需要再往上看父函数，在do_configure_accelerator中：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">do_configure_accelerator</span>(<span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">opaque</span>, <span style="color: #7CB8BB;">QemuOpts</span> *<span style="color: #DFAF8F;">opts</span>, <span style="color: #7CB8BB;">Error</span> **<span style="color: #DFAF8F;">errp</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">acc</span> = qemu_opt_get(opts, <span style="color: #CC9393;">"accel"</span>);
        <span style="color: #7CB8BB;">AccelClass</span> *<span style="color: #DFAF8F;">ac</span> = accel_find(acc);
        <span style="color: #7CB8BB;">AccelState</span> *<span style="color: #DFAF8F;">accel</span>;
        accel = ACCEL(object_new_with_class(OBJECT_CLASS(ac)));
        ret = accel_init_machine(accel, current_machine);
}
</pre>
</div>
<p>
看到这里就明晰了，qemu_opt_get就是根据传入的参数去找accelerator的字符串名字，比如在启动qemu时传入了-enable-kvm，那么这里的acc就是指向串“kvm”了。而accel_find往下一路调用，最后会来到glib提供的g_hash_table_lookup函数，也就是说，包括accelerator在内的很多对象，都会事先存在hash表里，然后后面要用时通过“kvm”这样的key去找，当然真正的key串可能是组合了一些其它的字符，比如kvm-accel，见accel_find-&gt;ACCEL_CLASS_NAME。
</p>

<p>
顺便提下，current_machine也是先在初始化阶段的qemu_create_machine里创建出来：
</p>
<div class="org-src-container">
<pre class="src src-c">current_machine = MACHINE(object_new_with_class(OBJECT_CLASS(machine_class)));
</pre>
</div>

<p>
这里以kvm accelerator这种type类型的对象注册为例，来分析下一个对象的注册到hash表的流程，有此一例，其它对象的注册类似。在accel/kvm/kvm-all.c中，有如下代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">TypeInfo</span> <span style="color: #DFAF8F;">kvm_accel_type</span> = {
        .name = TYPE_KVM_ACCEL,
        .parent = TYPE_ACCEL,
        .instance_init = kvm_accel_instance_init,
        .class_init = kvm_accel_class_init,
        .instance_size = <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(KVMState),
};
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">kvm_type_init</span>(<span style="color: #7CB8BB;">void</span>)
{
        type_register_static(&amp;kvm_accel_type);
}
</pre>
</div>
<p>
从type_register_static一路往下的话，就会看到g_hash_table_insert，这个就和前面通过
g_hash_table_lookup去寻找加速器对应起来了，只有这里insert，后面才能lookup。现在还有唯一一
个问题，那就是kvm_type_init这个函数何时执行，qemu项目的代码里并没有找到直接调用这个函数的
地方。秘密就在这行代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">type_init</span>(kvm_type_init);
</pre>
</div>
<p>
type_init定义如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">type_init</span>(<span style="color: #DFAF8F;">function</span>) module_init(function, MODULE_INIT_QOM)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">module_init</span>(<span style="color: #DFAF8F;">function</span>, <span style="color: #DFAF8F;">type</span>)                                           \
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #F0DFAF; font-weight: bold;">__attribute__</span>((constructor)) <span style="color: #DFAF8F;">do_qemu_init_</span> ## function(<span style="color: #7CB8BB;">void</span>)    \
{                                                                             \
    register_module_init(function, type);                               \ 
}
</pre>
</div>
<p>
可以看到这里用了constructor修饰，被这个gcc属性修饰的函数，会先于main函数的执行，而register_module_init关键的就下面几行：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">ModuleEntry</span> *<span style="color: #DFAF8F;">e</span>;
e-&gt;init = fn;
<span style="color: #93E0E3;">QTAILQ_INSERT_TAIL</span>(l, e, node);
</pre>
</div>
<p>
可以看到也就是把传进来的kvm_type_init给放到了e-&gt;init里，可以理解为先于main执行的这段代码，主要是个注册作用，而真正调用这个动作还是在main里做的：
</p>
<pre class="example">
main-&gt;qemu_init-&gt;qemu_init_subsystems-&gt;module_call_init-&gt;kvm_type_init
</pre>


<p>
上述流程当然是先于configure_accelerator里通过accel_find去寻找加速器的，也就是main调用的qemu_init函数里，是先调用qemu_init_subsystems而后调用configure_accelerator的。
</p>

<p>
继续看给accel真正分配空间就是在object_new_with_with_class里了：
</p>
<pre class="example">
object_new_with_class-&gt;object_new_with_type-&gt;g_malloc
</pre>


<p>
这里又出现了大写的ACCEL宏，可以想见其作用无非就是强转指针类型了：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">ACCEL</span>(<span style="color: #DFAF8F;">obj</span>)                                      \
        OBJECT_CHECK(AccelState, (obj), TYPE_ACCEL)
</pre>
</div>
<p>
到现在就有了一个KVMState，现在回过头来给出KVMState的一些作用，可以理解为内核实现了KVM模块，那么它在QEMU这样的用户程序里有一个代表就是KVMState，其中的fd成员就保存了打开/dev/kvm时返回的fd。每次运行一个QEMU程序，就会申请一个这个结构体。
</p>

<p>
回到kvm_init函数，再往下有如下重要的代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">do</span>{
        ret = kvm_ioctl(s, KVM_CREATE_VM, type);
 } <span style="color: #F0DFAF; font-weight: bold;">while</span> (ret == -EINTR);
s-&gt;vmfd = ret;
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">kvm_ioctl</span>(<span style="color: #7CB8BB;">KVMState</span> *<span style="color: #DFAF8F;">s</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">type</span>, ...)
{
        ret = ioctl(s-&gt;fd, type, arg);
        <span style="color: #F0DFAF; font-weight: bold;">return</span> ret;
}
</pre>
</div>
<p>
可以看到这里就使用了前面打开/dev/kvm的fd来调用ioctl，这个ioctl支持KVM_CREATE_VM这样的命令，在内核里的实现是kvm_dev_ioctl。并且将返回的ret文件描述符保存到了KVMState的vmfd成员，将来又可以在这个fd上调用它的ioctl，比如创建vcpu，在内核里对应这个vmfd的ioctl函数实现是kvm_vm_ioctl。关于这点后面还会分析。
</p>

<p>
<b>可以总结下，通过调用qemu_open_old函数，由/dev/kvm文件得到的fd，表示了一个KVM模块功能的合集，而通过KVM_CREATE_VM命令在/dev/kvm上的fd调用ioctl得到的vmfd，表示了一台虚拟机。</b>
</p>

<p>
在分析内核侧前，想特别的提下，QEMU作为一个用户程序，不论其代码怎么写，其起始入口函数都是softmmu/main.c:main，从这里入口会运行很多复杂的流程。而分析代码从这个函数起始，也算是扭住了千头万绪的线头。一些流程上先后顺序的确定也会很清晰。
</p>

<p>
现在可以看下内核KVM侧关于虚拟机创建的实现了。首先是初始化阶段/dev/kvm设备文件的注册，只有注册好了这个文件，用户程序才能open它，并在这上面使用ioctl函数。
</p>

<p>
内核的虚拟化实现是作为一个模块而存在，amd的svm，和intel的vmx实现不一样。但是内核抽出了公共部分在virt/kvm下。具体来说，针对/dev/kvm的初始化注册，由kvm_init函数里调用misc_register来实现。而对kvm_init的调用，对于intel来说就是arch/x86/kvm/vmx/vmx.c：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">module_init</span>(vmx_init);
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">__init</span> vmx_init(<span style="color: #7CB8BB;">void</span>)
{
        r = kvm_init(&amp;vmx_x86_ops, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">vcpu_vmx</span>),
                     __alignof__(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">vcpu_vmx</span>), THIS_MODULE);
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">kvm_init</span>(<span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">opaque</span>, <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">vcpu_size</span>, <span style="color: #7CB8BB;">unsigned</span> <span style="color: #DFAF8F;">vcpu_align</span>,
             <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">module</span> *<span style="color: #DFAF8F;">module</span>)
{
        r = misc_register(&amp;kvm_dev);
}
</pre>
</div>
<p>
这里的kvm_dev定义为：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file_operations</span> <span style="color: #DFAF8F;">kvm_chardev_ops</span> = {
        .unlocked_ioctl = kvm_dev_ioctl,
        .llseek         = noop_llseek,
        KVM_COMPAT(kvm_dev_ioctl),
};

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">miscdevice</span> <span style="color: #DFAF8F;">kvm_dev</span> = {
        KVM_MINOR,
        <span style="color: #CC9393;">"kvm"</span>,
        &amp;kvm_chardev_ops,
};
</pre>
</div>
<p>
可以看到，/dev/kvm文件关联的fop就是kvm_chardev_ops，对/dev/kvm使用ioctl时，就会来到kvm_dev_ioctl函数。现在主要关心kvm_ioctl以KVM_CREATE_VM调用ioctl时的内核代码，在这个命令下，内核会进入kvm_dev_ioctl_create_vm函数。该函数比较关键的流程如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">r</span>;
<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">kvm</span> *<span style="color: #DFAF8F;">kvm</span>;
kvm = kvm_create_vm(type);
r = get_unused_fd_flags(O_CLOEXEC);
file = anon_inode_getfile(<span style="color: #CC9393;">"kvm-vm"</span>, &amp;kvm_vm_fops, kvm, O_RDWR);
<span style="color: #93E0E3;">fd_install</span>(r, file);
<span style="color: #F0DFAF; font-weight: bold;">return</span> r;
</pre>
</div>
<p>
先是创建一个kvm结构体，一台vm都有一个kvm结构体，而kvm结构体里有内核对VCPU的表示比如kvm_cpu结构体，所有VCPU都在vcpus数组里，也有mm_struct结构体，vm所用的虚拟内存就是用户进程的虚拟地址空间，当然还有其它很多信息。
</p>

<p>
然后通过get_unused_fd_flags得到一个文件描述符r，最后返回的是这个文件描述符。随后调用anon_inode_getfile分配一个匿名的inode，file-&gt;private_data就是kvm，将来通过这个file（或fd）都可以找到kvm结构体。当然，fd和file要关联到当前进程的打开文件描述符表current-&gt;files里，后面通过fdget函数得到fd关联的file。
</p>

<p>
前面已经总结强调过了，get_unused_fd_flags返回的vmfd就是代表了一台虚拟机，Linux一切皆文件，针对这个文件（虚拟机），其操作的函数集就是kvm_vm_fops，这个fops里最关键的就是kvm_vm_ioctl函数了。比如针对一台虚拟机可以创建vcpu，这些事情都是后面小节的主题了。
</p>

<p>
总之到目前，总算是有了一台虚拟机，对比真实硬件机器来说，可以理解为主板以及上面的插槽这些都做好了，就等后面插上CPU（创建VCPU），插上需要的外设等。
</p>
</div>
</div>
<div id="outline-container-orga9d8b4c" class="outline-2">
<h2 id="orga9d8b4c"><span class="section-number-2">2.</span> QEMU CPU创建</h2>
</div>

<div id="outline-container-orgdb71851" class="outline-2">
<h2 id="orgdb71851"><span class="section-number-2">3.</span> KVM CPU创建</h2>
</div>

<div id="outline-container-org96b4ef6" class="outline-2">
<h2 id="org96b4ef6"><span class="section-number-2">4.</span> VCPU的运行</h2>
</div>

<div id="outline-container-org2bf45b5" class="outline-2">
<h2 id="org2bf45b5"><span class="section-number-2">5.</span> VCPU的调度</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cauchy(pqy7172@gmail.com)</p>
<p class="date">Created: 2023-08-25 Fri 10:43</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
