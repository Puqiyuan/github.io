#+TITLE: 系统编程概要
#+AUTHOR: Cauchy(pqy7172@gmail.com)
#+EMAIL: pqy7172@gmail.com
#+HTML_HEAD: <link rel="stylesheet" href="../org-manual.css" type="text/css">

本系列文章是为系统软件开发者准备的，系统软件开发者是指编写操作系统、加载器、链接器、设备驱动或者其它请求访问系统资源的程序。这些系统资源通常只能提供给具有最高权限级的软件（CPL=0），权限以及它们的交互在后面的系列文章介绍。

本章主要介绍AMD64架构提供给系统软件开发者的基本功能，这些概念包括：
- 支持的地址形式以及内存是怎样组织的。
- 内存管理硬件是怎样利用各种形式的地址去访问内存。
- 处理器操作模式，以及内存管理是怎样支持这些模式的。
- 用来管理系统资源的系统控制器。
- 中断与异常机制，以及它们是怎样打断程序的执行从而报告错误。
- 此外，一些其它的功能也会提供给系统软件，包括硬件多任务的支持，报告Machine-check异常，调试软件以及优化程序性能。

为了支持64-bit的操作系统和应用，许多遗留下来的功能或特点都有被加强，但同时也向后兼容已经存在的软件。

* 内存模型
ADM64架构的内存模型被设计成系统软件可以以安全的方式去管理应用软件以及相关的数据，它可以和旧版的内存模型兼容。对于虚拟地址和物理地址之间的转换由硬件机制完成。硬件的翻译机制允许系统软件以透明的方式重定位应用和数据，可以定位到物理内存空间或者是硬盘空间，这些空间都是由系统软件管理的。

在long mode模式下，AMD64架构实现的是平坦(flat)内存模型。

** 内存寻址
AMD64架构支持地址重定位，为了做到这点，几种类型的地址被定义用来完整的描述内存组织，共计四种：
- 逻辑地址
- 有效地址，或者叫段偏移，是逻辑地址的一部分。
- 线性（虚拟）地址
- 物理地址

*逻辑地址* 一个引用可以到段地址空间。它由段选择子和有效地址组成。在记法上，逻辑地址可以这样表示：
#+BEGIN_QUOTE
Logical Address = Segment Selector : Offset
#+END_QUOTE

段选择子可以用来选定在全局或局部描述符表中的一个条目。这些条目描述了段在虚拟空间中的位置、大小以及其它特性。有效地址表示段中的偏移。

逻辑地址常被称之为远指针。软件中，远指针常被用于寻址时需要显示指明段的场景，也即是引用到非当前段。

*有效地址* 在一个内存段中的偏移被叫做有效地址。有效地址由基础值，标量-索引值以及一个位移组成。有效地址由以下等式表示：

#+BEGIN_QUOTE
Effective Address = Base + (Scale x Index) + Displacement
#+END_QUOTE

上面等式中的几个值这样定义的：
+ Base - 存在通用寄存器中的一个值。
+ Scale - 1，2，4或8中的一个值。
+ Index - 存储在通用寄存器中的二进制补码的值。
+ Displacement - 一个8-bit，16-bit或32-bit的二进制补码的值，编码进指令中，作为一部分。

有效地址也常被叫做近指针，近指针在段选择子隐含知道的情况或平坦内存模式下使用。

Long mode定义了64-bit长的有效地址。如果处理器的实现不支持全64-bit的虚拟地址空间时，那么有效地址必须是规范形式的。

*线性（虚拟）地址*  逻辑地址的段选择子部分指明了选择全局或局部描述符表中的哪个条目（描述符）。被选中的段描述符中包含有段基址，这个地址是段在线性地址空间中的开始位置。线性地址就是将段基址和有效地址加起来，这就可以在线性地址空间中引用任何一个字节了。线性地址也常叫做虚拟地址，也就是等式：
 #+BEGIN_QUOTE
Linear Address = Segment Base Address + Effective Address
 #+END_QUOTE

64-bit模式下使用平坦内存时，段基址都是当作0，这种情况下线性地址和有效地址就等价了。在long
mode下，线性地址必须是规范地址形式。

*物理地址* 物理地址可以引用物理地址空间，通常就是主存。通过分页机制，虚拟地址翻译为物理地址。后面会详细介绍，当分页没有使能时，虚拟（线性）地址就被当作物理地址。

** 内存组织

AMD64架构将内存组织为虚拟内存和物理内存。虚拟内存和物理内存通常具有不同的大小，通常来说虚拟内存比物理内存大。系统软件负责将应用或数据在物理内存和系统硬盘间重定位，这使得看起来系统里有超过物理内存大小可用的内存。

*虚拟内存* 软件使用虚拟地址去访问虚拟内存空间。
* 内存管理
内存管理使用一些方法，总的来说，就是软件生成虚拟地址，然后经由分段或者分页将地址翻译成物理地址。内存管理对应用软件是不可见的，它是由系统软件和处理器硬件完成．

** 分段
分段最开始是用来隔离进程以及这些进程使用的数据，这会增加系统同时运行多个进程的可靠性．

AMD64架构支持各种传统分段（legacy segmentation）功能．然而在传统的X86架构上，许多现代的系统软件都不再使用分段特点．通常使用的是分页来做到程序以及数据的隔离．出于这个原因，AMD64采用平坦内存模型．不使用分段使得新写的64-bit程序能够编码的更加简单．并且比起传统的X86架构，其能更加高效的支持多处理程序．

分段主要用在兼容以及传统模式中．这时，分段是一种基地址的寻址方式，可以允许软件和数据在虚拟地址空间里重定位到任意地址．重定位到虚拟空间的软件或数据可以使用一个或多个变长大小的内存段．传统X86架构提供了多种方式来限制一个段到另一个段的访问，从而保护了软件和数据．

在兼容或传统模式中，最多16383个段可以定义使用．每个段的基址，段大小（也叫limit），保护以及其它属性包含在一个叫做段描述符的数据结构里．段描述符的集合放在段表里．通过段选择子寄存器（segment selector register）从一个段表里选择某个特定的段描述符．总共有六个段选择子寄存器可供提供，这样就支持一次访问六个段．

下面的图展示了分段，具体的细节后文还会介绍．

#+CAPTION: 分段内存模型
#+LABEL: fig:
#+ATTR_HTML: alt="" title="" align="center" :width 30% :height 30%
[[./img/seg-mem-mod.png]]

*平坦分段* 一种特别的分段内存叫做平坦内存模型．在传统的平坦内存模型中，所有的段基址从0开始， 并且段大小固定在4G．但是使用平坦内存模型，可以禁用分段翻译．这样的结果就是虚拟地址等于有效地址．下面的图展示了平坦内存模型的例子．

#+CAPTION: 平坦内存模型
#+LABEL: fig:
#+ATTR_HTML: alt="" title="" align="center" :width 30% :height 30%
[[./img/flat-mem-mod.png]]

运行在64-bit的软件自动使用平坦内存模型．在64-bit模式下，段基址当作0，段大小忽略了．这样允许有效地址去访问全部的虚拟地址空间．

** 分页
分页使得软件和数据可以在物理地址空间中以固定大小的块（物理页面）来进行重定位．传统的X86架构支持三种页面大小，包括4Kb，2Mb，4Mb．使用段翻译权限较低的软件可以限制访问物理页面．

分页使用被叫做页翻译表的分层数据结构将虚拟页面转换为物理页面．取决于物理页面大小和处理器操作模式，翻译表的层级少者可以只有一个，多的可以有四个．翻译表对齐在4K字节处，而物理页面则依据大小对齐在4K字节，2M字节处或者4M字节处．

每个级别的翻译表都由虚拟地址的一部分比特来索引．而表里的条目包含下一更低级别表的基地址．而最低级别的表，它的条目则指向物理页面的基地址．

下面的图展示了一个三级页表的翻译表组织，而后面会更加详细的介绍分页翻译和保护．

#+CAPTION: 分页内存模型
#+LABEL: fig:
#+ATTR_HTML: alt="" title="" align="center" :width 30% :height 30%
[[./img/page-mem-mod.png]]

运行在long mode的软件其分页翻译必须是使能的．
** 分页与分段混合
进行内存管理的软件，可以组合起来使用分段内存和分页内存．因为分段不能禁止，并且分页内存管理也需要初始化一点分段资源．而分页则是可以完全禁止的，所以分段内存管理不需要分页资源的初始化．

段大小的范围可以从一个字节到4G字节不等．因此可以将多个段映射到一个物理页面，也可以将多个物理页面映射到一个段．页和段的边界对齐并不是强制要求，只不过对齐了的话内存管理会更加简单．

最简单且有效的内存管理方法就是平坦内存模型，这时所有段的段基址都为0，而段限长固定在4GB，在内存引用时，分段机制依旧会用到但在这个模式下，虚拟地址和有效地址是一样的，分段机制实质上是忽略了．将虚拟（有效）地址转换为物理地址，实际上仅用了分页机制．

而在64bit模式下，分段禁止了，使用了平坦，分页的内存管理模式，4GB的段限制被忽略了．下面的图展示了这样的例子：

#+CAPTION: 64bit平坦分页内存模型
#+LABEL: fig:
#+ATTR_HTML: alt="" title="" align="center" :width 30% :height 30%
[[./img/64bit-flat.png]]

** 实模式
实模式地址是一种传统模式地址翻译方式，主要用在实模式下．主要是为了兼容8086处理器，在这种模式下，16-bit的有效地址映射到20-bit的物理地址，提供1MB的物理地址空间．

在实模式下，段选择子也会被使用到，不过不是作为描述符表的索引．而是，16-bit的段选择子左移4bit形成20-bit的段基址．16-bit的有效地址会加到这个20-bit的段基址，形成最后的20-bit物理地址．

A20地址线仅在实模式下使用，其它模式下使用会导致地址翻译错误．下面的图展示了实模式地址翻译：

#+CAPTION: 实模式内存模型
#+LABEL: fig:
#+ATTR_HTML: alt="" title="" align="center" :width 30% :height 30%
[[./img/real_mode.png]]

* 操作模式
传统x86架构支持四种操作模式，可以支持各种内存管理，比如各种虚拟内存和物理内存大小，以及不同的保护功能：

+ 实模式
+ 保护模式
+ 虚拟8086模式
+ 系统管理模式

AMD64架构支持所有这些传统模式，并且它加入了一个新的操作模式叫做long mode．下面的表展示了这些模式间的不同：
#+CAPTION: 操作模式
#+LABEL: fig:
#+ATTR_HTML: alt="" title="" align="center" :width 30% :height 30%
[[./img/operating-mode.png]]

而软件可以通过下图在各种模式间移动：
#+CAPTION: AMD64架构的操作模式
#+LABEL: fig:
#+ATTR_HTML: alt="" title="" align="center" :width 30% :height 30%
[[./img/operating-mode-convert.png]]

** Long模式
Long模式由两个子模式组成，一是64-bit模式，二是兼容模式．64-bit支持几个新的特点，包括寻址64-bit虚拟地址空间．兼容模式可以提供与16-bit以及32-bit的二进制兼容．

在使能和激活long模式前，系统软件必须先使能保护模式．关于使能和激活long模式的过程后文还会介绍．

** 64-bit模式
64bit-mode作为long mode的一种子模式．主要支持以下特点：
+ 64bit的虚拟地址．
+ 可以访问通用目的寄存器的63:32位
+ 通过rex，vex以及xop指令前缀可以访问一些寄存器：
  + 8个GPR(R8-R15).
  + 8个流SIMD扩展寄存器(SSE)(YMM/XMM8-15).
+ 64-bit指令指针(RIP).
+ 新的RIP相对数据索引模式.
+ 平坦的段地址空间．
  
** 兼容模式
兼容模式是long模式的一种子模式．
** 传统模式
传统模式包括三种子模式：实模式，保护模式以及虚拟模式．
** 系统管理模式
系统管理模式（SMM）主要是用于系统控制活动，这个对传统系统软件是透明的．
* 系统寄存器
下面的图展示了AMD64架构下的系统寄存器．
#+CAPTION: 
#+LABEL: fig:
#+ATTR_HTML: alt="" title="" align="center" :width 30% :height 30%
[[./img/sys-regs.png]]

系统软件使用这些寄存器来管理处理器的操作环境，包括定义系统资源的特性，监视软件的执行．这些系统寄存器包括：

+ 控制寄存器(Control Register)：用于控制系统操作和某些系统特点．
+ 系统标志寄存器(System-Flags Register)：包含系统状态标志．
+ 描述符表寄存器(Descriptor-Table Register)：这些寄存器包含描述符表的位置与大小（在内存里）．
+ 任务寄存器(Task Register)：包含任务状态段在内存里的位置和大小．硬件多任务机制使用任务状态段来存放一个给定任务的信息．
+ 调试寄存器(Debug Registers)：控制软件的Debug机制，并且可以将调试信息返回给应用程序．
+ 性能监视寄存器：用来计数处理器以及系统事件．
+ 机器检查寄存器：控制着处理器对不可恢复的失败作出何反映．
* 系统数据结构
下面的图展示了对于AMD64架构的一些系统数据结构：
#+CAPTION: 系统数据结构
#+LABEL: fig:
#+ATTR_HTML: alt="" title="" align="center" :width 30% :height 30%
[[./img/sys-data-struct.png]]

系统数据结构由系统软件创建及维护，处理器处于保护模式时会使用．运行在保护模式的处理器会使用这些结构体去管理内存与实现保护机制，并且在中断或任务切换发生时存储程序的状态信息．

如图所示，这些系统数据结构体包括：
+ 描述符：一个描述符提供一个段的位置，大小以及权限级别信息给处理器．有一种特别的描述符，叫门（gate），可以提供代码选择子以及软件程序的入口点．
+ 描述符表：用来存放描述符．全局描述符表存放的描述符可以供所有程序使用，而局部描述符表存放的描述符仅由一个程序使用．而中断描述符表存放的门描述符仅由中断句柄使用．系统软件必须初始化全局描述符以及中断描述符表，而使用局部描述符却是可选的．
+ 任务状态段：任务状态段是一个特别的段，可以存放一个任务的处理器状态信息．
+ 页翻译表：在保护模式下使用页翻译机制是可选的，但在long模式下却是必须的．四级页翻译数据结构可以在long模式下将64-bit的虚拟地址空间翻译为52-bit的物理地址空间．
* 中断
当中断或异常发生时，AMD64架构提供一种机制，可以自动的暂停软件的执行并且将控制权交给中断句柄．一个中断句柄具有较高的权限级，可以识别并且响应中断或异常，完成后将控制权返回给被中断的软件．

中断句柄是高权限级的软件，用来识别并且对中断或异常作出响应．中断可以由系统硬件的信号触发，中断也可以由软件执行中断指令而引起．

系统软件不仅会设置中断句柄，还会创建和初始化各种数据结构，这些结构体用于中断发生时．这些数据结构包括对于中断句柄的代码段描述符，以及其它的数据段．中断门描述符也必须提供．中断门指向中断句柄代码段描述符，以及中断句柄的入口点．中断门存储在中断描述符表里．代码段以及数据段描述符存在全局描述符表里，当然也可以存放在局部描述符表里．

当中断发生时，处理器使用中断向量在中断描述符表里找寻恰当的中断门．中断门指向中断句柄的代码段以及入口点，处理器就会转入到相应的位置．而在调用中断句柄之前，处理器会存放一些信息，以便处理完中断后返回到程序代码．后面还会有细节．

下面的表展示了支持的中断和异常，以它们的向量号码而排序，后面会更加详细的介绍它们．

#+CAPTION: 中断与异常
#+LABEL: fig:
#+ATTR_HTML: alt="" title="" align="center" :width 30% :height 30%
[[./img/interrupt.png]]


* 其它系统编程功能
** 硬件多任务
一个任务就是一个程序，处理器可以执行，暂停并且在随后恢复到暂停时的点继续执行．在任务暂停期间，其它任务又可以执行．每个任务都有它自己的执行环境，由代码段，数据段以及栈段组成．任务也有它们自己的虚拟内存环境，其由分页机制管理．定义执行环境的状态信息存放在任务状态段(TSS)里，每个任务都有．


** 机器检查
** 软件调试
** 性能检测
